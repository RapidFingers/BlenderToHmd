# Generated by Haxe 3.4.2 (git build master @ 890f8c7)
# coding: utf-8

from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
import functools as python_lib_Functools
import builtins as python_lib_Builtins
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import random as python_lib_Random
import re as python_lib_Re
import subprocess as python_lib_Subprocess
import sys as python_lib_Sys
try:
    import termios as python_lib_Termios
except:
    pass
import time as python_lib_Time
import timeit as python_lib_Timeit
try:
    import tty as python_lib_Tty
except:
    pass
from io import StringIO as python_lib_io_StringIO
import urllib.parse as python_lib_urllib_Parse


class _hx_AnonObject:
    def __init__(self, fields):
        self.__dict__ = fields


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")

Enum._hx_class = Enum


class Class:
    _hx_class_name = "Class"
Class._hx_class = Class


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date",)
    _hx_fields = ["date"]
    _hx_methods = ["toString"]
    _hx_statics = ["EPOCH_UTC", "now", "fromTime", "UTC", "datetimeTimestamp", "fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0)

    def toString(self):
        m = ((self.date.month - 1) + 1)
        d = self.date.day
        h = self.date.hour
        mi = self.date.minute
        s = self.date.second
        return ((((((((((Std.string(self.date.year) + "-") + HxOverrides.stringOrNull(((("0" + Std.string(m)) if ((m < 10)) else ("" + Std.string(m)))))) + "-") + HxOverrides.stringOrNull(((("0" + Std.string(d)) if ((d < 10)) else ("" + Std.string(d)))))) + " ") + HxOverrides.stringOrNull(((("0" + Std.string(h)) if ((h < 10)) else ("" + Std.string(h)))))) + ":") + HxOverrides.stringOrNull(((("0" + Std.string(mi)) if ((mi < 10)) else ("" + Std.string(mi)))))) + ":") + HxOverrides.stringOrNull(((("0" + Std.string(s)) if ((s < 10)) else ("" + Std.string(s))))))

    @staticmethod
    def now():
        d = Date(1970,0,1,0,0,0)
        d.date = python_lib_datetime_Datetime.now()
        return d

    @staticmethod
    def fromTime(t):
        d = Date(1970,0,1,0,0,0)
        d.date = python_lib_datetime_Datetime.fromtimestamp((t / 1000.0))
        return d

    @staticmethod
    def UTC(year,month,day,hour,_hx_min,sec):
        return Date.datetimeTimestamp(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0,python_lib_datetime_Timezone.utc),Date.EPOCH_UTC)

    @staticmethod
    def datetimeTimestamp(dt,epoch):
        return ((dt - epoch).total_seconds() * 1000)

    @staticmethod
    def fromString(s):
        _g = len(s)
        if (_g == 8):
            k = s.split(":")
            return Date(0,0,0,Std.parseInt((k[0] if 0 < len(k) else None)),Std.parseInt((k[1] if 1 < len(k) else None)),Std.parseInt((k[2] if 2 < len(k) else None)))
        elif (_g == 10):
            k1 = s.split("-")
            return Date(Std.parseInt((k1[0] if 0 < len(k1) else None)),(Std.parseInt((k1[1] if 1 < len(k1) else None)) - 1),Std.parseInt((k1[2] if 2 < len(k1) else None)),0,0,0)
        elif (_g == 19):
            k2 = s.split(" ")
            y = (k2[0] if 0 < len(k2) else None).split("-")
            t = (k2[1] if 1 < len(k2) else None).split(":")
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise _HxException(("Invalid date format : " + ("null" if s is None else s)))

Date._hx_class = Date


class Dumper:
    _hx_class_name = "Dumper"
    __slots__ = ()
    _hx_statics = ["main"]

    @staticmethod
    def main():
        convert = hxd_fs_ConvertFBX2HMD()
        path = (HxOverrides.stringOrNull(sys_FileSystem.absolutePath(".")) + "/res")
        convert.srcBytes = sys_io_File.getBytes((("" + ("null" if path is None else path)) + "/cube.fbx"))
        convert.srcFilename = "cube.fbx"
        convert.srcPath = path
        convert.dstPath = (("" + ("null" if path is None else path)) + "/cube.hmd")
        convert.convert()
        hmd = sys_io_File.getBytes((("" + ("null" if path is None else path)) + "/cube.hmd"))
        print(str(haxe_format_JsonPrinter.print(hxd_fmt_hmd_Reader(haxe_io_BytesInput(hmd,0,hmd.length)).read(),None," ")))
Dumper._hx_class = Dumper


class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["replace"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g1 = 0
        _g = len(opt)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def replace(self,s,by):
        _this = by.split("$$")
        by1 = "_hx_#repl#__".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_0(x):
            res = by1
            g = x.groups()
            _g1 = 0
            _g = len(g)
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = ("$" + HxOverrides.stringOrNull(str((i + 1))))
                _this1 = (list(res) if ((delimiter == "")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,'') for x1 in _this1])
            _this2 = res.split("_hx_#repl#__")
            res = "$".join([python_Boot.toString1(x1,'') for x1 in _this2])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

EReg._hx_class = EReg


class EnumValue:
    _hx_class_name = "EnumValue"
EnumValue._hx_class = EnumValue


class Lambda:
    _hx_class_name = "Lambda"
    __slots__ = ()
    _hx_statics = ["indexOf"]

    @staticmethod
    def indexOf(it,v):
        i = 0
        v2 = HxOverrides.iterator(it)
        while v2.hasNext():
            if (v == v2.next()):
                return i
            i = (i + 1)
        return -1
Lambda._hx_class = Lambda


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field", "setField", "isFunction", "compare"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return hasattr(f,"func_code")
        else:
            return True

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif (a == b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["is", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def _hx_is(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return True
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        tmp2 = None
        tmp3 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            if ((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))):
                tmp3 = (not python_lib_Math.isnan(f))
            else:
                tmp3 = False
        else:
            tmp3 = False
        if tmp3:
            tmp4 = None
            try:
                tmp4 = int(v)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp4 = None
            tmp2 = (v == tmp4)
        else:
            tmp2 = False
        if tmp2:
            tmp1 = (v <= 2147483647)
        else:
            tmp1 = False
        if tmp1:
            tmp = (v >= -2147483648)
        else:
            tmp = False
        if tmp:
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp5 = None
        try:
            tmp5 = isinstance(v,t)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp5 = False
        if tmp5:
            return True
        if python_lib_Inspect.isclass(t):
            loop = None
            def _hx_local_1(intf):
                f1 = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f1 is not None):
                    _g = 0
                    while (_g < len(f1)):
                        i = (f1[_g] if _g >= 0 and _g < len(f1) else None)
                        _g = (_g + 1)
                        if HxOverrides.eq(i,t):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            loop1 = loop
            currentClass = v.__class__
            while (currentClass is not None):
                if loop1(currentClass):
                    return True
                currentClass = python_Boot.getSuperClass(currentClass)
            return False
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            try:
                if (HxString.substr(x,0,2).lower() == "0x"):
                    return int(x,16)
                raise _HxException("fail")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                x1 = Std.parseFloat(x)
                r = None
                try:
                    r = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    r = None
                if (r is None):
                    r1 = Std.shortenPossibleNumber(x)
                    if (r1 != x):
                        return Std.parseInt(r1)
                    else:
                        return None
                return r

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g1 = 0
        _g = len(x)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            elif (((((((((((_g2 == 57) or ((_g2 == 56))) or ((_g2 == 55))) or ((_g2 == 54))) or ((_g2 == 53))) or ((_g2 == 52))) or ((_g2 == 51))) or ((_g2 == 50))) or ((_g2 == 49))) or ((_g2 == 48))) or ((_g2 == 46))):
                r = (("null" if r is None else r) + ("null" if c is None else c))
            else:
                break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN
Std._hx_class = Std


class Float:
    _hx_class_name = "Float"
Float._hx_class = Float


class Int:
    _hx_class_name = "Int"
Int._hx_class = Int


class Bool:
    _hx_class_name = "Bool"
Bool._hx_class = Bool


class Dynamic:
    _hx_class_name = "Dynamic"
Dynamic._hx_class = Dynamic


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

StringBuf._hx_class = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["startsWith", "endsWith", "isSpace", "ltrim", "rtrim", "trim", "lpad"]

    @staticmethod
    def startsWith(s,start):
        if (len(s) >= len(start)):
            return (HxString.substr(s,0,len(start)) == start)
        else:
            return False

    @staticmethod
    def endsWith(s,end):
        elen = len(end)
        slen = len(s)
        if (slen >= elen):
            return (HxString.substr(s,(slen - elen),elen) == end)
        else:
            return False

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        while (len(s) < l):
            s = (("null" if c is None else c) + ("null" if s is None else s))
        return s
StringTools._hx_class = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["fullPath", "absolutePath"]

    @staticmethod
    def fullPath(relPath):
        return python_lib_os_Path.realpath(relPath)

    @staticmethod
    def absolutePath(relPath):
        if haxe_io_Path.isAbsolute(relPath):
            return relPath
        return haxe_io_Path.join([Sys.getCwd(), relPath])
sys_FileSystem._hx_class = sys_FileSystem


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
    _hx_methods = ["get", "set"]
haxe_IMap._hx_class = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "keys", "iterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has

python_HaxeIterator._hx_class = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["environ", "time", "exit", "print", "println", "args", "getEnv", "putEnv", "environment", "sleep", "setTimeLocale", "getCwd", "setCwd", "systemName", "command", "cpuTime", "executablePath", "_programPath", "programPath", "getChar", "stdin", "stdout", "stderr"]

    @staticmethod
    def time():
        return python_lib_Time.time()

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def print(v):
        python_Lib.print(v)

    @staticmethod
    def println(v):
        python_Lib.println(v)

    @staticmethod
    def args():
        return python_lib_Sys.argv[1:None]

    @staticmethod
    def getEnv(s):
        return Sys.environ.h.get(s,None)

    @staticmethod
    def putEnv(s,v):
        python_lib_Os.putenv(s,v)
        Sys.environ.h[s] = v

    @staticmethod
    def environment():
        return Sys.environ

    @staticmethod
    def sleep(seconds):
        python_lib_Time.sleep(seconds)

    @staticmethod
    def setTimeLocale(loc):
        return False

    @staticmethod
    def getCwd():
        return python_lib_Os.getcwd()

    @staticmethod
    def setCwd(s):
        python_lib_Os.chdir(s)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        if StringTools.startsWith(_g,"linux"):
            return "Linux"
        else:
            _hx_local_0 = len(_g)
            if (_hx_local_0 == 5):
                if (_g == "win32"):
                    return "Windows"
                else:
                    raise _HxException("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g == "cygwin"):
                    return "Windows"
                elif (_g == "darwin"):
                    return "Mac"
                else:
                    raise _HxException("not supported platform")
            else:
                raise _HxException("not supported platform")

    @staticmethod
    def command(cmd,args = None):
        if (args is None):
            return python_lib_Subprocess.call(cmd,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'shell': True})))
        else:
            return python_lib_Subprocess.call(([cmd] + args))

    @staticmethod
    def cpuTime():
        return python_lib_Timeit.default_timer()

    @staticmethod
    def executablePath():
        return python_internal_ArrayImpl._get(python_lib_Sys.argv, 0)

    @staticmethod
    def programPath():
        return Sys._programPath

    @staticmethod
    def getChar(echo):
        ch = None
        _g = Sys.systemName()
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 5):
            if (_g == "Linux"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                a1 = fd
                a2 = python_lib_Termios.TCSADRAIN
                a3 = old
                def _hx_local_1():
                    python_lib_Termios.tcsetattr(a1,a2,a3)
                restore = _hx_local_1
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    restore()
                    raise _HxException(e)
            else:
                raise _HxException((("platform " + ("null" if _g is None else _g)) + " not supported"))
        elif (_hx_local_0 == 3):
            if (_g == "Mac"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                a1 = fd
                a2 = python_lib_Termios.TCSADRAIN
                a3 = old
                def _hx_local_2():
                    python_lib_Termios.tcsetattr(a1,a2,a3)
                restore = _hx_local_2
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    restore()
                    raise _HxException(e)
            else:
                raise _HxException((("platform " + ("null" if _g is None else _g)) + " not supported"))
        elif (_hx_local_0 == 7):
            if (_g == "Windows"):
                ch = HxString.charCodeAt(python_lib_Msvcrt.getch().decode("utf-8"),0)
            else:
                raise _HxException((("platform " + ("null" if _g is None else _g)) + " not supported"))
        else:
            raise _HxException((("platform " + ("null" if _g is None else _g)) + " not supported"))
        if echo:
            python_Lib.print("".join(map(chr,[ch])))
        return ch

    @staticmethod
    def stdin():
        return python_io_IoTools.createFileInputFromText(python_lib_Sys.stdin)

    @staticmethod
    def stdout():
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stdout)

    @staticmethod
    def stderr():
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stderr)
Sys._hx_class = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, [c])

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, [e])
ValueType.TNull = ValueType("TNull", 0, list())
ValueType.TInt = ValueType("TInt", 1, list())
ValueType.TFloat = ValueType("TFloat", 2, list())
ValueType.TBool = ValueType("TBool", 3, list())
ValueType.TObject = ValueType("TObject", 4, list())
ValueType.TFunction = ValueType("TFunction", 5, list())
ValueType.TUnknown = ValueType("TUnknown", 8, list())
ValueType._hx_class = ValueType


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["getClass", "getClassName", "getEnumConstructs", "typeof", "enumEq", "allEnums"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        if ((o is not None) and (((o == str) or python_lib_Inspect.isclass(o)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None

    @staticmethod
    def getEnumConstructs(e):
        if hasattr(e,"_hx_constructs"):
            x = e._hx_constructs
            return list(x)
        else:
            return []

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown

    @staticmethod
    def enumEq(a,b):
        if (a == b):
            return True
        try:
            if ((b is None) and ((a != b))):
                return False
            if (a.tag != b.tag):
                return False
            p1 = a.params
            p2 = b.params
            if (len(p1) != len(p2)):
                return False
            _g1 = 0
            _g = len(p1)
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                if (not Type.enumEq((p1[i] if i >= 0 and i < len(p1) else None),(p2[i] if i >= 0 and i < len(p2) else None))):
                    return False
            if (a._hx_class != b._hx_class):
                return False
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return False
        return True

    @staticmethod
    def allEnums(e):
        ctors = Type.getEnumConstructs(e)
        ret = []
        _g = 0
        while (_g < len(ctors)):
            ctor = (ctors[_g] if _g >= 0 and _g < len(ctors) else None)
            _g = (_g + 1)
            v = Reflect.field(e,ctor)
            if Std._hx_is(v,e):
                ret.append(v)
        return ret
Type._hx_class = Type


class Xml:
    _hx_class_name = "Xml"
    __slots__ = ("nodeType", "nodeName", "nodeValue", "parent", "children", "attributeMap")
    _hx_fields = ["nodeType", "nodeName", "nodeValue", "parent", "children", "attributeMap"]
    _hx_methods = ["set", "exists", "elements", "firstElement", "addChild", "removeChild"]
    _hx_statics = ["Element", "PCData", "CData", "Comment", "DocType", "ProcessingInstruction", "Document", "parse", "createElement", "createPCData", "createCData", "createComment", "createDocType", "createProcessingInstruction", "createDocument"]

    def __init__(self,nodeType):
        self.parent = None
        self.nodeValue = None
        self.nodeName = None
        self.nodeType = nodeType
        self.children = []
        self.attributeMap = haxe_ds_StringMap()

    def set(self,att,value):
        if (self.nodeType != Xml.Element):
            raise _HxException(("Bad node type, expected Element but found " + Std.string(self.nodeType)))
        self.attributeMap.h[att] = value

    def exists(self,att):
        if (self.nodeType != Xml.Element):
            raise _HxException(("Bad node type, expected Element but found " + Std.string(self.nodeType)))
        return (att in self.attributeMap.h)

    def elements(self):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + Std.string(self.nodeType)))
        _g = []
        _g1 = 0
        _g2 = self.children
        while (_g1 < len(_g2)):
            child = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            if (child.nodeType == Xml.Element):
                _g.append(child)
        return python_HaxeIterator(_g.__iter__())

    def firstElement(self):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + Std.string(self.nodeType)))
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            child = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (child.nodeType == Xml.Element):
                return child
        return None

    def addChild(self,x):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + Std.string(self.nodeType)))
        if (x.parent is not None):
            x.parent.removeChild(x)
        self.children.append(x)
        x.parent = self

    def removeChild(self,x):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + Std.string(self.nodeType)))
        if python_internal_ArrayImpl.remove(self.children,x):
            x.parent = None
            return True
        return False

    @staticmethod
    def parse(_hx_str):
        return haxe_xml_Parser.parse(_hx_str)

    @staticmethod
    def createElement(name):
        xml = Xml(Xml.Element)
        if (xml.nodeType != Xml.Element):
            raise _HxException(("Bad node type, expected Element but found " + Std.string(xml.nodeType)))
        xml.nodeName = name
        return xml

    @staticmethod
    def createPCData(data):
        xml = Xml(Xml.PCData)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + Std.string(xml.nodeType)))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createCData(data):
        xml = Xml(Xml.CData)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + Std.string(xml.nodeType)))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createComment(data):
        xml = Xml(Xml.Comment)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + Std.string(xml.nodeType)))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createDocType(data):
        xml = Xml(Xml.DocType)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + Std.string(xml.nodeType)))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createProcessingInstruction(data):
        xml = Xml(Xml.ProcessingInstruction)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + Std.string(xml.nodeType)))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createDocument():
        return Xml(Xml.Document)

Xml._hx_class = Xml

class h2d_BlendMode(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.BlendMode"
    _hx_constructs = ["None", "Alpha", "Add", "SoftAdd", "Multiply", "Erase", "Screen"]
h2d_BlendMode._hx_None = h2d_BlendMode("None", 0, list())
h2d_BlendMode.Alpha = h2d_BlendMode("Alpha", 1, list())
h2d_BlendMode.Add = h2d_BlendMode("Add", 2, list())
h2d_BlendMode.SoftAdd = h2d_BlendMode("SoftAdd", 3, list())
h2d_BlendMode.Multiply = h2d_BlendMode("Multiply", 4, list())
h2d_BlendMode.Erase = h2d_BlendMode("Erase", 5, list())
h2d_BlendMode.Screen = h2d_BlendMode("Screen", 6, list())
h2d_BlendMode._hx_class = h2d_BlendMode


class h3d_impl__Serializable_EmptyInterface:
    _hx_class_name = "h3d.impl._Serializable.EmptyInterface"
    __slots__ = ()
h3d_impl__Serializable_EmptyInterface._hx_class = h3d_impl__Serializable_EmptyInterface


class h3d_impl_RenderContext:
    _hx_class_name = "h3d.impl.RenderContext"
    __slots__ = ()
h3d_impl_RenderContext._hx_class = h3d_impl_RenderContext


class h2d_RenderContext(h3d_impl_RenderContext):
    _hx_class_name = "h2d.RenderContext"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_impl_RenderContext

h2d_RenderContext._hx_class = h2d_RenderContext


class h3d_Engine:
    _hx_class_name = "h3d.Engine"
    __slots__ = ("mem", "frameCount", "textureColorCache", "resCache")
    _hx_fields = ["mem", "frameCount", "textureColorCache", "resCache"]
    _hx_statics = ["CURRENT"]

    def __init__(self):
        self.mem = None
        self.resCache = haxe_ds_ObjectMap()
        self.textureColorCache = haxe_ds_IntMap()
        self.frameCount = 0

h3d_Engine._hx_class = h3d_Engine


class h3d_Matrix:
    _hx_class_name = "h3d.Matrix"
    __slots__ = ("_11", "_12", "_13", "_14", "_21", "_22", "_23", "_24", "_31", "_32", "_33", "_34", "_41", "_42", "_43", "_44")
    _hx_fields = ["_11", "_12", "_13", "_14", "_21", "_22", "_23", "_24", "_31", "_32", "_33", "_34", "_41", "_42", "_43", "_44"]
    _hx_methods = ["identity", "initScale", "initRotate", "translate", "scale", "rotate", "prependScale", "multiply", "transpose", "clone", "load"]
    _hx_statics = ["tmp", "L"]

    def __init__(self):
        self._44 = None
        self._43 = None
        self._42 = None
        self._41 = None
        self._34 = None
        self._33 = None
        self._32 = None
        self._31 = None
        self._24 = None
        self._23 = None
        self._22 = None
        self._21 = None
        self._14 = None
        self._13 = None
        self._12 = None
        self._11 = None

    def identity(self):
        self._11 = 1.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 1.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 1.0
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initScale(self,x = 1.,y = 1.,z = 1.):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.
        self._11 = x
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = y
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = z
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotate(self,x,y,z):
        cx = (Math.NaN if (((x == Math.POSITIVE_INFINITY) or ((x == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(x))
        sx = (Math.NaN if (((x == Math.POSITIVE_INFINITY) or ((x == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(x))
        cy = (Math.NaN if (((y == Math.POSITIVE_INFINITY) or ((y == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(y))
        sy = (Math.NaN if (((y == Math.POSITIVE_INFINITY) or ((y == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(y))
        cz = (Math.NaN if (((z == Math.POSITIVE_INFINITY) or ((z == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(z))
        sz = (Math.NaN if (((z == Math.POSITIVE_INFINITY) or ((z == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(z))
        cxsy = (cx * sy)
        sxsy = (sx * sy)
        self._11 = (cy * cz)
        self._12 = (cy * sz)
        self._13 = -sy
        self._14 = 0
        self._21 = ((sxsy * cz) - ((cx * sz)))
        self._22 = ((sxsy * sz) + ((cx * cz)))
        self._23 = (sx * cy)
        self._24 = 0
        self._31 = ((cxsy * cz) + ((sx * sz)))
        self._32 = ((cxsy * sz) - ((sx * cz)))
        self._33 = (cx * cy)
        self._34 = 0
        self._41 = 0
        self._42 = 0
        self._43 = 0
        self._44 = 1

    def translate(self,x = 0.,y = 0.,z = 0.):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 + ((x * self._14)))
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 + ((y * self._14)))
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 + ((z * self._14)))
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 + ((x * self._24)))
        _hx_local_6._21
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 + ((y * self._24)))
        _hx_local_8._22
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 + ((z * self._24)))
        _hx_local_10._23
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 + ((x * self._34)))
        _hx_local_12._31
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 + ((y * self._34)))
        _hx_local_14._32
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 + ((z * self._34)))
        _hx_local_16._33
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._41
        _hx_local_18._41 = (_hx_local_19 + ((x * self._44)))
        _hx_local_18._41
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._42
        _hx_local_20._42 = (_hx_local_21 + ((y * self._44)))
        _hx_local_20._42
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 + ((z * self._44)))
        _hx_local_22._43

    def scale(self,x = 1.,y = 1.,z = 1.):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * x)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._21
        _hx_local_2._21 = (_hx_local_3 * x)
        _hx_local_2._21
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._31
        _hx_local_4._31 = (_hx_local_5 * x)
        _hx_local_4._31
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._41
        _hx_local_6._41 = (_hx_local_7 * x)
        _hx_local_6._41
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._12
        _hx_local_8._12 = (_hx_local_9 * y)
        _hx_local_8._12
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._22
        _hx_local_10._22 = (_hx_local_11 * y)
        _hx_local_10._22
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._32
        _hx_local_12._32 = (_hx_local_13 * y)
        _hx_local_12._32
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._42
        _hx_local_14._42 = (_hx_local_15 * y)
        _hx_local_14._42
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._13
        _hx_local_16._13 = (_hx_local_17 * z)
        _hx_local_16._13
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._23
        _hx_local_18._23 = (_hx_local_19 * z)
        _hx_local_18._23
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._33
        _hx_local_20._33 = (_hx_local_21 * z)
        _hx_local_20._33
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 * z)
        _hx_local_22._43

    def rotate(self,x,y,z):
        tmp = h3d_Matrix.tmp
        tmp.initRotate(x,y,z)
        self.multiply(self,tmp)

    def prependScale(self,sx = 1.,sy = 1.,sz = 1.):
        if (sx is None):
            sx = 1.
        if (sy is None):
            sy = 1.
        if (sz is None):
            sz = 1.
        tmp = h3d_Matrix.tmp
        tmp.initScale(sx,sy,sz)
        self.multiply(tmp,self)

    def multiply(self,a,b):
        a11 = a._11
        a12 = a._12
        a13 = a._13
        a14 = a._14
        a21 = a._21
        a22 = a._22
        a23 = a._23
        a24 = a._24
        a31 = a._31
        a32 = a._32
        a33 = a._33
        a34 = a._34
        a41 = a._41
        a42 = a._42
        a43 = a._43
        a44 = a._44
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b14 = b._14
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b24 = b._24
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b34 = b._34
        b41 = b._41
        b42 = b._42
        b43 = b._43
        b44 = b._44
        self._11 = ((((a11 * b11) + ((a12 * b21))) + ((a13 * b31))) + ((a14 * b41)))
        self._12 = ((((a11 * b12) + ((a12 * b22))) + ((a13 * b32))) + ((a14 * b42)))
        self._13 = ((((a11 * b13) + ((a12 * b23))) + ((a13 * b33))) + ((a14 * b43)))
        self._14 = ((((a11 * b14) + ((a12 * b24))) + ((a13 * b34))) + ((a14 * b44)))
        self._21 = ((((a21 * b11) + ((a22 * b21))) + ((a23 * b31))) + ((a24 * b41)))
        self._22 = ((((a21 * b12) + ((a22 * b22))) + ((a23 * b32))) + ((a24 * b42)))
        self._23 = ((((a21 * b13) + ((a22 * b23))) + ((a23 * b33))) + ((a24 * b43)))
        self._24 = ((((a21 * b14) + ((a22 * b24))) + ((a23 * b34))) + ((a24 * b44)))
        self._31 = ((((a31 * b11) + ((a32 * b21))) + ((a33 * b31))) + ((a34 * b41)))
        self._32 = ((((a31 * b12) + ((a32 * b22))) + ((a33 * b32))) + ((a34 * b42)))
        self._33 = ((((a31 * b13) + ((a32 * b23))) + ((a33 * b33))) + ((a34 * b43)))
        self._34 = ((((a31 * b14) + ((a32 * b24))) + ((a33 * b34))) + ((a34 * b44)))
        self._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + ((a44 * b41)))
        self._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + ((a44 * b42)))
        self._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + ((a44 * b43)))
        self._44 = ((((a41 * b14) + ((a42 * b24))) + ((a43 * b34))) + ((a44 * b44)))

    def transpose(self):
        tmp = self._12
        self._12 = self._21
        self._21 = tmp
        tmp = self._13
        self._13 = self._31
        self._31 = tmp
        tmp = self._14
        self._14 = self._41
        self._41 = tmp
        tmp = self._23
        self._23 = self._32
        self._32 = tmp
        tmp = self._24
        self._24 = self._42
        self._42 = tmp
        tmp = self._34
        self._34 = self._43
        self._43 = tmp

    def clone(self):
        m = h3d_Matrix()
        m._11 = self._11
        m._12 = self._12
        m._13 = self._13
        m._14 = self._14
        m._21 = self._21
        m._22 = self._22
        m._23 = self._23
        m._24 = self._24
        m._31 = self._31
        m._32 = self._32
        m._33 = self._33
        m._34 = self._34
        m._41 = self._41
        m._42 = self._42
        m._43 = self._43
        m._44 = self._44
        return m

    def load(self,a):
        self._11 = (a[0] if 0 < len(a) else None)
        self._12 = (a[1] if 1 < len(a) else None)
        self._13 = (a[2] if 2 < len(a) else None)
        self._14 = (a[3] if 3 < len(a) else None)
        self._21 = (a[4] if 4 < len(a) else None)
        self._22 = (a[5] if 5 < len(a) else None)
        self._23 = (a[6] if 6 < len(a) else None)
        self._24 = (a[7] if 7 < len(a) else None)
        self._31 = (a[8] if 8 < len(a) else None)
        self._32 = (a[9] if 9 < len(a) else None)
        self._33 = (a[10] if 10 < len(a) else None)
        self._34 = (a[11] if 11 < len(a) else None)
        self._41 = (a[12] if 12 < len(a) else None)
        self._42 = (a[13] if 13 < len(a) else None)
        self._43 = (a[14] if 14 < len(a) else None)
        self._44 = (a[15] if 15 < len(a) else None)

    @staticmethod
    def L(a):
        m = h3d_Matrix()
        m.load(a)
        return m

h3d_Matrix._hx_class = h3d_Matrix


class h3d_Quat:
    _hx_class_name = "h3d.Quat"
    __slots__ = ("x", "y", "z", "w")
    _hx_fields = ["x", "y", "z", "w"]
    _hx_methods = ["initRotateMatrix", "normalize", "initRotate", "multiply"]

    def __init__(self,x = 0.,y = 0.,z = 0.,w = 1.):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def initRotateMatrix(self,m):
        tr = ((m._11 + m._22) + m._33)
        if (tr > 0):
            f = (tr + 1.0)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            _hx_is = (1 / s)
            self.x = (((m._23 - m._32)) * _hx_is)
            self.y = (((m._31 - m._13)) * _hx_is)
            self.z = (((m._12 - m._21)) * _hx_is)
            self.w = (0.25 * s)
        elif ((m._11 > m._22) and ((m._11 > m._33))):
            f1 = (((1.0 + m._11) - m._22) - m._33)
            s1 = (((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))) * 2)
            is1 = (1 / s1)
            self.x = (0.25 * s1)
            self.y = (((m._21 + m._12)) * is1)
            self.z = (((m._31 + m._13)) * is1)
            self.w = (((m._23 - m._32)) * is1)
        elif (m._22 > m._33):
            f2 = (((1.0 + m._22) - m._11) - m._33)
            s2 = (((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))) * 2)
            is2 = (1 / s2)
            self.x = (((m._21 + m._12)) * is2)
            self.y = (0.25 * s2)
            self.z = (((m._32 + m._23)) * is2)
            self.w = (((m._31 - m._13)) * is2)
        else:
            f3 = (((1.0 + m._33) - m._11) - m._22)
            s3 = (((Math.NaN if ((f3 < 0)) else python_lib_Math.sqrt(f3))) * 2)
            is3 = (1 / s3)
            self.x = (((m._31 + m._13)) * is3)
            self.y = (((m._32 + m._23)) * is3)
            self.z = (0.25 * s3)
            self.w = (((m._12 - m._21)) * is3)

    def normalize(self):
        _hx_len = ((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((self.w * self.w)))
        if (_hx_len < 1e-10):
            def _hx_local_1():
                def _hx_local_0():
                    self.z = 0
                    return self.z
                self.y = _hx_local_0()
                return self.y
            self.x = _hx_local_1()
            self.w = 1
        else:
            m = (1. / ((Math.NaN if ((_hx_len < 0)) else python_lib_Math.sqrt(_hx_len))))
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.x
            _hx_local_2.x = (_hx_local_3 * m)
            _hx_local_2.x
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.y
            _hx_local_4.y = (_hx_local_5 * m)
            _hx_local_4.y
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.z
            _hx_local_6.z = (_hx_local_7 * m)
            _hx_local_6.z
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.w
            _hx_local_8.w = (_hx_local_9 * m)
            _hx_local_8.w

    def initRotate(self,ax,ay,az):
        f = (ax * 0.5)
        sinX = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f1 = (ax * 0.5)
        cosX = (Math.NaN if (((f1 == Math.POSITIVE_INFINITY) or ((f1 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f1))
        f2 = (ay * 0.5)
        sinY = (Math.NaN if (((f2 == Math.POSITIVE_INFINITY) or ((f2 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f2))
        f3 = (ay * 0.5)
        cosY = (Math.NaN if (((f3 == Math.POSITIVE_INFINITY) or ((f3 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f3))
        f4 = (az * 0.5)
        sinZ = (Math.NaN if (((f4 == Math.POSITIVE_INFINITY) or ((f4 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f4))
        f5 = (az * 0.5)
        cosZ = (Math.NaN if (((f5 == Math.POSITIVE_INFINITY) or ((f5 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f5))
        cosYZ = (cosY * cosZ)
        sinYZ = (sinY * sinZ)
        self.x = ((sinX * cosYZ) - ((cosX * sinYZ)))
        self.y = (((cosX * sinY) * cosZ) + (((sinX * cosY) * sinZ)))
        self.z = (((cosX * cosY) * sinZ) - (((sinX * sinY) * cosZ)))
        self.w = ((cosX * cosYZ) + ((sinX * sinYZ)))

    def multiply(self,q1,q2):
        y2 = ((((q1.w * q2.y) - ((q1.x * q2.z))) + ((q1.y * q2.w))) + ((q1.z * q2.x)))
        z2 = ((((q1.w * q2.z) + ((q1.x * q2.y))) - ((q1.y * q2.x))) + ((q1.z * q2.w)))
        w2 = ((((q1.w * q2.w) - ((q1.x * q2.x))) - ((q1.y * q2.y))) - ((q1.z * q2.z)))
        self.x = ((((q1.x * q2.w) + ((q1.w * q2.x))) + ((q1.y * q2.z))) - ((q1.z * q2.y)))
        self.y = y2
        self.z = z2
        self.w = w2

h3d_Quat._hx_class = h3d_Quat


class h3d_Vector:
    _hx_class_name = "h3d.Vector"
    __slots__ = ("x", "y", "z", "w")
    _hx_fields = ["x", "y", "z", "w"]

    def __init__(self,x = 0.,y = 0.,z = 0.,w = 1.):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

h3d_Vector._hx_class = h3d_Vector


class h3d_anim_AnimatedObject:
    _hx_class_name = "h3d.anim.AnimatedObject"
    __slots__ = ("objectName",)
    _hx_fields = ["objectName"]

    def __init__(self,name):
        self.objectName = name

h3d_anim_AnimatedObject._hx_class = h3d_anim_AnimatedObject


class h3d_anim_Animation:
    _hx_class_name = "h3d.anim.Animation"
    __slots__ = ("name", "frameCount", "sampling", "frame", "speed", "pause", "loop", "objects", "lastEvent")
    _hx_fields = ["name", "frameCount", "sampling", "frame", "speed", "pause", "loop", "objects", "lastEvent"]

    def __init__(self,name,frameCount,sampling):
        self.name = name
        self.frameCount = frameCount
        self.sampling = sampling
        self.objects = []
        self.lastEvent = -1
        self.frame = 0.
        self.speed = 1.
        self.loop = True
        self.pause = False

h3d_anim_Animation._hx_class = h3d_anim_Animation


class h3d_anim_LinearFrame:
    _hx_class_name = "h3d.anim.LinearFrame"
    __slots__ = ("tx", "ty", "tz", "qx", "qy", "qz", "qw", "sx", "sy", "sz")
    _hx_fields = ["tx", "ty", "tz", "qx", "qy", "qz", "qw", "sx", "sy", "sz"]

    def __init__(self):
        self.sz = None
        self.sy = None
        self.sx = None
        self.qw = None
        self.qz = None
        self.qy = None
        self.qx = None
        self.tz = None
        self.ty = None
        self.tx = None

h3d_anim_LinearFrame._hx_class = h3d_anim_LinearFrame


class h3d_anim_LinearObject(h3d_anim_AnimatedObject):
    _hx_class_name = "h3d.anim.LinearObject"
    __slots__ = ("hasRotation", "hasScale", "frames", "alphas", "uvs", "propName", "propValues")
    _hx_fields = ["hasRotation", "hasScale", "frames", "alphas", "uvs", "propName", "propValues"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_AnimatedObject


    def __init__(self,name):
        self.propValues = None
        self.propName = None
        self.uvs = None
        self.alphas = None
        self.frames = None
        self.hasScale = None
        self.hasRotation = None
        super().__init__(name)

h3d_anim_LinearObject._hx_class = h3d_anim_LinearObject


class h3d_anim_LinearAnimation(h3d_anim_Animation):
    _hx_class_name = "h3d.anim.LinearAnimation"
    __slots__ = ("syncFrame",)
    _hx_fields = ["syncFrame"]
    _hx_methods = ["addCurve", "addAlphaCurve", "addUVCurve", "addPropCurve"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_Animation


    def __init__(self,name,frame,sampling):
        self.syncFrame = None
        super().__init__(name,frame,sampling)
        self.syncFrame = -1

    def addCurve(self,objName,frames,hasRot,hasScale):
        f = h3d_anim_LinearObject(objName)
        f.frames = frames
        f.hasRotation = hasRot
        f.hasScale = hasScale
        self.objects.append(f)

    def addAlphaCurve(self,objName,alphas):
        f = h3d_anim_LinearObject(objName)
        f.alphas = alphas
        self.objects.append(f)

    def addUVCurve(self,objName,uvs):
        f = h3d_anim_LinearObject(objName)
        f.uvs = uvs
        self.objects.append(f)

    def addPropCurve(self,objName,propName,values):
        f = h3d_anim_LinearObject(objName)
        f.propName = propName
        f.propValues = values
        self.objects.append(f)

h3d_anim_LinearAnimation._hx_class = h3d_anim_LinearAnimation


class h3d_anim_Joint:
    _hx_class_name = "h3d.anim.Joint"
    __slots__ = ("index", "name", "bindIndex", "splitIndex", "defMat", "transPos", "parent", "subs")
    _hx_fields = ["index", "name", "bindIndex", "splitIndex", "defMat", "transPos", "parent", "subs"]

    def __init__(self):
        self.parent = None
        self.transPos = None
        self.defMat = None
        self.name = None
        self.index = None
        self.bindIndex = -1
        self.splitIndex = -1
        self.subs = []

h3d_anim_Joint._hx_class = h3d_anim_Joint


class h3d_anim__Skin_Permut:
    _hx_class_name = "h3d.anim._Skin.Permut"
    __slots__ = ("joints", "triangles", "material", "indexedJoints")
    _hx_fields = ["joints", "triangles", "material", "indexedJoints"]

    def __init__(self):
        self.indexedJoints = None
        self.material = None
        self.triangles = None
        self.joints = None

h3d_anim__Skin_Permut._hx_class = h3d_anim__Skin_Permut


class h3d_anim__Skin_Influence:
    _hx_class_name = "h3d.anim._Skin.Influence"
    __slots__ = ("j", "w")
    _hx_fields = ["j", "w"]

    def __init__(self,j,w):
        self.j = j
        self.w = w

h3d_anim__Skin_Influence._hx_class = h3d_anim__Skin_Influence


class h3d_anim_Skin:
    _hx_class_name = "h3d.anim.Skin"
    __slots__ = ("name", "vertexCount", "bonesPerVertex", "vertexJoints", "vertexWeights", "rootJoints", "namedJoints", "allJoints", "boundJoints", "splitJoints", "triangleGroups", "envelop")
    _hx_fields = ["name", "vertexCount", "bonesPerVertex", "vertexJoints", "vertexWeights", "rootJoints", "namedJoints", "allJoints", "boundJoints", "splitJoints", "triangleGroups", "envelop"]
    _hx_methods = ["setJoints", "sortInfluences", "initWeights", "sortByBindIndex", "isSub", "merge", "jointsDiff", "split"]

    def __init__(self,name,vertexCount,bonesPerVertex):
        self.envelop = None
        self.triangleGroups = None
        self.splitJoints = None
        self.boundJoints = None
        self.allJoints = None
        self.namedJoints = None
        self.rootJoints = None
        self.vertexWeights = None
        self.vertexJoints = None
        self.name = name
        self.vertexCount = vertexCount
        self.bonesPerVertex = bonesPerVertex
        if (vertexCount > 0):
            self.vertexJoints = [None]*(vertexCount * bonesPerVertex)
            self.vertexWeights = [None]*(vertexCount * bonesPerVertex)
            self.envelop = []

    def setJoints(self,joints,roots):
        self.rootJoints = roots
        self.allJoints = joints
        self.namedJoints = haxe_ds_StringMap()
        _g = 0
        while (_g < len(joints)):
            j = (joints[_g] if _g >= 0 and _g < len(joints) else None)
            _g = (_g + 1)
            if (j.name is not None):
                self.namedJoints.h[j.name] = j

    def sortInfluences(self,i1,i2):
        if (i2.w > i1.w):
            return 1
        else:
            return -1

    def initWeights(self):
        self.boundJoints = []
        pos = 0
        _g1 = 0
        _g = self.vertexCount
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            il = (self.envelop[i] if i >= 0 and i < len(self.envelop) else None)
            if (il is None):
                il = []
            haxe_ds_ArraySort.sort(il,self.sortInfluences)
            if (len(il) > self.bonesPerVertex):
                il = il[0:self.bonesPerVertex]
            tw = 0.
            _g2 = 0
            while (_g2 < len(il)):
                i1 = (il[_g2] if _g2 >= 0 and _g2 < len(il) else None)
                _g2 = (_g2 + 1)
                tw = (tw + i1.w)
            tw = (1 / tw)
            _g3 = 0
            _g21 = self.bonesPerVertex
            while (_g3 < _g21):
                i2 = _g3
                _g3 = (_g3 + 1)
                i3 = (il[i2] if i2 >= 0 and i2 < len(il) else None)
                if (i3 is None):
                    self.vertexJoints[pos] = 0
                    self.vertexWeights[pos] = 0
                else:
                    if (i3.j.bindIndex == -1):
                        i3.j.bindIndex = len(self.boundJoints)
                        x = i3.j
                        self.boundJoints.append(x)
                    val = i3.j.bindIndex
                    self.vertexJoints[pos] = val
                    val1 = (i3.w * tw)
                    self.vertexWeights[pos] = val1
                pos = (pos + 1)
        self.envelop = None

    def sortByBindIndex(self,j1,j2):
        return (j1.bindIndex - j2.bindIndex)

    def isSub(self,a,b):
        j = 0
        _hx_max = len(b)
        _g = 0
        while (_g < len(a)):
            e = (a[_g] if _g >= 0 and _g < len(a) else None)
            _g = (_g + 1)
            while True:
                b1 = j
                j = (j + 1)
                if (not ((e != (b[b1] if b1 >= 0 and b1 < len(b) else None)))):
                    break
                if (j >= _hx_max):
                    return False
                continue
        return True

    def merge(self,permuts):
        _g = 0
        while (_g < len(permuts)):
            p1 = (permuts[_g] if _g >= 0 and _g < len(permuts) else None)
            _g = (_g + 1)
            _g1 = 0
            while (_g1 < len(permuts)):
                p2 = (permuts[_g1] if _g1 >= 0 and _g1 < len(permuts) else None)
                _g1 = (_g1 + 1)
                if (((p1 != p2) and ((p1.material == p2.material))) and self.isSub(p1.joints,p2.joints)):
                    _g2 = 0
                    _g3 = p1.triangles
                    while (_g2 < len(_g3)):
                        t = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                        _g2 = (_g2 + 1)
                        p2.triangles.append(t)
                    python_internal_ArrayImpl.remove(permuts,p1)
                    return True
        return False

    def jointsDiff(self,p1,p2):
        diff = 0
        i = 0
        j = 0
        imax = len(p1.joints)
        jmax = len(p2.joints)
        while ((i < imax) and ((j < jmax))):
            j1 = (p1.joints[i] if i >= 0 and i < len(p1.joints) else None)
            j2 = (p2.joints[j] if j >= 0 and j < len(p2.joints) else None)
            if (j1 == j2):
                i = (i + 1)
                j = (j + 1)
            else:
                diff = (diff + 1)
                if (j1.bindIndex < j2.bindIndex):
                    i = (i + 1)
                else:
                    j = (j + 1)
        return ((diff + ((imax - i))) + ((jmax - j)))

    def split(self,maxBones,index,triangleMaterials):
        if (self.splitJoints is not None):
            return True
        if (len(self.boundJoints) <= maxBones):
            return False
        self.splitJoints = []
        x = (len(index) / 3)
        length = None
        try:
            length = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            length = None
        self.triangleGroups = [None]*length
        permuts = list()
        _g1 = 0
        x1 = (len(index) / 3)
        _g = None
        try:
            _g = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            _g = None
        while (_g1 < _g):
            tri = _g1
            _g1 = (_g1 + 1)
            iid = (tri * 3)
            mid = (0 if ((triangleMaterials is None)) else (triangleMaterials[tri] if tri >= 0 and tri < len(triangleMaterials) else None))
            jl = []
            _g2 = 0
            while (_g2 < 3):
                i = _g2
                _g2 = (_g2 + 1)
                vid = python_internal_ArrayImpl._get(index, (iid + i))
                _g4 = 0
                _g3 = self.bonesPerVertex
                while (_g4 < _g3):
                    b = _g4
                    _g4 = (_g4 + 1)
                    bidx = ((vid * self.bonesPerVertex) + b)
                    if (self.vertexWeights[bidx] == 0):
                        continue
                    j = python_internal_ArrayImpl._get(self.boundJoints, self.vertexJoints[bidx])
                    if (j.splitIndex != iid):
                        j.splitIndex = iid
                        jl.append(j)
            jl.sort(key= python_lib_Functools.cmp_to_key(self.sortByBindIndex))
            _g21 = 0
            while (_g21 < len(permuts)):
                p2 = (permuts[_g21] if _g21 >= 0 and _g21 < len(permuts) else None)
                _g21 = (_g21 + 1)
                if ((p2.material == mid) and self.isSub(jl,p2.joints)):
                    p2.triangles.append(tri)
                    jl = None
                    break
            if (jl is None):
                continue
            _g22 = 0
            while (_g22 < len(permuts)):
                p21 = (permuts[_g22] if _g22 >= 0 and _g22 < len(permuts) else None)
                _g22 = (_g22 + 1)
                if ((p21.material == mid) and self.isSub(p21.joints,jl)):
                    p21.joints = jl
                    p21.triangles.append(tri)
                    jl = None
                    break
            if (jl is None):
                continue
            pr = h3d_anim__Skin_Permut()
            pr.joints = jl
            pr.triangles = [tri]
            pr.material = mid
            permuts.append(pr)
        while True:
            while self.merge(permuts):
                pass
            minDif = 100000
            minTot = 100000
            minP1 = None
            minP2 = None
            _g11 = 0
            _g5 = len(permuts)
            while (_g11 < _g5):
                i1 = _g11
                _g11 = (_g11 + 1)
                p1 = (permuts[i1] if i1 >= 0 and i1 < len(permuts) else None)
                if (len(p1.joints) == maxBones):
                    continue
                _g31 = (i1 + 1)
                _g23 = len(permuts)
                while (_g31 < _g23):
                    j1 = _g31
                    _g31 = (_g31 + 1)
                    p22 = (permuts[j1] if j1 >= 0 and j1 < len(permuts) else None)
                    if ((len(p22.joints) == maxBones) or ((p1.material != p22.material))):
                        continue
                    count = self.jointsDiff(p1,p22)
                    tot = (count + ((((len(p1.joints) + len(p22.joints)) - count) >> 1)))
                    if (((tot > maxBones) or ((tot > minTot))) or (((tot == minTot) and ((count > minDif))))):
                        continue
                    minDif = count
                    minTot = tot
                    minP1 = p1
                    minP2 = p22
            if (minP1 is None):
                break
            p11 = minP1
            p23 = minP2
            _g6 = 0
            _g12 = p11.joints
            while (_g6 < len(_g12)):
                j2 = (_g12[_g6] if _g6 >= 0 and _g6 < len(_g12) else None)
                _g6 = (_g6 + 1)
                python_internal_ArrayImpl.remove(p23.joints,j2)
                p23.joints.append(j2)
            p23.joints.sort(key= python_lib_Functools.cmp_to_key(self.sortByBindIndex))
            _g7 = 0
            _g13 = p11.triangles
            while (_g7 < len(_g13)):
                t = (_g13[_g7] if _g7 >= 0 and _g7 < len(_g13) else None)
                _g7 = (_g7 + 1)
                p23.triangles.append(t)
            python_internal_ArrayImpl.remove(permuts,p11)
        _g14 = 0
        _g8 = len(permuts)
        while (_g14 < _g8):
            i2 = _g14
            _g14 = (_g14 + 1)
            _g24 = 0
            _g32 = (permuts[i2] if i2 >= 0 and i2 < len(permuts) else None).triangles
            while (_g24 < len(_g32)):
                tri1 = (_g32[_g24] if _g24 >= 0 and _g24 < len(_g32) else None)
                _g24 = (_g24 + 1)
                self.triangleGroups[tri1] = i2
        jointsPermuts = []
        _g9 = 0
        _g15 = self.boundJoints
        while (_g9 < len(_g15)):
            j3 = (_g15[_g9] if _g9 >= 0 and _g9 < len(_g15) else None)
            _g9 = (_g9 + 1)
            pl = []
            _g25 = 0
            while (_g25 < len(permuts)):
                p = (permuts[_g25] if _g25 >= 0 and _g25 < len(permuts) else None)
                _g25 = (_g25 + 1)
                if (python_internal_ArrayImpl.indexOf(p.joints,j3,None) >= 0):
                    pl.append(p)
            jointsPermuts.append(_hx_AnonObject({'j': j3, 'pl': pl}))
        def _hx_local_7(j11,j21):
            return (len(j21.pl) - len(j11.pl))
        jointsPermuts.sort(key= python_lib_Functools.cmp_to_key(_hx_local_7))
        _g10 = 0
        while (_g10 < len(permuts)):
            p3 = (permuts[_g10] if _g10 >= 0 and _g10 < len(permuts) else None)
            _g10 = (_g10 + 1)
            p3.indexedJoints = []
        _g16 = 0
        while (_g16 < len(jointsPermuts)):
            j4 = (jointsPermuts[_g16] if _g16 >= 0 and _g16 < len(jointsPermuts) else None)
            _g16 = (_g16 + 1)
            j4.j.splitIndex = -1
            _g26 = 0
            while (_g26 < maxBones):
                id = _g26
                _g26 = (_g26 + 1)
                ok = True
                _g33 = 0
                _g41 = j4.pl
                while (_g33 < len(_g41)):
                    p4 = (_g41[_g33] if _g33 >= 0 and _g33 < len(_g41) else None)
                    _g33 = (_g33 + 1)
                    if ((p4.indexedJoints[id] if id >= 0 and id < len(p4.indexedJoints) else None) is not None):
                        ok = False
                        break
                if ok:
                    j4.j.splitIndex = id
                    _g34 = 0
                    _g42 = j4.pl
                    while (_g34 < len(_g42)):
                        p5 = (_g42[_g34] if _g34 >= 0 and _g34 < len(_g42) else None)
                        _g34 = (_g34 + 1)
                        python_internal_ArrayImpl._set(p5.indexedJoints, id, j4.j)
                    break
            if (j4.j.splitIndex < 0):
                raise _HxException("Failed to assign index while spliting skin")
        self.splitJoints = []
        _g17 = 0
        while (_g17 < len(permuts)):
            p6 = (permuts[_g17] if _g17 >= 0 and _g17 < len(permuts) else None)
            _g17 = (_g17 + 1)
            jl1 = []
            _g27 = 0
            _g18 = len(p6.indexedJoints)
            while (_g27 < _g18):
                i3 = _g27
                _g27 = (_g27 + 1)
                j5 = (p6.indexedJoints[i3] if i3 >= 0 and i3 < len(p6.indexedJoints) else None)
                if (j5 is None):
                    j5 = (self.boundJoints[0] if 0 < len(self.boundJoints) else None)
                jl1.append(j5)
            x2 = _hx_AnonObject({'material': p6.material, 'joints': jl1})
            self.splitJoints.append(x2)
        _g19 = 0
        _g20 = len(self.vertexJoints)
        while (_g19 < _g20):
            i4 = _g19
            _g19 = (_g19 + 1)
            this1 = self.vertexJoints
            val = python_internal_ArrayImpl._get(self.boundJoints, self.vertexJoints[i4]).splitIndex
            this1[i4] = val
        return True

h3d_anim_Skin._hx_class = h3d_anim_Skin


class h3d_col_Collider:
    _hx_class_name = "h3d.col.Collider"
    __slots__ = ()
    _hx_interfaces = [h3d_impl__Serializable_EmptyInterface]
h3d_col_Collider._hx_class = h3d_col_Collider


class h3d_col_Bounds:
    _hx_class_name = "h3d.col.Bounds"
    __slots__ = ("xMin", "xMax", "yMin", "yMax", "zMin", "zMax")
    _hx_fields = ["xMin", "xMax", "yMin", "yMax", "zMin", "zMax"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20

h3d_col_Bounds._hx_class = h3d_col_Bounds


class h3d_col_Point:
    _hx_class_name = "h3d.col.Point"
    __slots__ = ("x", "y", "z")
    _hx_fields = ["x", "y", "z"]

    def __init__(self,x = 0.,y = 0.,z = 0.):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self.x = x
        self.y = y
        self.z = z

h3d_col_Point._hx_class = h3d_col_Point


class h3d_impl_Driver:
    _hx_class_name = "h3d.impl.Driver"
    __slots__ = ()
    _hx_methods = ["generateMipMaps", "allocTexture", "disposeTexture", "uploadTextureBitmap", "uploadTexturePixels"]

    def generateMipMaps(self,texture):
        raise _HxException("Mipmaps auto generation is not supported on this platform")

    def allocTexture(self,t):
        return None

    def disposeTexture(self,t):
        pass

    def uploadTextureBitmap(self,t,bmp,mipLevel,side):
        pass

    def uploadTexturePixels(self,t,pixels,mipLevel,side):
        pass

h3d_impl_Driver._hx_class = h3d_impl_Driver


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if isinstance(o,int):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g1 = 0
            _g = l
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return "<function>"
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g12 = 0
                    _g3 = l1
                    while (_g12 < _g3):
                        i1 = _g12
                        _g12 = (_g12 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        _hx_local_0 = len(field)
        if (_hx_local_0 == 10):
            if (field == "charCodeAt"):
                if isinstance(o,str):
                    s1 = o
                    def _hx_local_1(a11):
                        return HxString.charCodeAt(s1,a11)
                    return _hx_local_1
        elif (_hx_local_0 == 11):
            if (field == "lastIndexOf"):
                if isinstance(o,str):
                    s3 = o
                    def _hx_local_2(a15):
                        return HxString.lastIndexOf(s3,a15)
                    return _hx_local_2
                elif isinstance(o,list):
                    a4 = o
                    def _hx_local_3(x4):
                        return python_internal_ArrayImpl.lastIndexOf(a4,x4)
                    return _hx_local_3
            elif (field == "toLowerCase"):
                if isinstance(o,str):
                    s7 = o
                    def _hx_local_4():
                        return HxString.toLowerCase(s7)
                    return _hx_local_4
            elif (field == "toUpperCase"):
                if isinstance(o,str):
                    s9 = o
                    def _hx_local_5():
                        return HxString.toUpperCase(s9)
                    return _hx_local_5
        elif (_hx_local_0 == 9):
            if (field == "substring"):
                if isinstance(o,str):
                    s6 = o
                    def _hx_local_6(a19):
                        return HxString.substring(s6,a19)
                    return _hx_local_6
        elif (_hx_local_0 == 4):
            if (field == "copy"):
                if isinstance(o,list):
                    def _hx_local_7():
                        return list(o)
                    return _hx_local_7
            elif (field == "join"):
                if isinstance(o,list):
                    def _hx_local_8(sep):
                        return sep.join([python_Boot.toString1(x1,'') for x1 in o])
                    return _hx_local_8
            elif (field == "push"):
                if isinstance(o,list):
                    x7 = o
                    def _hx_local_9(e):
                        return python_internal_ArrayImpl.push(x7,e)
                    return _hx_local_9
            elif (field == "sort"):
                if isinstance(o,list):
                    x11 = o
                    def _hx_local_10(f2):
                        python_internal_ArrayImpl.sort(x11,f2)
                    return _hx_local_10
        elif (_hx_local_0 == 5):
            if (field == "shift"):
                if isinstance(o,list):
                    x9 = o
                    def _hx_local_11():
                        return python_internal_ArrayImpl.shift(x9)
                    return _hx_local_11
            elif (field == "slice"):
                if isinstance(o,list):
                    x10 = o
                    def _hx_local_12(a16):
                        return python_internal_ArrayImpl.slice(x10,a16)
                    return _hx_local_12
            elif (field == "split"):
                if isinstance(o,str):
                    s4 = o
                    def _hx_local_13(d):
                        return HxString.split(s4,d)
                    return _hx_local_13
        elif (_hx_local_0 == 7):
            if (field == "indexOf"):
                if isinstance(o,str):
                    s2 = o
                    def _hx_local_14(a13):
                        return HxString.indexOf(s2,a13)
                    return _hx_local_14
                elif isinstance(o,list):
                    a = o
                    def _hx_local_15(x1):
                        return python_internal_ArrayImpl.indexOf(a,x1)
                    return _hx_local_15
            elif (field == "reverse"):
                if isinstance(o,list):
                    a5 = o
                    def _hx_local_16():
                        python_internal_ArrayImpl.reverse(a5)
                    return _hx_local_16
            elif (field == "unshift"):
                if isinstance(o,list):
                    x14 = o
                    def _hx_local_17(e2):
                        python_internal_ArrayImpl.unshift(x14,e2)
                    return _hx_local_17
        elif (_hx_local_0 == 3):
            if (field == "map"):
                if isinstance(o,list):
                    x5 = o
                    def _hx_local_18(f1):
                        return python_internal_ArrayImpl.map(x5,f1)
                    return _hx_local_18
            elif (field == "pop"):
                if isinstance(o,list):
                    x6 = o
                    def _hx_local_19():
                        return python_internal_ArrayImpl.pop(x6)
                    return _hx_local_19
        elif (_hx_local_0 == 8):
            if (field == "iterator"):
                if isinstance(o,list):
                    x3 = o
                    def _hx_local_20():
                        return python_internal_ArrayImpl.iterator(x3)
                    return _hx_local_20
            elif (field == "toString"):
                if isinstance(o,str):
                    s8 = o
                    def _hx_local_21():
                        return HxString.toString(s8)
                    return _hx_local_21
                elif isinstance(o,list):
                    x13 = o
                    def _hx_local_22():
                        return python_internal_ArrayImpl.toString(x13)
                    return _hx_local_22
        elif (_hx_local_0 == 6):
            if (field == "charAt"):
                if isinstance(o,str):
                    s = o
                    def _hx_local_23(a1):
                        return HxString.charAt(s,a1)
                    return _hx_local_23
            elif (field == "concat"):
                if isinstance(o,list):
                    a12 = o
                    def _hx_local_24(a2):
                        return python_internal_ArrayImpl.concat(a12,a2)
                    return _hx_local_24
            elif (field == "filter"):
                if isinstance(o,list):
                    x = o
                    def _hx_local_25(f):
                        return python_internal_ArrayImpl.filter(x,f)
                    return _hx_local_25
            elif (field == "insert"):
                if isinstance(o,list):
                    a3 = o
                    def _hx_local_26(a14,x2):
                        python_internal_ArrayImpl.insert(a3,a14,x2)
                    return _hx_local_26
            elif (field == "length"):
                if isinstance(o,str):
                    return len(o)
                elif isinstance(o,list):
                    return len(o)
            elif (field == "remove"):
                if isinstance(o,list):
                    x8 = o
                    def _hx_local_27(e1):
                        return python_internal_ArrayImpl.remove(x8,e1)
                    return _hx_local_27
            elif (field == "splice"):
                if isinstance(o,list):
                    x12 = o
                    def _hx_local_28(a17,a21):
                        return python_internal_ArrayImpl.splice(x12,a17,a21)
                    return _hx_local_28
            elif (field == "substr"):
                if isinstance(o,str):
                    s5 = o
                    def _hx_local_29(a18):
                        return HxString.substr(s5,a18)
                    return _hx_local_29
        else:
            pass
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def getInstanceFields(c):
        f = (c._hx_fields if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "iterator", "indexOf", "lastIndexOf", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g1 = l
        while (_g1 < _hx_len):
            i = _g1
            _g1 = (_g1 + 1)
            if (a[i] == x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if (a[l] == x):
                return l
        return -1

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class h3d_impl_MemoryManager:
    _hx_class_name = "h3d.impl.MemoryManager"
    __slots__ = ("driver", "textures", "texMemory")
    _hx_fields = ["driver", "textures", "texMemory"]
    _hx_methods = ["bpp", "cleanTextures", "sortByLRU", "deleteTexture", "allocTexture"]

    def __init__(self):
        self.textures = None
        self.driver = None
        self.texMemory = 0

    def bpp(self,t):
        return 4

    def cleanTextures(self,force = True):
        if (force is None):
            force = True
        self.textures.sort(key= python_lib_Functools.cmp_to_key(self.sortByLRU))
        _g = 0
        _g1 = self.textures
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (t.realloc is None):
                continue
            if (force or ((t.lastFrame < ((h3d_Engine.CURRENT.frameCount - 3600))))):
                t.dispose()
                return True
        return False

    def sortByLRU(self,t1,t2):
        return (t1.lastFrame - t2.lastFrame)

    def deleteTexture(self,t):
        python_internal_ArrayImpl.remove(self.textures,t)
        self.driver.disposeTexture(t)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 - (((t.width * t.height) * self.bpp(t))))
        _hx_local_0.texMemory

    def allocTexture(self,t):
        self.cleanTextures(False)
        t.t = self.driver.allocTexture(t)
        if (t.t is None):
            if (not self.cleanTextures(True)):
                raise _HxException("Maximum texture memory reached")
            self.allocTexture(t)
            return
        self.textures.append(t)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 + (((t.width * t.height) * self.bpp(t))))
        _hx_local_0.texMemory

h3d_impl_MemoryManager._hx_class = h3d_impl_MemoryManager

class h3d_mat_Face(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Face"
    _hx_constructs = ["None", "Back", "Front", "Both"]
h3d_mat_Face._hx_None = h3d_mat_Face("None", 0, list())
h3d_mat_Face.Back = h3d_mat_Face("Back", 1, list())
h3d_mat_Face.Front = h3d_mat_Face("Front", 2, list())
h3d_mat_Face.Both = h3d_mat_Face("Both", 3, list())
h3d_mat_Face._hx_class = h3d_mat_Face

class h3d_mat_MipMap(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.MipMap"
    _hx_constructs = ["None", "Nearest", "Linear"]
h3d_mat_MipMap._hx_None = h3d_mat_MipMap("None", 0, list())
h3d_mat_MipMap.Nearest = h3d_mat_MipMap("Nearest", 1, list())
h3d_mat_MipMap.Linear = h3d_mat_MipMap("Linear", 2, list())
h3d_mat_MipMap._hx_class = h3d_mat_MipMap

class h3d_mat_Filter(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Filter"
    _hx_constructs = ["Nearest", "Linear"]
h3d_mat_Filter.Nearest = h3d_mat_Filter("Nearest", 0, list())
h3d_mat_Filter.Linear = h3d_mat_Filter("Linear", 1, list())
h3d_mat_Filter._hx_class = h3d_mat_Filter

class h3d_mat_Wrap(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Wrap"
    _hx_constructs = ["Clamp", "Repeat"]
h3d_mat_Wrap.Clamp = h3d_mat_Wrap("Clamp", 0, list())
h3d_mat_Wrap.Repeat = h3d_mat_Wrap("Repeat", 1, list())
h3d_mat_Wrap._hx_class = h3d_mat_Wrap

class h3d_mat_TextureFlags(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.TextureFlags"
    _hx_constructs = ["Target", "Cube", "MipMapped", "ManualMipMapGen", "IsNPOT", "NoAlloc", "Dynamic", "AlphaPremultiplied", "WasCleared", "Loading", "Serialize"]
h3d_mat_TextureFlags.Target = h3d_mat_TextureFlags("Target", 0, list())
h3d_mat_TextureFlags.Cube = h3d_mat_TextureFlags("Cube", 1, list())
h3d_mat_TextureFlags.MipMapped = h3d_mat_TextureFlags("MipMapped", 2, list())
h3d_mat_TextureFlags.ManualMipMapGen = h3d_mat_TextureFlags("ManualMipMapGen", 3, list())
h3d_mat_TextureFlags.IsNPOT = h3d_mat_TextureFlags("IsNPOT", 4, list())
h3d_mat_TextureFlags.NoAlloc = h3d_mat_TextureFlags("NoAlloc", 5, list())
h3d_mat_TextureFlags.Dynamic = h3d_mat_TextureFlags("Dynamic", 6, list())
h3d_mat_TextureFlags.AlphaPremultiplied = h3d_mat_TextureFlags("AlphaPremultiplied", 7, list())
h3d_mat_TextureFlags.WasCleared = h3d_mat_TextureFlags("WasCleared", 8, list())
h3d_mat_TextureFlags.Loading = h3d_mat_TextureFlags("Loading", 9, list())
h3d_mat_TextureFlags.Serialize = h3d_mat_TextureFlags("Serialize", 10, list())
h3d_mat_TextureFlags._hx_class = h3d_mat_TextureFlags


class h3d_mat_Pass:
    _hx_class_name = "h3d.mat.Pass"
    __slots__ = ()
    _hx_interfaces = [h3d_impl__Serializable_EmptyInterface]
h3d_mat_Pass._hx_class = h3d_mat_Pass

class hxd_PixelFormat(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.PixelFormat"
    _hx_constructs = ["ARGB", "BGRA", "RGBA", "RGBA16F", "RGBA32F", "ALPHA8", "ALPHA16F", "ALPHA32F"]
hxd_PixelFormat.ARGB = hxd_PixelFormat("ARGB", 0, list())
hxd_PixelFormat.BGRA = hxd_PixelFormat("BGRA", 1, list())
hxd_PixelFormat.RGBA = hxd_PixelFormat("RGBA", 2, list())
hxd_PixelFormat.RGBA16F = hxd_PixelFormat("RGBA16F", 3, list())
hxd_PixelFormat.RGBA32F = hxd_PixelFormat("RGBA32F", 4, list())
hxd_PixelFormat.ALPHA8 = hxd_PixelFormat("ALPHA8", 5, list())
hxd_PixelFormat.ALPHA16F = hxd_PixelFormat("ALPHA16F", 6, list())
hxd_PixelFormat.ALPHA32F = hxd_PixelFormat("ALPHA32F", 7, list())
hxd_PixelFormat._hx_class = hxd_PixelFormat


class h3d_mat_Texture:
    _hx_class_name = "h3d.mat.Texture"
    __slots__ = ("t", "mem", "id", "width", "height", "flags", "format", "lastFrame", "bits", "mipMap", "filter", "wrap", "realloc")
    _hx_fields = ["t", "mem", "id", "width", "height", "flags", "format", "lastFrame", "bits", "mipMap", "filter", "wrap", "realloc"]
    _hx_methods = ["alloc", "set_mipMap", "set_filter", "set_wrap", "clear", "checkMipMapGen", "uploadBitmap", "uploadPixels", "dispose"]
    _hx_statics = ["UID", "nativeFormat", "nativeFlip", "fromBitmap", "fromPixels", "fromColor", "defaultCubeTexture", "noiseTextures", "genNoise", "allocNoise"]

    def __init__(self,w,h,flags = None,format = None,allocPos = None):
        self.realloc = None
        self.wrap = None
        self.filter = None
        self.mipMap = None
        self.bits = None
        self.lastFrame = None
        self.height = None
        self.width = None
        self.t = None
        self.mem = h3d_Engine.CURRENT.mem
        if (format is None):
            format = h3d_mat_Texture.nativeFormat
        def _hx_local_2():
            _hx_local_0 = h3d_mat_Texture
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_0.UID
        self.id = _hx_local_2()
        self.format = format
        self.flags = 0
        if (flags is not None):
            _g = 0
            while (_g < len(flags)):
                f = (flags[_g] if _g >= 0 and _g < len(flags) else None)
                _g = (_g + 1)
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.flags
                _hx_local_4.flags = (_hx_local_5 | ((1 << f.index)))
                _hx_local_4.flags
        tw = 1
        th = 1
        while (tw < w):
            tw = (tw << 1)
        while (th < h):
            th = (th << 1)
        if ((tw != w) or ((th != h))):
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | ((1 << h3d_mat_TextureFlags.IsNPOT.index)))
            _hx_local_8.flags
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) != 0):
            def _hx_local_10():
                pass
            self.realloc = _hx_local_10
        self.width = w
        self.height = h
        self.set_mipMap((h3d_mat_MipMap.Nearest if ((((self.flags & ((1 << h3d_mat_TextureFlags.MipMapped.index)))) != 0)) else h3d_mat_MipMap._hx_None))
        self.set_filter(h3d_mat_Filter.Linear)
        self.set_wrap(h3d_mat_Wrap.Clamp)
        _hx_local_11 = self
        _hx_local_12 = _hx_local_11.bits
        _hx_local_11.bits = (_hx_local_12 & 32767)
        _hx_local_11.bits
        if (((self.flags & ((1 << h3d_mat_TextureFlags.NoAlloc.index)))) == 0):
            self.alloc()

    def alloc(self):
        if (self.t is None):
            self.mem.allocTexture(self)

    def set_mipMap(self,m):
        self.bits = ((self.bits & -4) | m.index)
        def _hx_local_1():
            def _hx_local_0():
                self.mipMap = m
                return self.mipMap
            return _hx_local_0()
        return _hx_local_1()

    def set_filter(self,f):
        self.bits = ((self.bits & -25) | ((f.index << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.filter = f
                return self.filter
            return _hx_local_0()
        return _hx_local_1()

    def set_wrap(self,w):
        self.bits = ((self.bits & -193) | ((w.index << 6)))
        def _hx_local_1():
            def _hx_local_0():
                self.wrap = w
                return self.wrap
            return _hx_local_0()
        return _hx_local_1()

    def clear(self,color,alpha = 1.):
        if (alpha is None):
            alpha = 1.
        self.alloc()
        p = hxd_Pixels.alloc(self.width,self.height,hxd_PixelFormat.BGRA)
        k = 0
        b = (color & 255)
        g = ((color >> 8) & 255)
        r = ((color >> 16) & 255)
        a = None
        try:
            a = int((alpha * 255))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            a = None
        a1 = a
        if (a1 < 0):
            a1 = 0
        elif (a1 > 255):
            a1 = 255
        _g1 = 0
        _g = (self.width * self.height)
        while (_g1 < _g):
            _g1 = (_g1 + 1)
            pos = k
            k = (k + 1)
            p.bytes.b[pos] = (b & 255)
            pos1 = k
            k = (k + 1)
            p.bytes.b[pos1] = (g & 255)
            pos2 = k
            k = (k + 1)
            p.bytes.b[pos2] = (r & 255)
            pos3 = k
            k = (k + 1)
            p.bytes.b[pos3] = (a1 & 255)
        self.uploadPixels(p)
        p.dispose()

    def checkMipMapGen(self,mipLevel,side):
        if ((((mipLevel == 0) and ((((self.flags & ((1 << h3d_mat_TextureFlags.MipMapped.index)))) != 0))) and ((((self.flags & ((1 << h3d_mat_TextureFlags.ManualMipMapGen.index)))) == 0))) and (((((self.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) == 0) or ((side == 5))))):
            self.mem.driver.generateMipMaps(self)

    def uploadBitmap(self,bmp,mipLevel = 0,side = 0):
        if (mipLevel is None):
            mipLevel = 0
        if (side is None):
            side = 0
        self.alloc()
        width = bmp.data.width
        height = bmp.data.height
        if ((width != ((self.width >> mipLevel))) or ((height != ((self.height >> mipLevel))))):
            raise _HxException(((((((("Invalid upload size : " + Std.string(width)) + "x") + Std.string(height)) + " should be ") + Std.string(((self.width >> mipLevel)))) + "x") + Std.string(((self.height >> mipLevel)))))
        self.mem.driver.uploadTextureBitmap(self,bmp,mipLevel,side)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | ((1 << h3d_mat_TextureFlags.WasCleared.index)))
        _hx_local_0.flags
        self.checkMipMapGen(mipLevel,side)

    def uploadPixels(self,pixels,mipLevel = 0,side = 0):
        if (mipLevel is None):
            mipLevel = 0
        if (side is None):
            side = 0
        self.alloc()
        width = pixels.width
        height = pixels.height
        if ((width != ((self.width >> mipLevel))) or ((height != ((self.height >> mipLevel))))):
            raise _HxException(((((((("Invalid upload size : " + Std.string(width)) + "x") + Std.string(height)) + " should be ") + Std.string(((self.width >> mipLevel)))) + "x") + Std.string(((self.height >> mipLevel)))))
        self.mem.driver.uploadTexturePixels(self,pixels,mipLevel,side)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | ((1 << h3d_mat_TextureFlags.WasCleared.index)))
        _hx_local_0.flags
        self.checkMipMapGen(mipLevel,side)

    def dispose(self):
        if (self.t is not None):
            self.mem.deleteTexture(self)

    @staticmethod
    def fromBitmap(bmp,allocPos = None):
        t = h3d_mat_Texture(bmp.data.width,bmp.data.height,None,None,allocPos)
        t.uploadBitmap(bmp)
        return t

    @staticmethod
    def fromPixels(pixels,allocPos = None):
        t = h3d_mat_Texture(pixels.width,pixels.height,None,None,allocPos)
        t.uploadPixels(pixels)
        return t

    @staticmethod
    def fromColor(color,alpha = 1.,allocPos = None):
        if (alpha is None):
            alpha = 1.
        engine = h3d_Engine.CURRENT
        aval = None
        try:
            aval = int((alpha * 255))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            aval = None
        aval1 = aval
        if (aval1 < 0):
            aval1 = 0
        elif (aval1 > 255):
            aval1 = 255
        key = ((color & 16777215) | ((aval1 << 24)))
        t = engine.textureColorCache.h.get(key,None)
        if (t is not None):
            return t
        t1 = h3d_mat_Texture(1,1,None,None,allocPos)
        t1.clear(color,alpha)
        def _hx_local_0():
            t1.clear(color,alpha)
        t1.realloc = _hx_local_0
        engine.textureColorCache.set(key,t1)
        return t1

    @staticmethod
    def defaultCubeTexture():
        engine = h3d_Engine.CURRENT
        t = engine.resCache.h.get(h3d_mat_Texture,None)
        if (t is not None):
            return t
        t = h3d_mat_Texture(1,1,[h3d_mat_TextureFlags.Cube])
        Reflect.field(t,"clear")(0)
        def _hx_local_0():
            Reflect.field(t,"clear")(0)
        Reflect.setField(t,"realloc",_hx_local_0)
        engine.resCache.set(h3d_mat_Texture,t)
        return t

    @staticmethod
    def genNoise(size):
        t = h3d_mat_Texture.noiseTextures.h.get(size,None)
        if ((t is not None) and (not (((t.t is None) and ((t.realloc is None)))))):
            return t
        t1 = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc])
        t2 = t1
        a1 = size
        def _hx_local_0():
            h3d_mat_Texture.allocNoise(t2,a1)
        t1.realloc = _hx_local_0
        h3d_mat_Texture.noiseTextures.set(size,t1)
        return t1

    @staticmethod
    def allocNoise(t,size):
        b = hxd_BitmapData(size,size)
        _g1 = 0
        while (_g1 < size):
            x = _g1
            _g1 = (_g1 + 1)
            _g3 = 0
            while (_g3 < size):
                y = _g3
                _g3 = (_g3 + 1)
                x1 = (python_lib_Random.random() * 256)
                n = None
                try:
                    n = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    n = None
                b.setPixel(x,y,(((-16777216 | n) | ((n << 8))) | ((n << 16))))
        t.uploadBitmap(b)
        b.data = None

h3d_mat_Texture._hx_class = h3d_mat_Texture


class hxsl_Shader:
    _hx_class_name = "hxsl.Shader"
    __slots__ = ()
hxsl_Shader._hx_class = hxsl_Shader


class h3d_pass__Border_BorderShader(hxsl_Shader):
    _hx_class_name = "h3d.pass._Border.BorderShader"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_pass__Border_BorderShader._hx_class = h3d_pass__Border_BorderShader


class h3d_shader_ScreenShader(hxsl_Shader):
    _hx_class_name = "h3d.shader.ScreenShader"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None
h3d_shader_ScreenShader._hx_class = h3d_shader_ScreenShader


class h3d_pass__Copy_CopyShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._Copy.CopyShader"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader

    _SHADER = None

h3d_pass__Copy_CopyShader._hx_class = h3d_pass__Copy_CopyShader


class h3d_pass__HardwarePick_FixedColor(hxsl_Shader):
    _hx_class_name = "h3d.pass._HardwarePick.FixedColor"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_pass__HardwarePick_FixedColor._hx_class = h3d_pass__HardwarePick_FixedColor


class h3d_shader_AmbientLight(hxsl_Shader):
    _hx_class_name = "h3d.shader.AmbientLight"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_AmbientLight._hx_class = h3d_shader_AmbientLight


class h3d_shader_Base2d(hxsl_Shader):
    _hx_class_name = "h3d.shader.Base2d"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_Base2d._hx_class = h3d_shader_Base2d


class h3d_shader_BaseMesh(hxsl_Shader):
    _hx_class_name = "h3d.shader.BaseMesh"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_BaseMesh._hx_class = h3d_shader_BaseMesh


class h3d_shader_Blur(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.Blur"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader

    _SHADER = None

h3d_shader_Blur._hx_class = h3d_shader_Blur


class h3d_shader_ColorAdd(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorAdd"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_ColorAdd._hx_class = h3d_shader_ColorAdd


class h3d_shader_ColorKey(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorKey"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_ColorKey._hx_class = h3d_shader_ColorKey


class h3d_shader_ColorMatrix(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorMatrix"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_ColorMatrix._hx_class = h3d_shader_ColorMatrix


class h3d_shader_DirLight(hxsl_Shader):
    _hx_class_name = "h3d.shader.DirLight"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_DirLight._hx_class = h3d_shader_DirLight


class h3d_shader_LineShader(hxsl_Shader):
    _hx_class_name = "h3d.shader.LineShader"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_LineShader._hx_class = h3d_shader_LineShader


class h3d_shader_Shadow(hxsl_Shader):
    _hx_class_name = "h3d.shader.Shadow"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_Shadow._hx_class = h3d_shader_Shadow


class h3d_shader_Skin(hxsl_Shader):
    _hx_class_name = "h3d.shader.Skin"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_Skin._hx_class = h3d_shader_Skin


class h3d_shader_SpecularTexture(hxsl_Shader):
    _hx_class_name = "h3d.shader.SpecularTexture"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_SpecularTexture._hx_class = h3d_shader_SpecularTexture


class h3d_shader_Texture(hxsl_Shader):
    _hx_class_name = "h3d.shader.Texture"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_Texture._hx_class = h3d_shader_Texture


class h3d_shader_UVDelta(hxsl_Shader):
    _hx_class_name = "h3d.shader.UVDelta"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_UVDelta._hx_class = h3d_shader_UVDelta


class h3d_shader_VertexColorAlpha(hxsl_Shader):
    _hx_class_name = "h3d.shader.VertexColorAlpha"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_VertexColorAlpha._hx_class = h3d_shader_VertexColorAlpha


class h3d_shader_VolumeDecal(hxsl_Shader):
    _hx_class_name = "h3d.shader.VolumeDecal"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader

    _SHADER = None

h3d_shader_VolumeDecal._hx_class = h3d_shader_VolumeDecal


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    __slots__ = ()
    _hx_statics = ["pending", "threadCount", "processEvents", "run"]

    @staticmethod
    def processEvents():
        while True:
            _this = haxe_EntryPoint.pending
            f = (None if ((len(_this) == 0)) else _this.pop(0))
            if (f is None):
                break
            f()
        if ((haxe_MainLoop.pending is None) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        return haxe_MainLoop.tick()

    @staticmethod
    def run():
        while (not ((haxe_EntryPoint.processEvents() < 0))):
            pass
haxe_EntryPoint._hx_class = haxe_EntryPoint


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    __slots__ = ("f", "prev", "next", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "nextRun", "priority"]

haxe_MainEvent._hx_class = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    __slots__ = ()
    _hx_statics = ["pending", "sortEvents", "tick"]
    threadCount = None

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g1 = 0
                _g = insize
                while (_g1 < _g):
                    _g1 = (_g1 + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if ((e.nextRun < 0) or ((wt <= 0))):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop


class haxe_ds_ArraySort:
    _hx_class_name = "haxe.ds.ArraySort"
    __slots__ = ()
    _hx_statics = ["sort", "rec", "doMerge", "rotate", "gcd", "upper", "lower", "swap"]

    @staticmethod
    def sort(a,cmp):
        haxe_ds_ArraySort.rec(a,cmp,0,len(a))

    @staticmethod
    def rec(a,cmp,_hx_from,to):
        middle = ((_hx_from + to) >> 1)
        if ((to - _hx_from) < 12):
            if (to <= _hx_from):
                return
            _g1 = (_hx_from + 1)
            while (_g1 < to):
                i = _g1
                _g1 = (_g1 + 1)
                j = i
                while (j > _hx_from):
                    if (cmp((a[j] if j >= 0 and j < len(a) else None),python_internal_ArrayImpl._get(a, (j - 1))) < 0):
                        haxe_ds_ArraySort.swap(a,(j - 1),j)
                    else:
                        break
                    j = (j - 1)
            return
        haxe_ds_ArraySort.rec(a,cmp,_hx_from,middle)
        haxe_ds_ArraySort.rec(a,cmp,middle,to)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,middle,to,(middle - _hx_from),(to - middle))

    @staticmethod
    def doMerge(a,cmp,_hx_from,pivot,to,len1,len2):
        first_cut = None
        second_cut = None
        len11 = None
        len22 = None
        new_mid = None
        if ((len1 == 0) or ((len2 == 0))):
            return
        if ((len1 + len2) == 2):
            if (cmp((a[pivot] if pivot >= 0 and pivot < len(a) else None),(a[_hx_from] if _hx_from >= 0 and _hx_from < len(a) else None)) < 0):
                haxe_ds_ArraySort.swap(a,pivot,_hx_from)
            return
        if (len1 > len2):
            len11 = (len1 >> 1)
            first_cut = (_hx_from + len11)
            second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut)
            len22 = (second_cut - pivot)
        else:
            len22 = (len2 >> 1)
            second_cut = (pivot + len22)
            first_cut = haxe_ds_ArraySort.upper(a,cmp,_hx_from,pivot,second_cut)
            len11 = (first_cut - _hx_from)
        haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut)
        new_mid = (first_cut + len22)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,first_cut,new_mid,len11,len22)
        haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,(len1 - len11),(len2 - len22))

    @staticmethod
    def rotate(a,cmp,_hx_from,mid,to):
        n = None
        if ((_hx_from == mid) or ((mid == to))):
            return
        n = haxe_ds_ArraySort.gcd((to - _hx_from),(mid - _hx_from))
        while True:
            tmp = n
            n = (n - 1)
            if (not ((tmp != 0))):
                break
            val = python_internal_ArrayImpl._get(a, (_hx_from + n))
            shift = (mid - _hx_from)
            p1 = (_hx_from + n)
            p2 = ((_hx_from + n) + shift)
            while (p2 != ((_hx_from + n))):
                python_internal_ArrayImpl._set(a, p1, (a[p2] if p2 >= 0 and p2 < len(a) else None))
                p1 = p2
                if ((to - p2) > shift):
                    p2 = (p2 + shift)
                else:
                    p2 = (_hx_from + ((shift - ((to - p2)))))
            python_internal_ArrayImpl._set(a, p1, val)

    @staticmethod
    def gcd(m,n):
        while (n != 0):
            t = HxOverrides.mod(m, n)
            m = n
            n = t
        return m

    @staticmethod
    def upper(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[val] if val >= 0 and val < len(a) else None),(a[mid] if mid >= 0 and mid < len(a) else None)) < 0):
                _hx_len = half
            else:
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
        return _hx_from

    @staticmethod
    def lower(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[mid] if mid >= 0 and mid < len(a) else None),(a[val] if val >= 0 and val < len(a) else None)) < 0):
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
            else:
                _hx_len = half
        return _hx_from

    @staticmethod
    def swap(a,i,j):
        tmp = (a[i] if i >= 0 and i < len(a) else None)
        python_internal_ArrayImpl._set(a, i, (a[j] if j >= 0 and j < len(a) else None))
        python_internal_ArrayImpl._set(a, j, tmp)
haxe_ds_ArraySort._hx_class = haxe_ds_ArraySort


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "iterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

haxe_ds_IntMap._hx_class = haxe_ds_IntMap


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        self.replacer = replacer
        self.indent = space
        self.pretty = (space is not None)
        self.nind = 0
        self.buf = StringBuf()

    def write(self,k,v):
        if (self.replacer is not None):
            v = self.replacer(k,v)
        _g = Type.typeof(v)
        _g1 = _g.index
        if (_g1 == 0):
            self.buf.b.write("null")
        elif (_g1 == 1):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (_g1 == 2):
            v1 = None
            f = v
            if (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f))):
                v1 = v
            else:
                v1 = "null"
            _this1 = self.buf
            s1 = Std.string(v1)
            _this1.b.write(s1)
        elif (_g1 == 3):
            _this2 = self.buf
            s2 = Std.string(v)
            _this2.b.write(s2)
        elif (_g1 == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (_g1 == 5):
            self.buf.b.write("\"<fun>\"")
        elif (_g1 == 6):
            c = _g.params[0]
            if (c == str):
                self.quote(v)
            elif (c == list):
                v2 = v
                _this3 = self.buf
                s3 = "".join(map(chr,[91]))
                _this3.b.write(s3)
                _hx_len = len(v2)
                last = (_hx_len - 1)
                _g11 = 0
                while (_g11 < _hx_len):
                    i = _g11
                    _g11 = (_g11 + 1)
                    if (i > 0):
                        _this4 = self.buf
                        s4 = "".join(map(chr,[44]))
                        _this4.b.write(s4)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    if self.pretty:
                        _this5 = self.buf
                        s5 = "".join(map(chr,[10]))
                        _this5.b.write(s5)
                    if self.pretty:
                        _this6 = self.buf
                        s6 = Std.string(StringTools.lpad("",self.indent,(self.nind * len(self.indent))))
                        _this6.b.write(s6)
                    self.write(i,(v2[i] if i >= 0 and i < len(v2) else None))
                    if (i == last):
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        if self.pretty:
                            _this7 = self.buf
                            s7 = "".join(map(chr,[10]))
                            _this7.b.write(s7)
                        if self.pretty:
                            _this8 = self.buf
                            s8 = Std.string(StringTools.lpad("",self.indent,(self.nind * len(self.indent))))
                            _this8.b.write(s8)
                _this9 = self.buf
                s9 = "".join(map(chr,[93]))
                _this9.b.write(s9)
            elif (c == haxe_ds_StringMap):
                v3 = v
                o = _hx_AnonObject({})
                k1 = v3.keys()
                while k1.hasNext():
                    k2 = k1.next()
                    value = v3.h.get(k2,None)
                    setattr(o,(("_hx_" + k2) if ((k2 in python_Boot.keywords)) else (("_hx_" + k2) if (((((len(k2) > 2) and ((ord(k2[0]) == 95))) and ((ord(k2[1]) == 95))) and ((ord(k2[(len(k2) - 1)]) != 95)))) else k2)),value)
                self.fieldsString(o,python_Boot.fields(o))
            elif (c == Date):
                self.quote(v.toString())
            else:
                self.fieldsString(v,python_Boot.fields(v))
        elif (_g1 == 7):
            _this10 = self.buf
            s10 = Std.string(v.index)
            _this10.b.write(s10)
        elif (_g1 == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def fieldsString(self,v,fields):
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        _hx_len = len(fields)
        last = (_hx_len - 1)
        first = True
        _g1 = 0
        while (_g1 < _hx_len):
            i = _g1
            _g1 = (_g1 + 1)
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            value = Reflect.field(v,f)
            if Reflect.isFunction(value):
                continue
            if first:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                first = False
            else:
                _this1 = self.buf
                s1 = "".join(map(chr,[44]))
                _this1.b.write(s1)
            if self.pretty:
                _this2 = self.buf
                s2 = "".join(map(chr,[10]))
                _this2.b.write(s2)
            if self.pretty:
                _this3 = self.buf
                s3 = Std.string(StringTools.lpad("",self.indent,(self.nind * len(self.indent))))
                _this3.b.write(s3)
            self.quote(f)
            _this4 = self.buf
            s4 = "".join(map(chr,[58]))
            _this4.b.write(s4)
            if self.pretty:
                _this5 = self.buf
                s5 = "".join(map(chr,[32]))
                _this5.b.write(s5)
            self.write(f,value)
            if (i == last):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                if self.pretty:
                    _this6 = self.buf
                    s6 = "".join(map(chr,[10]))
                    _this6.b.write(s6)
                if self.pretty:
                    _this7 = self.buf
                    s7 = Std.string(StringTools.lpad("",self.indent,(self.nind * len(self.indent))))
                    _this7.b.write(s7)
        _this8 = self.buf
        s8 = "".join(map(chr,[125]))
        _this8.b.write(s8)

    def quote(self,s):
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        i = 0
        while True:
            index = i
            i = (i + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            if (c == -1):
                break
            c1 = c
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                _this1 = self.buf
                s2 = "".join(map(chr,[c]))
                _this1.b.write(s2)
        _this2 = self.buf
        s3 = "".join(map(chr,[34]))
        _this2.b.write(s3)

    @staticmethod
    def print(o,replacer = None,space = None):
        printer = haxe_format_JsonPrinter(replacer,space)
        printer.write("",o)
        return printer.buf.b.getvalue()

haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter


class haxe_io_ArrayBufferViewImpl:
    _hx_class_name = "haxe.io.ArrayBufferViewImpl"
    __slots__ = ()
haxe_io_ArrayBufferViewImpl._hx_class = haxe_io_ArrayBufferViewImpl


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["blit", "getFloat", "getString", "toString"]
    _hx_statics = ["alloc", "ofString", "ofData"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def getFloat(self,pos):
        return haxe_io_BytesInput(self,pos,4).readFloat()

    def getString(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        return haxe_io_Bytes(len(b),b)

haxe_io_Bytes._hx_class = haxe_io_Bytes


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        self.b = list()

    def getBytes(self):
        buf = bytearray(self.b)
        _hx_bytes = haxe_io_Bytes(len(buf),buf)
        self.b = None
        return _hx_bytes

haxe_io_BytesBuffer._hx_class = haxe_io_BytesBuffer


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "readBytes", "set_bigEndian", "readFullBytes", "read", "readFloat", "readUInt16", "readInt32", "readString"]

    def readByte(self):
        raise _HxException("Not implemented")

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                    pass
            else:
                raise _hx_e
        return (_hx_len - k)

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.readBytes(s,pos,_hx_len)
            if (k == 0):
                raise _HxException(haxe_io_Error.Blocked)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def read(self,nbytes):
        s = haxe_io_Bytes.alloc(nbytes)
        p = 0
        while (nbytes > 0):
            k = self.readBytes(s,p,nbytes)
            if (k == 0):
                raise _HxException(haxe_io_Error.Blocked)
            p = (p + k)
            nbytes = (nbytes - k)
        return s

    def readFloat(self):
        return haxe_io_FPHelper.i32ToFloat(self.readInt32())

    def readUInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        if self.bigEndian:
            return (ch2 | ((ch1 << 8)))
        else:
            return (ch1 | ((ch2 << 8)))

    def readInt32(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        ch4 = self.readByte()
        n = ((((ch4 | ((ch3 << 8))) | ((ch2 << 16))) | ((ch1 << 24))) if (self.bigEndian) else (((ch1 | ((ch2 << 8))) | ((ch3 << 16))) | ((ch4 << 24))))
        if (((n & -2147483648)) != 0):
            return (n | -2147483648)
        else:
            return n

    def readString(self,_hx_len):
        b = haxe_io_Bytes.alloc(_hx_len)
        self.readFullBytes(b,0,_hx_len)
        return b.toString()

haxe_io_Input._hx_class = haxe_io_Input


class haxe_io_BytesInput(haxe_io_Input):
    _hx_class_name = "haxe.io.BytesInput"
    __slots__ = ("b", "pos", "len", "totlen")
    _hx_fields = ["b", "pos", "len", "totlen"]
    _hx_methods = ["readByte", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,b,pos = None,_hx_len = None):
        if (pos is None):
            pos = 0
        if (_hx_len is None):
            _hx_len = (b.length - pos)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > b.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        self.b = b.b
        self.pos = pos
        self.len = _hx_len
        self.totlen = _hx_len
        self.set_bigEndian(False)

    def readByte(self):
        if (self.len == 0):
            raise _HxException(haxe_io_Eof())
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 - 1)
        _hx_local_1
        def _hx_local_5():
            def _hx_local_4():
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.pos
                _hx_local_2.pos = (_hx_local_3 + 1)
                return _hx_local_3
            return self.b[_hx_local_4()]
        return _hx_local_5()

    def readBytes(self,buf,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        if ((self.len == 0) and ((_hx_len > 0))):
            raise _HxException(haxe_io_Eof())
        if (self.len < _hx_len):
            _hx_len = self.len
        b1 = self.b
        b2 = buf.b
        _g1 = 0
        _g = _hx_len
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            b2[(pos + i)] = b1[(self.pos + i)]
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.len
        _hx_local_2.len = (_hx_local_3 - _hx_len)
        _hx_local_2.len
        return _hx_len

haxe_io_BytesInput._hx_class = haxe_io_BytesInput


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "set_bigEndian", "write", "writeFullBytes", "writeFloat", "writeUInt16", "writeInt32", "writeString"]

    def writeByte(self,c):
        raise _HxException("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def write(self,s):
        l = s.length
        p = 0
        while (l > 0):
            k = self.writeBytes(s,p,l)
            if (k == 0):
                raise _HxException(haxe_io_Error.Blocked)
            p = (p + k)
            l = (l - k)

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeFloat(self,x):
        self.writeInt32(haxe_io_FPHelper.floatToI32(x))

    def writeUInt16(self,x):
        if ((x < 0) or ((x >= 65536))):
            raise _HxException(haxe_io_Error.Overflow)
        if self.bigEndian:
            self.writeByte((x >> 8))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte((x >> 8))

    def writeInt32(self,x):
        if self.bigEndian:
            self.writeByte(HxOverrides.rshift(x, 24))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(HxOverrides.rshift(x, 24))

    def writeString(self,s):
        b = haxe_io_Bytes.ofString(s)
        self.writeFullBytes(b,0,b.length)

haxe_io_Output._hx_class = haxe_io_Output


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self):
        self.b = haxe_io_BytesBuffer()
        self.set_bigEndian(False)

    def writeByte(self,c):
        self.b.b.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        _this = self.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b2 = buf.b
        _g1 = pos
        _g = (pos + _hx_len)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            _this.b.append(b2[i])
        return _hx_len

    def getBytes(self):
        return self.b.getBytes()

haxe_io_BytesOutput._hx_class = haxe_io_BytesOutput


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"

haxe_io_Eof._hx_class = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, [e])
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, list())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, list())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, list())
haxe_io_Error._hx_class = haxe_io_Error


class haxe_io_FPHelper:
    _hx_class_name = "haxe.io.FPHelper"
    __slots__ = ()
    _hx_statics = ["i32ToFloat", "floatToI32"]

    @staticmethod
    def i32ToFloat(i):
        exp = (HxOverrides.rshift(i, 23) & 255)
        sig = (i & 8388607)
        if ((sig == 0) and ((exp == 0))):
            return 0.0
        return ((((1 - ((HxOverrides.rshift(i, 31) << 1)))) * ((1 + ((Math.pow(2,-23) * sig))))) * Math.pow(2,(exp - 127)))

    @staticmethod
    def floatToI32(f):
        if (f == 0):
            return 0
        af = (-f if ((f < 0)) else f)
        exp = Math.floor((((Math.NEGATIVE_INFINITY if ((af == 0.0)) else (Math.NaN if ((af < 0.0)) else python_lib_Math.log(af)))) / 0.6931471805599453))
        if (exp < -127):
            exp = -127
        elif (exp > 128):
            exp = 128
        sig = Math.floor((((((af / Math.pow(2,exp)) - 1)) * 8388608) + 0.5))
        if ((sig == 8388608) and ((exp < 128))):
            sig = 0
            exp = (exp + 1)
        return ((((-2147483648 if ((f < 0)) else 0)) | (((exp + 127) << 23))) | sig)
haxe_io_FPHelper._hx_class = haxe_io_FPHelper


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    __slots__ = ()
    _hx_statics = ["join", "normalize", "addTrailingSlash", "isAbsolute"]

    @staticmethod
    def join(paths):
        def _hx_local_0(s):
            if (s is not None):
                return (s != "")
            else:
                return False
        paths1 = list(filter(_hx_local_0,paths))
        if (len(paths1) == 0):
            return ""
        path = (paths1[0] if 0 < len(paths1) else None)
        _g1 = 1
        _g = len(paths1)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            path = haxe_io_Path.addTrailingSlash(path)
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((paths1[i] if i >= 0 and i < len(paths1) else None)))
        return haxe_io_Path.normalize(path)

    @staticmethod
    def normalize(path):
        _this = path.split("\\")
        path = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
        if (path == "/"):
            return "/"
        target = []
        _g = 0
        _g1 = None
        _g1 = path.split("/")
        while (_g < len(_g1)):
            token = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((token == "..") and ((len(target) > 0))) and ((python_internal_ArrayImpl._get(target, (len(target) - 1)) != ".."))):
                if (len(target) != 0):
                    target.pop()
            elif (token != "."):
                target.append(token)
        tmp = "/".join([python_Boot.toString1(x1,'') for x1 in target])
        EReg("([^:])/+","g").replace(tmp,("$1" + "/"))
        acc_b = python_lib_io_StringIO()
        colon = False
        slashes = False
        _g11 = 0
        _g2 = len(tmp)
        while (_g11 < _g2):
            i = _g11
            _g11 = (_g11 + 1)
            _g21 = (-1 if ((i >= len(tmp))) else ord(tmp[i]))
            _g22 = _g21
            if (_g22 == 47):
                if (not colon):
                    slashes = True
                else:
                    colon = False
                    if slashes:
                        acc_b.write("/")
                        slashes = False
                    acc_b.write("".join(map(chr,[_g21])))
            elif (_g22 == 58):
                acc_b.write(":")
                colon = True
            else:
                colon = False
                if slashes:
                    acc_b.write("/")
                    slashes = False
                acc_b.write("".join(map(chr,[_g21])))
        return acc_b.getvalue()

    @staticmethod
    def addTrailingSlash(path):
        if (len(path) == 0):
            return "/"
        c1 = path.rfind("/", 0, len(path))
        c2 = path.rfind("\\", 0, len(path))
        if (c1 < c2):
            if (c2 != ((len(path) - 1))):
                return (("null" if path is None else path) + "\\")
            else:
                return path
        elif (c1 != ((len(path) - 1))):
            return (("null" if path is None else path) + "/")
        else:
            return path

    @staticmethod
    def isAbsolute(path):
        if StringTools.startsWith(path,"/"):
            return True
        if ((("" if ((1 >= len(path))) else path[1])) == ":"):
            return True
        if StringTools.startsWith(path,"\\\\"):
            return True
        return False
haxe_io_Path._hx_class = haxe_io_Path


class haxe_xml__Fast_NodeAccess:
    _hx_class_name = "haxe.xml._Fast.NodeAccess"
    __slots__ = ("__dict__", "_hx___x")
    _hx_fields = ["__x"]

    def __init__(self,x):
        self._hx___x = x

haxe_xml__Fast_NodeAccess._hx_class = haxe_xml__Fast_NodeAccess


class haxe_xml__Fast_AttribAccess:
    _hx_class_name = "haxe.xml._Fast.AttribAccess"
    __slots__ = ("__dict__", "_hx___x")
    _hx_fields = ["__x"]

    def __init__(self,x):
        self._hx___x = x

haxe_xml__Fast_AttribAccess._hx_class = haxe_xml__Fast_AttribAccess


class haxe_xml__Fast_HasAttribAccess:
    _hx_class_name = "haxe.xml._Fast.HasAttribAccess"
    __slots__ = ("__dict__", "_hx___x")
    _hx_fields = ["__x"]

    def __init__(self,x):
        self._hx___x = x

haxe_xml__Fast_HasAttribAccess._hx_class = haxe_xml__Fast_HasAttribAccess


class haxe_xml__Fast_HasNodeAccess:
    _hx_class_name = "haxe.xml._Fast.HasNodeAccess"
    __slots__ = ("__dict__", "_hx___x")
    _hx_fields = ["__x"]

    def __init__(self,x):
        self._hx___x = x

haxe_xml__Fast_HasNodeAccess._hx_class = haxe_xml__Fast_HasNodeAccess


class haxe_xml__Fast_NodeListAccess:
    _hx_class_name = "haxe.xml._Fast.NodeListAccess"
    __slots__ = ("__dict__", "_hx___x")
    _hx_fields = ["__x"]

    def __init__(self,x):
        self._hx___x = x

haxe_xml__Fast_NodeListAccess._hx_class = haxe_xml__Fast_NodeListAccess


class haxe_xml_Fast:
    _hx_class_name = "haxe.xml.Fast"
    __slots__ = ("x", "node", "nodes", "att", "has", "hasNode")
    _hx_fields = ["x", "node", "nodes", "att", "has", "hasNode"]
    _hx_methods = ["get_name", "get_innerData", "get_elements"]

    def __init__(self,x):
        if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
            raise _HxException(("Invalid nodeType " + Std.string(x.nodeType)))
        self.x = x
        self.node = haxe_xml__Fast_NodeAccess(x)
        self.nodes = haxe_xml__Fast_NodeListAccess(x)
        self.att = haxe_xml__Fast_AttribAccess(x)
        self.has = haxe_xml__Fast_HasAttribAccess(x)
        self.hasNode = haxe_xml__Fast_HasNodeAccess(x)

    def get_name(self):
        if (self.x.nodeType == Xml.Document):
            return "Document"
        else:
            _this = self.x
            if (_this.nodeType != Xml.Element):
                raise _HxException(("Bad node type, expected Element but found " + Std.string(_this.nodeType)))
            return _this.nodeName

    def get_innerData(self):
        _this = self.x
        if ((_this.nodeType != Xml.Document) and ((_this.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + Std.string(_this.nodeType)))
        it = python_HaxeIterator(_this.children.__iter__())
        if (not it.hasNext()):
            raise _HxException((HxOverrides.stringOrNull(self.get_name()) + " does not have data"))
        v = it.next()
        if it.hasNext():
            n = it.next()
            tmp = None
            if ((v.nodeType == Xml.PCData) and ((n.nodeType == Xml.CData))):
                if ((v.nodeType == Xml.Document) or ((v.nodeType == Xml.Element))):
                    raise _HxException(("Bad node type, unexpected " + Std.string(v.nodeType)))
                tmp = (StringTools.trim(v.nodeValue) == "")
            else:
                tmp = False
            if tmp:
                if (not it.hasNext()):
                    if ((n.nodeType == Xml.Document) or ((n.nodeType == Xml.Element))):
                        raise _HxException(("Bad node type, unexpected " + Std.string(n.nodeType)))
                    return n.nodeValue
                n2 = it.next()
                tmp1 = None
                tmp2 = None
                if (n2.nodeType == Xml.PCData):
                    if ((n2.nodeType == Xml.Document) or ((n2.nodeType == Xml.Element))):
                        raise _HxException(("Bad node type, unexpected " + Std.string(n2.nodeType)))
                    tmp2 = (StringTools.trim(n2.nodeValue) == "")
                else:
                    tmp2 = False
                if tmp2:
                    tmp1 = (not it.hasNext())
                else:
                    tmp1 = False
                if tmp1:
                    if ((n.nodeType == Xml.Document) or ((n.nodeType == Xml.Element))):
                        raise _HxException(("Bad node type, unexpected " + Std.string(n.nodeType)))
                    return n.nodeValue
            raise _HxException((HxOverrides.stringOrNull(self.get_name()) + " does not only have data"))
        if ((v.nodeType != Xml.PCData) and ((v.nodeType != Xml.CData))):
            raise _HxException((HxOverrides.stringOrNull(self.get_name()) + " does not have data"))
        if ((v.nodeType == Xml.Document) or ((v.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + Std.string(v.nodeType)))
        return v.nodeValue

    def get_elements(self):
        it = self.x.elements()
        def _hx_local_1():
            def _hx_local_0():
                x = it.next()
                if (x is None):
                    return None
                return haxe_xml_Fast(x)
            return _hx_AnonObject({'hasNext': it.hasNext, 'next': _hx_local_0})
        return _hx_local_1()

haxe_xml_Fast._hx_class = haxe_xml_Fast


class haxe_xml_XmlParserException:
    _hx_class_name = "haxe.xml.XmlParserException"
    __slots__ = ("message", "lineNumber", "positionAtLine", "position", "xml")
    _hx_fields = ["message", "lineNumber", "positionAtLine", "position", "xml"]
    _hx_methods = ["toString"]

    def __init__(self,message,xml,position):
        self.xml = xml
        self.message = message
        self.position = position
        self.lineNumber = 1
        self.positionAtLine = 0
        _g1 = 0
        while (_g1 < position):
            i = _g1
            _g1 = (_g1 + 1)
            c = (-1 if ((i >= len(xml))) else ord(xml[i]))
            if (c == 10):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.lineNumber
                _hx_local_0.lineNumber = (_hx_local_1 + 1)
                _hx_local_1
                self.positionAtLine = 0
            elif (c != 13):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.positionAtLine
                _hx_local_2.positionAtLine = (_hx_local_3 + 1)
                _hx_local_3

    def toString(self):
        return ((((((HxOverrides.stringOrNull(Type.getClassName(Type.getClass(self))) + ": ") + HxOverrides.stringOrNull(self.message)) + " at line ") + Std.string(self.lineNumber)) + " char ") + Std.string(self.positionAtLine))

haxe_xml_XmlParserException._hx_class = haxe_xml_XmlParserException


class haxe_xml_Parser:
    _hx_class_name = "haxe.xml.Parser"
    __slots__ = ()
    _hx_statics = ["escapes", "parse", "doParse"]

    @staticmethod
    def parse(_hx_str,strict = False):
        if (strict is None):
            strict = False
        doc = Xml.createDocument()
        haxe_xml_Parser.doParse(_hx_str,strict,0,doc)
        return doc

    @staticmethod
    def doParse(_hx_str,strict,p = 0,parent = None):
        if (p is None):
            p = 0
        xml = None
        state = 1
        next = 1
        aname = None
        start = 0
        nsubs = 0
        nbrackets = 0
        c = (-1 if ((p >= len(_hx_str))) else ord(_hx_str[p]))
        buf = StringBuf()
        escapeNext = 1
        attrValQuote = -1
        while (c != -1):
            state1 = state
            if (state1 == 0):
                c1 = c
                if ((((c1 == 32) or ((c1 == 13))) or ((c1 == 10))) or ((c1 == 9))):
                    pass
                else:
                    state = next
                    continue
            elif (state1 == 1):
                if (c == 60):
                    state = 0
                    next = 2
                else:
                    start = p
                    state = 13
                    continue
            elif (state1 == 2):
                c2 = c
                if (c2 == 33):
                    index = (p + 1)
                    if (((-1 if ((index >= len(_hx_str))) else ord(_hx_str[index]))) == 91):
                        p = (p + 2)
                        if (HxString.substr(_hx_str,p,6).upper() != "CDATA["):
                            raise _HxException(haxe_xml_XmlParserException("Expected <![CDATA[",_hx_str,p))
                        p = (p + 5)
                        state = 17
                        start = (p + 1)
                    else:
                        tmp = None
                        index1 = (p + 1)
                        if (((-1 if ((index1 >= len(_hx_str))) else ord(_hx_str[index1]))) != 68):
                            index2 = (p + 1)
                            tmp = (((-1 if ((index2 >= len(_hx_str))) else ord(_hx_str[index2]))) == 100)
                        else:
                            tmp = True
                        if tmp:
                            if (HxString.substr(_hx_str,(p + 2),6).upper() != "OCTYPE"):
                                raise _HxException(haxe_xml_XmlParserException("Expected <!DOCTYPE",_hx_str,p))
                            p = (p + 8)
                            state = 16
                            start = (p + 1)
                        else:
                            tmp1 = None
                            index3 = (p + 1)
                            if (((-1 if ((index3 >= len(_hx_str))) else ord(_hx_str[index3]))) == 45):
                                index4 = (p + 2)
                                tmp1 = (((-1 if ((index4 >= len(_hx_str))) else ord(_hx_str[index4]))) != 45)
                            else:
                                tmp1 = True
                            if tmp1:
                                raise _HxException(haxe_xml_XmlParserException("Expected <!--",_hx_str,p))
                            else:
                                p = (p + 2)
                                state = 15
                                start = (p + 1)
                elif (c2 == 47):
                    if (parent is None):
                        raise _HxException(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    start = (p + 1)
                    state = 0
                    next = 10
                elif (c2 == 63):
                    state = 14
                    start = p
                else:
                    state = 3
                    start = p
                    continue
            elif (state1 == 3):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (p == start):
                        raise _HxException(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    xml = Xml.createElement(HxString.substr(_hx_str,start,(p - start)))
                    parent.addChild(xml)
                    nsubs = (nsubs + 1)
                    state = 0
                    next = 4
                    continue
            elif (state1 == 4):
                c3 = c
                if (c3 == 47):
                    state = 11
                elif (c3 == 62):
                    state = 9
                else:
                    state = 5
                    start = p
                    continue
            elif (state1 == 5):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    tmp2 = None
                    if (start == p):
                        raise _HxException(haxe_xml_XmlParserException("Expected attribute name",_hx_str,p))
                    tmp2 = HxString.substr(_hx_str,start,(p - start))
                    aname = tmp2
                    if xml.exists(tmp2):
                        raise _HxException(haxe_xml_XmlParserException((("Duplicate attribute [" + ("null" if tmp2 is None else tmp2)) + "]"),_hx_str,p))
                    state = 0
                    next = 6
                    continue
            elif (state1 == 6):
                if (c == 61):
                    state = 0
                    next = 7
                else:
                    raise _HxException(haxe_xml_XmlParserException("Expected =",_hx_str,p))
            elif (state1 == 7):
                c4 = c
                if ((c4 == 39) or ((c4 == 34))):
                    buf = StringBuf()
                    state = 8
                    start = (p + 1)
                    attrValQuote = c
                else:
                    raise _HxException(haxe_xml_XmlParserException("Expected \"",_hx_str,p))
            elif (state1 == 8):
                c5 = c
                if (c5 == 38):
                    _hx_len = (p - start)
                    s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
                    buf.b.write(s)
                    state = 18
                    escapeNext = 8
                    start = (p + 1)
                elif ((c5 == 62) or ((c5 == 60))):
                    if strict:
                        raise _HxException(haxe_xml_XmlParserException((("Invalid unescaped " + HxOverrides.stringOrNull("".join(map(chr,[c])))) + " in attribute value"),_hx_str,p))
                    elif (c == attrValQuote):
                        len1 = (p - start)
                        s1 = (HxString.substr(_hx_str,start,None) if ((len1 is None)) else HxString.substr(_hx_str,start,len1))
                        buf.b.write(s1)
                        val = buf.b.getvalue()
                        buf = StringBuf()
                        xml.set(aname,val)
                        state = 0
                        next = 4
                elif (c == attrValQuote):
                    len2 = (p - start)
                    s2 = (HxString.substr(_hx_str,start,None) if ((len2 is None)) else HxString.substr(_hx_str,start,len2))
                    buf.b.write(s2)
                    val1 = buf.b.getvalue()
                    buf = StringBuf()
                    xml.set(aname,val1)
                    state = 0
                    next = 4
            elif (state1 == 9):
                p = haxe_xml_Parser.doParse(_hx_str,strict,p,xml)
                start = p
                state = 1
            elif (state1 == 10):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (start == p):
                        raise _HxException(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    v = HxString.substr(_hx_str,start,(p - start))
                    if (parent.nodeType != Xml.Element):
                        raise _HxException(("Bad node type, expected Element but found " + Std.string(parent.nodeType)))
                    if (v != parent.nodeName):
                        if (parent.nodeType != Xml.Element):
                            raise _HxException(("Bad node type, expected Element but found " + Std.string(parent.nodeType)))
                        raise _HxException(haxe_xml_XmlParserException((("Expected </" + HxOverrides.stringOrNull(parent.nodeName)) + ">"),_hx_str,p))
                    state = 0
                    next = 12
                    continue
            elif (state1 == 11):
                if (c == 62):
                    state = 1
                else:
                    raise _HxException(haxe_xml_XmlParserException("Expected >",_hx_str,p))
            elif (state1 == 12):
                if (c == 62):
                    if (nsubs == 0):
                        parent.addChild(Xml.createPCData(""))
                    return p
                else:
                    raise _HxException(haxe_xml_XmlParserException("Expected >",_hx_str,p))
            elif (state1 == 13):
                if (c == 60):
                    len3 = (p - start)
                    s3 = (HxString.substr(_hx_str,start,None) if ((len3 is None)) else HxString.substr(_hx_str,start,len3))
                    buf.b.write(s3)
                    child = Xml.createPCData(buf.b.getvalue())
                    buf = StringBuf()
                    parent.addChild(child)
                    nsubs = (nsubs + 1)
                    state = 0
                    next = 2
                elif (c == 38):
                    len4 = (p - start)
                    s4 = (HxString.substr(_hx_str,start,None) if ((len4 is None)) else HxString.substr(_hx_str,start,len4))
                    buf.b.write(s4)
                    state = 18
                    escapeNext = 13
                    start = (p + 1)
            elif (state1 == 14):
                tmp3 = None
                if (c == 63):
                    index5 = (p + 1)
                    tmp3 = (((-1 if ((index5 >= len(_hx_str))) else ord(_hx_str[index5]))) == 62)
                else:
                    tmp3 = False
                if tmp3:
                    p = (p + 1)
                    parent.addChild(Xml.createProcessingInstruction(HxString.substr(_hx_str,(start + 1),((p - start) - 2))))
                    nsubs = (nsubs + 1)
                    state = 1
            elif (state1 == 15):
                tmp4 = None
                tmp5 = None
                if (c == 45):
                    index6 = (p + 1)
                    tmp5 = (((-1 if ((index6 >= len(_hx_str))) else ord(_hx_str[index6]))) == 45)
                else:
                    tmp5 = False
                if tmp5:
                    index7 = (p + 2)
                    tmp4 = (((-1 if ((index7 >= len(_hx_str))) else ord(_hx_str[index7]))) == 62)
                else:
                    tmp4 = False
                if tmp4:
                    parent.addChild(Xml.createComment(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    p = (p + 2)
                    state = 1
            elif (state1 == 16):
                if (c == 91):
                    nbrackets = (nbrackets + 1)
                elif (c == 93):
                    nbrackets = (nbrackets - 1)
                elif ((c == 62) and ((nbrackets == 0))):
                    parent.addChild(Xml.createDocType(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    state = 1
            elif (state1 == 17):
                tmp6 = None
                tmp7 = None
                if (c == 93):
                    index8 = (p + 1)
                    tmp7 = (((-1 if ((index8 >= len(_hx_str))) else ord(_hx_str[index8]))) == 93)
                else:
                    tmp7 = False
                if tmp7:
                    index9 = (p + 2)
                    tmp6 = (((-1 if ((index9 >= len(_hx_str))) else ord(_hx_str[index9]))) == 62)
                else:
                    tmp6 = False
                if tmp6:
                    parent.addChild(Xml.createCData(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    p = (p + 2)
                    state = 1
            elif (state1 == 18):
                if (c == 59):
                    s5 = HxString.substr(_hx_str,start,(p - start))
                    if (((-1 if ((0 >= len(s5))) else ord(s5[0]))) == 35):
                        c6 = (Std.parseInt(("0" + HxOverrides.stringOrNull(HxString.substr(s5,1,(len(s5) - 1))))) if ((((-1 if ((1 >= len(s5))) else ord(s5[1]))) == 120)) else Std.parseInt(HxString.substr(s5,1,(len(s5) - 1))))
                        s6 = "".join(map(chr,[c6]))
                        buf.b.write(s6)
                    elif (not (s5 in haxe_xml_Parser.escapes.h)):
                        if strict:
                            raise _HxException(haxe_xml_XmlParserException(("Undefined entity: " + ("null" if s5 is None else s5)),_hx_str,p))
                        s7 = Std.string((("&" + ("null" if s5 is None else s5)) + ";"))
                        buf.b.write(s7)
                    else:
                        s8 = Std.string(haxe_xml_Parser.escapes.h.get(s5,None))
                        buf.b.write(s8)
                    start = (p + 1)
                    state = escapeNext
                elif ((not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))) and ((c != 35))):
                    if strict:
                        raise _HxException(haxe_xml_XmlParserException(("Invalid character in entity: " + HxOverrides.stringOrNull("".join(map(chr,[c])))),_hx_str,p))
                    s9 = "".join(map(chr,[38]))
                    buf.b.write(s9)
                    len5 = (p - start)
                    s10 = (HxString.substr(_hx_str,start,None) if ((len5 is None)) else HxString.substr(_hx_str,start,len5))
                    buf.b.write(s10)
                    def _hx_local_16():
                        nonlocal p
                        _hx_local_15 = p
                        p = (p - 1)
                        return _hx_local_15
                    start = _hx_local_16()
                    state = escapeNext
            else:
                pass
            p = (p + 1)
            index10 = p
            if (index10 >= len(_hx_str)):
                c = -1
            else:
                c = ord(_hx_str[index10])
        if (state == 1):
            start = p
            state = 13
        if (state == 13):
            if ((p != start) or ((nsubs == 0))):
                len6 = (p - start)
                s11 = (HxString.substr(_hx_str,start,None) if ((len6 is None)) else HxString.substr(_hx_str,start,len6))
                buf.b.write(s11)
                parent.addChild(Xml.createPCData(buf.b.getvalue()))
            return p
        if (((not strict) and ((state == 18))) and ((escapeNext == 13))):
            s12 = "".join(map(chr,[38]))
            buf.b.write(s12)
            len7 = (p - start)
            s13 = (HxString.substr(_hx_str,start,None) if ((len7 is None)) else HxString.substr(_hx_str,start,len7))
            buf.b.write(s13)
            parent.addChild(Xml.createPCData(buf.b.getvalue()))
            return p
        raise _HxException(haxe_xml_XmlParserException("Unexpected end",_hx_str,p))
haxe_xml_Parser._hx_class = haxe_xml_Parser


class hxd_BitmapInnerDataImpl:
    _hx_class_name = "hxd.BitmapInnerDataImpl"
    __slots__ = ("pixels", "width", "height")
    _hx_fields = ["pixels", "width", "height"]

    def __init__(self):
        self.height = None
        self.width = None
        self.pixels = None

hxd_BitmapInnerDataImpl._hx_class = hxd_BitmapInnerDataImpl


class hxd_BitmapData:
    _hx_class_name = "hxd.BitmapData"
    __slots__ = ("data",)
    _hx_fields = ["data"]
    _hx_methods = ["setPixel"]

    def __init__(self,width,height):
        self.data = None
        if (not (((width == -101) and ((height == -102))))):
            self.data = hxd_BitmapInnerDataImpl()
            this1 = [None]*(width * height)
            self.data.pixels = this1
            self.data.width = width
            self.data.height = height

    def setPixel(self,x,y,c):
        if ((((x >= 0) and ((y >= 0))) and ((x < self.data.width))) and ((y < self.data.height))):
            self.data.pixels[(x + ((y * self.data.width)))] = c

hxd_BitmapData._hx_class = hxd_BitmapData


class hxd_File:
    _hx_class_name = "hxd.File"
    __slots__ = ()
    _hx_statics = ["saveBytes"]

    @staticmethod
    def saveBytes(path,data):
        sys_io_File.saveBytes(path,data)
hxd_File._hx_class = hxd_File

class hxd_Flags(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Flags"
    _hx_constructs = ["ReadOnly", "AlphaPremultiplied", "FlipY"]
hxd_Flags.ReadOnly = hxd_Flags("ReadOnly", 0, list())
hxd_Flags.AlphaPremultiplied = hxd_Flags("AlphaPremultiplied", 1, list())
hxd_Flags.FlipY = hxd_Flags("FlipY", 2, list())
hxd_Flags._hx_class = hxd_Flags


class hxd_Pixels:
    _hx_class_name = "hxd.Pixels"
    __slots__ = ("bytes", "width", "height", "offset", "flags", "bpp", "innerFormat")
    _hx_fields = ["bytes", "width", "height", "offset", "flags", "bpp", "innerFormat"]
    _hx_methods = ["set_innerFormat", "dispose"]
    _hx_statics = ["bytesPerPixel", "alloc"]

    def __init__(self,width,height,_hx_bytes,format,offset = 0):
        if (offset is None):
            offset = 0
        self.innerFormat = None
        self.bpp = None
        self.flags = None
        self.offset = None
        self.width = width
        self.height = height
        self.bytes = _hx_bytes
        self.set_innerFormat(format)
        self.offset = offset

    def set_innerFormat(self,fmt):
        self.innerFormat = fmt
        self.bpp = hxd_Pixels.bytesPerPixel(fmt)
        return fmt

    def dispose(self):
        if (self.bytes is not None):
            if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) == 0):
                hxd_impl_Tmp.saveBytes(self.bytes)
            self.bytes = None

    @staticmethod
    def bytesPerPixel(format):
        format1 = format.index
        if (((format1 == 2) or ((format1 == 1))) or ((format1 == 0))):
            return 4
        elif (format1 == 3):
            return 8
        elif (format1 == 4):
            return 16
        elif (format1 == 5):
            return 1
        elif (format1 == 6):
            return 2
        elif (format1 == 7):
            return 4
        else:
            pass

    @staticmethod
    def alloc(width,height,format):
        return hxd_Pixels(width,height,hxd_impl_Tmp.getBytes(((width * height) * hxd_Pixels.bytesPerPixel(format))),format)

hxd_Pixels._hx_class = hxd_Pixels

class hxd_Platform(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Platform"
    _hx_constructs = ["IOS", "Android", "WebGL", "PC", "Console", "FlashPlayer"]
hxd_Platform.IOS = hxd_Platform("IOS", 0, list())
hxd_Platform.Android = hxd_Platform("Android", 1, list())
hxd_Platform.WebGL = hxd_Platform("WebGL", 2, list())
hxd_Platform.PC = hxd_Platform("PC", 3, list())
hxd_Platform.Console = hxd_Platform("Console", 4, list())
hxd_Platform.FlashPlayer = hxd_Platform("FlashPlayer", 5, list())
hxd_Platform._hx_class = hxd_Platform


class hxd_fmt_fbx_TmpObject:
    _hx_class_name = "hxd.fmt.fbx.TmpObject"
    __slots__ = ("index", "model", "parent", "isJoint", "isMesh", "childs", "joint", "skin")
    _hx_fields = ["index", "model", "parent", "isJoint", "isMesh", "childs", "joint", "skin"]

    def __init__(self):
        self.skin = None
        self.joint = None
        self.isMesh = None
        self.isJoint = None
        self.parent = None
        self.model = None
        self.index = None
        self.childs = []

hxd_fmt_fbx_TmpObject._hx_class = hxd_fmt_fbx_TmpObject


class hxd_fmt_fbx__BaseLibrary_AnimCurve:
    _hx_class_name = "hxd.fmt.fbx._BaseLibrary.AnimCurve"
    __slots__ = ("_hx_def", "object", "t", "r", "s", "a", "fov", "roll", "uv")
    _hx_fields = ["def", "object", "t", "r", "s", "a", "fov", "roll", "uv"]

    def __init__(self,_hx_def,object):
        self.uv = None
        self.roll = None
        self.fov = None
        self.a = None
        self.s = None
        self.r = None
        self.t = None
        self._hx_def = _hx_def
        self.object = object

hxd_fmt_fbx__BaseLibrary_AnimCurve._hx_class = hxd_fmt_fbx__BaseLibrary_AnimCurve


class hxd_fmt_fbx_DefaultMatrixes:
    _hx_class_name = "hxd.fmt.fbx.DefaultMatrixes"
    __slots__ = ("trans", "scale", "rotate", "preRot", "wasRemoved")
    _hx_fields = ["trans", "scale", "rotate", "preRot", "wasRemoved"]
    _hx_methods = ["toMatrix", "toQuaternion"]

    def __init__(self):
        self.wasRemoved = None
        self.preRot = None
        self.rotate = None
        self.scale = None
        self.trans = None

    def toMatrix(self,leftHand):
        m = h3d_Matrix()
        m.identity()
        if (self.scale is not None):
            m.scale(self.scale.x,self.scale.y,self.scale.z)
        if (self.rotate is not None):
            m.rotate(self.rotate.x,self.rotate.y,self.rotate.z)
        if (self.preRot is not None):
            m.rotate(self.preRot.x,self.preRot.y,self.preRot.z)
        if (self.trans is not None):
            m.translate(self.trans.x,self.trans.y,self.trans.z)
        if leftHand:
            m._12 = -m._12
            m._13 = -m._13
            m._21 = -m._21
            m._31 = -m._31
            m._41 = -m._41
        return m

    def toQuaternion(self,leftHand):
        m = h3d_Matrix()
        m.identity()
        if (self.rotate is not None):
            m.rotate(self.rotate.x,self.rotate.y,self.rotate.z)
        if (self.preRot is not None):
            m.rotate(self.preRot.x,self.preRot.y,self.preRot.z)
        if leftHand:
            m._12 = -m._12
            m._13 = -m._13
            m._21 = -m._21
            m._31 = -m._31
            m._41 = -m._41
        q = h3d_Quat()
        q.initRotateMatrix(m)
        return q

hxd_fmt_fbx_DefaultMatrixes._hx_class = hxd_fmt_fbx_DefaultMatrixes


class hxd_fmt_fbx_BaseLibrary:
    _hx_class_name = "hxd.fmt.fbx.BaseLibrary"
    __slots__ = ("root", "ids", "connect", "namedConnect", "invConnect", "leftHand", "defaultModelMatrixes", "uvAnims", "animationEvents", "version", "keepJoints", "skipObjects", "bonesPerVertex", "maxBonesPerSkin", "unskinnedJointsAsObjects")
    _hx_fields = ["root", "ids", "connect", "namedConnect", "invConnect", "leftHand", "defaultModelMatrixes", "uvAnims", "animationEvents", "version", "keepJoints", "skipObjects", "bonesPerVertex", "maxBonesPerSkin", "unskinnedJointsAsObjects"]
    _hx_methods = ["reset", "load", "convertPoints", "leftHandConvert", "init", "getParent", "getChild", "getSpecChild", "getChilds", "getParents", "ignoreMissingObject", "buildHierarchy", "getObjectCurve", "mergeModels", "addLink", "removeLink", "checkData", "roundValues", "loadAnimation", "sortDistinctFloats", "isNullJoint", "autoMerge", "keepJoint", "createSkin", "round", "getDefaultMatrixes"]

    def __init__(self):
        self.unskinnedJointsAsObjects = None
        self.animationEvents = None
        self.uvAnims = None
        self.defaultModelMatrixes = None
        self.leftHand = None
        self.invConnect = None
        self.namedConnect = None
        self.connect = None
        self.ids = None
        self.maxBonesPerSkin = 34
        self.bonesPerVertex = 3
        self.version = 0.
        self.root = _hx_AnonObject({'name': "Root", 'props': [], 'childs': []})
        self.keepJoints = haxe_ds_StringMap()
        self.skipObjects = haxe_ds_StringMap()
        self.reset()

    def reset(self):
        self.ids = haxe_ds_IntMap()
        self.connect = haxe_ds_IntMap()
        self.namedConnect = haxe_ds_IntMap()
        self.invConnect = haxe_ds_IntMap()
        self.defaultModelMatrixes = haxe_ds_StringMap()

    def load(self,root):
        self.reset()
        self.root = root
        self.version = (hxd_fmt_fbx_FbxTools.toInt(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(root,"FBXHeaderExtension.FBXVersion").props, 0)) / 1000)
        x = self.version
        tmp = None
        try:
            tmp = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        if (tmp != 7):
            raise _HxException("FBX Version 7.x required : use FBX 2010 export")
        _g = 0
        _g1 = root.childs
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.init(c)
        _g2 = 0
        _g11 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
        while (_g2 < len(_g11)):
            m = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
            _g2 = (_g2 + 1)
            _g21 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(m,"Properties70.P")
            while (_g21 < len(_g3)):
                p = (_g3[_g21] if _g21 >= 0 and _g21 < len(_g3) else None)
                _g21 = (_g21 + 1)
                if (hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None)) == "UDP3DSMAX"):
                    userProps = hxd_fmt_fbx_FbxTools.toString((p.props[4] if 4 < len(p.props) else None)).split("&cr;&lf;")
                    _g4 = 0
                    while (_g4 < len(userProps)):
                        p1 = (userProps[_g4] if _g4 >= 0 and _g4 < len(userProps) else None)
                        _g4 = (_g4 + 1)
                        pl = p1.split("=")
                        pname = StringTools.trim((None if ((len(pl) == 0)) else pl.pop(0)))
                        pval = StringTools.trim("=".join([python_Boot.toString1(x1,'') for x1 in pl]))
                        _hx_local_4 = len(pname)
                        if (_hx_local_4 == 6):
                            if (pname == "Events"):
                                xml = None
                                try:
                                    xml = Xml.parse(pval)
                                except Exception as _hx_e:
                                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                    e1 = _hx_e1
                                    raise _HxException(("Invalid Events data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                _g5 = []
                                f = haxe_xml_Fast(xml.firstElement()).get_elements()
                                while f.hasNext():
                                    f1 = f.next().get_innerData().split(" ")
                                    x1 = _hx_AnonObject({'frame': Std.parseInt((None if ((len(f1) == 0)) else f1.pop(0))), 'data': StringTools.trim(" ".join([python_Boot.toString1(x1,'') for x1 in f1]))})
                                    _g5.append(x1)
                                self.animationEvents = _g5
                            else:
                                pass
                        elif (_hx_local_4 == 2):
                            if (pname == "UV"):
                                if (pval != ""):
                                    xml1 = None
                                    try:
                                        xml1 = Xml.parse(pval)
                                    except Exception as _hx_e:
                                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                        e2 = _hx_e1
                                        raise _HxException(("Invalid UV data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                    _g51 = []
                                    f2 = haxe_xml_Fast(xml1.firstElement()).get_elements()
                                    while f2.hasNext():
                                        f3 = f2.next().get_innerData().split(" ")
                                        x2 = _hx_AnonObject({'t': (Std.parseFloat((f3[0] if 0 < len(f3) else None)) * 9622116.25), 'u': Std.parseFloat((f3[1] if 1 < len(f3) else None)), 'v': Std.parseFloat((f3[2] if 2 < len(f3) else None))})
                                        _g51.append(x2)
                                    if (self.uvAnims is None):
                                        self.uvAnims = haxe_ds_StringMap()
                                    self.uvAnims.set(hxd_fmt_fbx_FbxTools.getName(m),_g51)
                            else:
                                pass
                        else:
                            pass

    def convertPoints(self,a):
        p = 0
        _g1 = 0
        x = (len(a) / 3)
        _g = None
        try:
            _g = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            _g = None
        while (_g1 < _g):
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(a, p, -(a[p] if p >= 0 and p < len(a) else None))
            p = (p + 3)

    def leftHandConvert(self):
        if self.leftHand:
            return
        self.leftHand = True
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(g,"Vertices")
            while (_g2 < len(_g3)):
                v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v))
            _g21 = 0
            _g31 = hxd_fmt_fbx_FbxTools.getAll(g,"LayerElementNormal.Normals")
            while (_g21 < len(_g31)):
                v1 = (_g31[_g21] if _g21 >= 0 and _g21 < len(_g31) else None)
                _g21 = (_g21 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v1))

    def init(self,n):
        _g = n.name
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 11):
            if (_g == "Connections"):
                _g1 = 0
                _g11 = n.childs
                while (_g1 < len(_g11)):
                    c = (_g11[_g1] if _g1 >= 0 and _g1 < len(_g11) else None)
                    _g1 = (_g1 + 1)
                    if (c.name != "C"):
                        continue
                    child = hxd_fmt_fbx_FbxTools.toInt((c.props[1] if 1 < len(c.props) else None))
                    parent = hxd_fmt_fbx_FbxTools.toInt((c.props[2] if 2 < len(c.props) else None))
                    if ((self.ids.get(child) is None) or ((self.ids.get(parent) is None))):
                        continue
                    name = (c.props[3] if 3 < len(c.props) else None)
                    if (name is not None):
                        name1 = hxd_fmt_fbx_FbxTools.toString(name)
                        nc = self.namedConnect.get(parent)
                        if (nc is None):
                            nc = haxe_ds_StringMap()
                            self.namedConnect.set(parent,nc)
                        nc.h[name1] = child
                        if (name1 == "LookAtProperty"):
                            continue
                    c1 = self.connect.get(parent)
                    if (c1 is None):
                        c1 = []
                        self.connect.set(parent,c1)
                    c1.append(child)
                    if (parent == 0):
                        continue
                    c2 = self.invConnect.get(child)
                    if (c2 is None):
                        c2 = []
                        self.invConnect.set(child,c2)
                    c2.append(parent)
            else:
                pass
        elif (_hx_local_0 == 7):
            if (_g == "Objects"):
                _g2 = 0
                _g12 = n.childs
                while (_g2 < len(_g12)):
                    c3 = (_g12[_g2] if _g2 >= 0 and _g2 < len(_g12) else None)
                    _g2 = (_g2 + 1)
                    self.ids.set(hxd_fmt_fbx_FbxTools.getId(c3),c3)
            else:
                pass
        else:
            pass

    def getParent(self,node,nodeName,opt = None):
        p = self.getParents(node,nodeName)
        if (len(p) > 1):
            tmp = (((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node)) + " has ") + Std.string(len(p))) + " ") + ("null" if nodeName is None else nodeName)) + " parents ")
            _g = []
            _g1 = 0
            while (_g1 < len(p)):
                o = (p[_g1] if _g1 >= 0 and _g1 < len(p) else None)
                _g1 = (_g1 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(o)
                _g.append(x)
            raise _HxException((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))))
        if ((len(p) == 0) and (not opt)):
            raise _HxException((((("Missing " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node))) + " ") + ("null" if nodeName is None else nodeName)) + " parent"))
        return (p[0] if 0 < len(p) else None)

    def getChild(self,node,nodeName,opt = None):
        c = self.getChilds(node,nodeName)
        if (len(c) > 1):
            tmp = (((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node)) + " has ") + Std.string(len(c))) + " ") + ("null" if nodeName is None else nodeName)) + " childs ")
            _g = []
            _g1 = 0
            while (_g1 < len(c)):
                o = (c[_g1] if _g1 >= 0 and _g1 < len(c) else None)
                _g1 = (_g1 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(o)
                _g.append(x)
            raise _HxException((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))))
        if ((len(c) == 0) and (not opt)):
            raise _HxException((((("Missing " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node))) + " ") + ("null" if nodeName is None else nodeName)) + " child"))
        return (c[0] if 0 < len(c) else None)

    def getSpecChild(self,node,name):
        this1 = self.namedConnect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        nc = this1.h.get(key,None)
        if (nc is None):
            return None
        id = nc.h.get(name,None)
        if (id is None):
            return None
        return self.ids.h.get(id,None)

    def getChilds(self,node,nodeName = None):
        this1 = self.connect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        c = this1.h.get(key,None)
        subs = []
        if (c is not None):
            _g = 0
            while (_g < len(c)):
                id = (c[_g] if _g >= 0 and _g < len(c) else None)
                _g = (_g + 1)
                n = self.ids.h.get(id,None)
                if (n is None):
                    raise _HxException((Std.string(id) + " not found"))
                if ((nodeName is not None) and ((n.name != nodeName))):
                    continue
                subs.append(n)
        return subs

    def getParents(self,node,nodeName = None):
        this1 = self.invConnect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        c = this1.h.get(key,None)
        pl = []
        if (c is not None):
            _g = 0
            while (_g < len(c)):
                id = (c[_g] if _g >= 0 and _g < len(c) else None)
                _g = (_g + 1)
                n = self.ids.h.get(id,None)
                if (n is None):
                    raise _HxException((Std.string(id) + " not found"))
                if ((nodeName is not None) and ((n.name != nodeName))):
                    continue
                pl.append(n)
        return pl

    def ignoreMissingObject(self,name):
        _hx_def = self.defaultModelMatrixes.h.get(name,None)
        if (_hx_def is None):
            _hx_def = hxd_fmt_fbx_DefaultMatrixes()
            _hx_def.wasRemoved = -1
            self.defaultModelMatrixes.h[name] = _hx_def

    def buildHierarchy(self):
        oroot = hxd_fmt_fbx_TmpObject()
        objects = list()
        hobjects = haxe_ds_IntMap()
        hobjects.set(0,oroot)
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
        while (_g < len(_g1)):
            model = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            this1 = self.skipObjects
            key = hxd_fmt_fbx_FbxTools.getName(model)
            if this1.h.get(key,None):
                continue
            mtype = hxd_fmt_fbx_FbxTools.getType(model)
            isJoint = ((mtype == "LimbNode") and (((not self.unskinnedJointsAsObjects) or (not self.isNullJoint(model)))))
            o = hxd_fmt_fbx_TmpObject()
            o.model = model
            o.isJoint = isJoint
            o.isMesh = (mtype == "Mesh")
            hobjects.set(hxd_fmt_fbx_FbxTools.getId(model),o)
            objects.append(o)
        _g2 = 0
        while (_g2 < len(objects)):
            o1 = (objects[_g2] if _g2 >= 0 and _g2 < len(objects) else None)
            _g2 = (_g2 + 1)
            p = self.getParent(o1.model,"Model",True)
            pid = (0 if ((p is None)) else hxd_fmt_fbx_FbxTools.getId(p))
            op = hobjects.h.get(pid,None)
            if (op is None):
                op = oroot
            op.childs.append(o1)
            o1.parent = op
        _g3 = 0
        while (_g3 < len(objects)):
            o2 = (objects[_g3] if _g3 >= 0 and _g3 < len(objects) else None)
            _g3 = (_g3 + 1)
            if (not o2.isMesh):
                continue
            _hx_def = self.getChild(self.getChild(o2.model,"Geometry"),"Deformer",True)
            if (_hx_def is None):
                continue
            _g11 = []
            _g21 = 0
            _g31 = self.getChilds(_hx_def,"Deformer")
            while (_g21 < len(_g31)):
                d = (_g31[_g21] if _g21 >= 0 and _g21 < len(_g31) else None)
                _g21 = (_g21 + 1)
                key1 = hxd_fmt_fbx_FbxTools.getId(self.getChild(d,"Model"))
                x = hobjects.h.get(key1,None)
                _g11.append(x)
            bones = _g11
            if (len(_g11) == 0):
                continue
            o3 = (_g11[0] if 0 < len(_g11) else None)
            k = 0
            while (o3 != oroot):
                o3 = o3.parent
                k = (k + 1)
            minDepth = k
            _g32 = 1
            _g22 = len(_g11)
            while (_g32 < _g22):
                i = _g32
                _g32 = (_g32 + 1)
                o4 = (_g11[i] if i >= 0 and i < len(_g11) else None)
                k1 = 0
                while (o4 != oroot):
                    o4 = o4.parent
                    k1 = (k1 + 1)
                d1 = k1
                if (d1 < minDepth):
                    minDepth = d1
            out = []
            _g33 = 0
            _g23 = len(_g11)
            while (_g33 < _g23):
                i1 = _g33
                _g33 = (_g33 + 1)
                b = (_g11[i1] if i1 >= 0 and i1 < len(_g11) else None)
                o5 = b
                k2 = 0
                while (o5 != oroot):
                    o5 = o5.parent
                    k2 = (k2 + 1)
                n = (k2 - minDepth)
                _g5 = 0
                while (_g5 < n):
                    _g5 = (_g5 + 1)
                    b.isJoint = True
                    b = b.parent
                python_internal_ArrayImpl.remove(out,b)
                out.append(b)
            bones = out
            while (len(bones) > 1):
                _g24 = 0
                while (_g24 < len(bones)):
                    b1 = (bones[_g24] if _g24 >= 0 and _g24 < len(bones) else None)
                    _g24 = (_g24 + 1)
                    b1.isJoint = True
                parents = []
                _g25 = 0
                while (_g25 < len(bones)):
                    b2 = (bones[_g25] if _g25 >= 0 and _g25 < len(bones) else None)
                    _g25 = (_g25 + 1)
                    if ((b2.parent == oroot) or b2.parent.isMesh):
                        continue
                    python_internal_ArrayImpl.remove(parents,b2.parent)
                    x1 = b2.parent
                    parents.append(x1)
                bones = parents
        changed = True
        while changed:
            changed = False
            _g4 = 0
            while (_g4 < len(objects)):
                o6 = (objects[_g4] if _g4 >= 0 and _g4 < len(objects) else None)
                _g4 = (_g4 + 1)
                if (o6.isJoint or o6.isMesh):
                    continue
                if o6.parent.isJoint:
                    o6.isJoint = True
                    changed = True
                    continue
                hasJoint = False
                _g12 = 0
                _g26 = o6.childs
                while (_g12 < len(_g26)):
                    c = (_g26[_g12] if _g12 >= 0 and _g12 < len(_g26) else None)
                    _g12 = (_g12 + 1)
                    if c.isJoint:
                        hasJoint = True
                        break
                if hasJoint:
                    _g13 = 0
                    _g27 = o6.parent.childs
                    while (_g13 < len(_g27)):
                        c1 = (_g27[_g13] if _g13 >= 0 and _g13 < len(_g27) else None)
                        _g13 = (_g13 + 1)
                        if c1.isJoint:
                            o6.isJoint = True
                            changed = True
                            break
        return _hx_AnonObject({'root': oroot, 'objects': objects})

    def getObjectCurve(self,curves,model,curveName,animName):
        key = hxd_fmt_fbx_FbxTools.getId(model)
        c = curves.h.get(key,None)
        if (c is not None):
            return c
        name = hxd_fmt_fbx_FbxTools.getName(model)
        if self.skipObjects.h.get(name,None):
            return None
        _hx_def = self.getDefaultMatrixes(model)
        if (_hx_def is None):
            return None
        if (_hx_def.wasRemoved is not None):
            if (((curveName != "Visibility") and ((curveName != "UV"))) or ((_hx_def.wasRemoved == -1))):
                return None
            model = self.ids.h.get(_hx_def.wasRemoved,None)
            name = hxd_fmt_fbx_FbxTools.getName(model)
            c = curves.h.get(_hx_def.wasRemoved,None)
            _hx_def = self.getDefaultMatrixes(model)
            if (_hx_def is None):
                raise _HxException("assert")
        if (c is None):
            c = hxd_fmt_fbx__BaseLibrary_AnimCurve(_hx_def,name)
            curves.set(hxd_fmt_fbx_FbxTools.getId(model),c)
        return c

    def mergeModels(self,modelNames):
        if (len(modelNames) <= 1):
            return
        models = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
        def _hx_local_1(name):
            _g = 0
            while (_g < len(models)):
                m = (models[_g] if _g >= 0 and _g < len(models) else None)
                _g = (_g + 1)
                if (hxd_fmt_fbx_FbxTools.getName(m) == name):
                    return m
            raise _HxException(("Model not found " + ("null" if name is None else name)))
        getModel = _hx_local_1
        m1 = getModel((modelNames[0] if 0 < len(modelNames) else None))
        geom = hxd_fmt_fbx_Geometry(self,self.getChild(m1,"Geometry"))
        _hx_def = self.getChild(geom.getRoot(),"Deformer",True)
        subDefs = self.getChilds(_hx_def,"Deformer")
        _g1 = 1
        _g2 = len(modelNames)
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            name1 = (modelNames[i] if i >= 0 and i < len(modelNames) else None)
            m2 = getModel(name1)
            geom2 = hxd_fmt_fbx_Geometry(self,self.getChild(m2,"Geometry"))
            x = (len(geom.getVertices()) / 3)
            vcount = None
            try:
                vcount = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                vcount = None
            self.skipObjects.h[name1] = True
            mindex = []
            materials = self.getChilds(m1,"Material")
            _g21 = 0
            _g3 = self.getChilds(m2,"Material")
            while (_g21 < len(_g3)):
                mat = (_g3[_g21] if _g21 >= 0 and _g21 < len(_g3) else None)
                _g21 = (_g21 + 1)
                idx = python_internal_ArrayImpl.indexOf(materials,mat,None)
                if (idx < 0):
                    idx = len(materials)
                    materials.append(mat)
                    self.addLink(m1,mat)
                mindex.append(idx)
            geom.merge(geom2,mindex)
            def2 = self.getChild(geom2.getRoot(),"Deformer",True)
            if (def2 is not None):
                if (_hx_def is None):
                    raise _HxException((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m1)) + " does not have a deformer but ") + ("null" if name1 is None else name1)) + " has one"))
                _g22 = 0
                _g31 = self.getChilds(def2,"Deformer")
                while (_g22 < len(_g31)):
                    subDef = (_g31[_g22] if _g22 >= 0 and _g22 < len(_g31) else None)
                    _g22 = (_g22 + 1)
                    subModel = self.getChild(subDef,"Model")
                    prevDef = None
                    _g4 = 0
                    while (_g4 < len(subDefs)):
                        s = (subDefs[_g4] if _g4 >= 0 and _g4 < len(subDefs) else None)
                        _g4 = (_g4 + 1)
                        if (self.getChild(s,"Model") == subModel):
                            prevDef = s
                            break
                    if (prevDef is not None):
                        self.removeLink(subDef,subModel)
                    idx1 = hxd_fmt_fbx_FbxTools.get(subDef,"Indexes",True)
                    if (idx1 is None):
                        continue
                    if (prevDef is None):
                        self.addLink(_hx_def,subDef)
                        self.removeLink(def2,subDef)
                        subDefs.append(subDef)
                        idx2 = hxd_fmt_fbx_FbxTools.getInts(idx1)
                        _g5 = 0
                        _g41 = len(idx2)
                        while (_g5 < _g41):
                            i1 = _g5
                            _g5 = (_g5 + 1)
                            python_internal_ArrayImpl._set(idx2, i1, ((idx2[i1] if i1 >= 0 and i1 < len(idx2) else None) + vcount))
                    else:
                        pidx = hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(prevDef,"Indexes"))
                        _g42 = 0
                        _g51 = hxd_fmt_fbx_FbxTools.getInts(idx1)
                        while (_g42 < len(_g51)):
                            i2 = (_g51[_g42] if _g42 >= 0 and _g42 < len(_g51) else None)
                            _g42 = (_g42 + 1)
                            pidx.append((i2 + vcount))
                        weights = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(prevDef,"Weights"))
                        _g43 = 0
                        _g52 = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(subDef,"Weights"))
                        while (_g43 < len(_g52)):
                            w = (_g52[_g43] if _g43 >= 0 and _g43 < len(_g52) else None)
                            _g43 = (_g43 + 1)
                            weights.append(w)

    def addLink(self,parent,child):
        pid = hxd_fmt_fbx_FbxTools.getId(parent)
        nid = hxd_fmt_fbx_FbxTools.getId(child)
        self.connect.h.get(pid,None).append(nid)
        self.invConnect.h.get(nid,None).append(pid)

    def removeLink(self,parent,child):
        pid = hxd_fmt_fbx_FbxTools.getId(parent)
        nid = hxd_fmt_fbx_FbxTools.getId(child)
        python_internal_ArrayImpl.remove(self.connect.h.get(pid,None),nid)
        python_internal_ArrayImpl.remove(self.invConnect.h.get(nid,None),pid)

    def checkData(self,t):
        if (t is None):
            return True
        if (t.x is not None):
            v = (t.x[0] if 0 < len(t.x) else None)
            _g = 0
            _g1 = t.x
            while (_g < len(_g1)):
                v2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v != v2):
                    return False
        if (t.y is not None):
            v1 = (t.y[0] if 0 < len(t.y) else None)
            _g2 = 0
            _g11 = t.y
            while (_g2 < len(_g11)):
                v21 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                if (v1 != v21):
                    return False
        if (t.z is not None):
            v3 = (t.z[0] if 0 < len(t.z) else None)
            _g3 = 0
            _g12 = t.z
            while (_g3 < len(_g12)):
                v22 = (_g12[_g3] if _g3 >= 0 and _g3 < len(_g12) else None)
                _g3 = (_g3 + 1)
                if (v3 != v22):
                    return False
        return True

    def roundValues(self,data,_hx_def,mult = 1.):
        if (mult is None):
            mult = 1.
        hasValue = False
        _g1 = 0
        _g = len(data)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            v = ((data[i] if i >= 0 and i < len(data) else None) * mult)
            f = (v - _hx_def)
            if (((-f if ((f < 0)) else f)) > 1e-3):
                hasValue = True
            else:
                v = _hx_def
            python_internal_ArrayImpl._set(data, i, self.round(v))
        return hasValue

    def loadAnimation(self,animName = None,root = None,lib = None):
        if (lib is not None):
            lib.defaultModelMatrixes = self.defaultModelMatrixes
            return lib.loadAnimation(animName)
        if (root is not None):
            l = hxd_fmt_fbx_BaseLibrary()
            l.load(root)
            if self.leftHand:
                l.leftHandConvert()
            l.defaultModelMatrixes = self.defaultModelMatrixes
            return l.loadAnimation(animName)
        animNode = None
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.AnimationStack")
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((animName is None) or ((hxd_fmt_fbx_FbxTools.getName(a) == animName))):
                if (animName is None):
                    animName = hxd_fmt_fbx_FbxTools.getName(a)
                animNode = self.getChild(a,"AnimationLayer")
                break
        if (animNode is None):
            if (animName is not None):
                raise _HxException(("Animation not found " + ("null" if animName is None else animName)))
            if (self.uvAnims is None):
                return None
        curves = haxe_ds_IntMap()
        P0 = h3d_col_Point()
        P1 = h3d_col_Point(1,1,1)
        allTimes = haxe_ds_IntMap()
        if (animNode is not None):
            _g2 = 0
            _g11 = self.getChilds(animNode,"AnimationCurveNode")
            while (_g2 < len(_g11)):
                cn = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                model = self.getParent(cn,"Model",True)
                if (model is None):
                    _g21 = hxd_fmt_fbx_FbxTools.getName(cn)
                    _hx_local_2 = len(_g21)
                    if (_hx_local_2 == 11):
                        if (_g21 == "FieldOfView"):
                            nattr = self.getParent(cn,"NodeAttribute",True)
                            if (nattr is None):
                                model = None
                            else:
                                model = self.getParent(nattr,"Model",True)
                            if (model is None):
                                continue
                        else:
                            continue
                    elif (_hx_local_2 == 4):
                        if (_g21 == "Roll"):
                            nattr = self.getParent(cn,"NodeAttribute",True)
                            if (nattr is None):
                                model = None
                            else:
                                model = self.getParent(nattr,"Model",True)
                            if (model is None):
                                continue
                        else:
                            continue
                    else:
                        continue
                c = self.getObjectCurve(curves,model,hxd_fmt_fbx_FbxTools.getName(cn),animName)
                if (c is None):
                    continue
                data = self.getChilds(cn,"AnimationCurve")
                if (len(data) == 0):
                    continue
                cname = hxd_fmt_fbx_FbxTools.getName(cn)
                times = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((data[0] if 0 < len(data) else None),"KeyTime"))
                _g3 = 0
                _g22 = len(times)
                while (_g3 < _g22):
                    i = _g3
                    _g3 = (_g3 + 1)
                    t = (times[i] if i >= 0 and i < len(times) else None)
                    if (HxOverrides.modf(t, 100) != 0):
                        t = (t + ((100 - (HxOverrides.modf(t, 100)))))
                        python_internal_ArrayImpl._set(times, i, t)
                    it = None
                    try:
                        it = int((t / 200000))
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e = _hx_e1
                        it = None
                    allTimes.set(it,t)
                if (len(data) != 3):
                    values = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((data[0] if 0 < len(data) else None),"KeyValueFloat"))
                    _hx_local_4 = len(cname)
                    if (_hx_local_4 == 10):
                        if (cname == "Visibility"):
                            if (not self.roundValues(values,1)):
                                continue
                            c.a = _hx_AnonObject({'v': values, 't': times})
                            continue
                        else:
                            pass
                    elif (_hx_local_4 == 11):
                        if (cname == "FieldOfView"):
                            ratio = 1.7777777777777777
                            fov = 45.
                            _g23 = 0
                            _g31 = hxd_fmt_fbx_FbxTools.getAll(self.getChild(model,"NodeAttribute"),"Properties70.P")
                            while (_g23 < len(_g31)):
                                p = (_g31[_g23] if _g23 >= 0 and _g23 < len(_g31) else None)
                                _g23 = (_g23 + 1)
                                _g4 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
                                _hx_local_6 = len(_g4)
                                if (_hx_local_6 == 15):
                                    if (_g4 == "FilmAspectRatio"):
                                        ratio = hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))
                                    else:
                                        pass
                                elif (_hx_local_6 == 11):
                                    if (_g4 == "FieldOfView"):
                                        fov = hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))
                                    else:
                                        pass
                                else:
                                    pass
                            _g32 = 0
                            _g24 = len(values)
                            while (_g32 < _g24):
                                i1 = _g32
                                _g32 = (_g32 + 1)
                                python_internal_ArrayImpl._set(values, i1, (((2 * Math.atan((Math.tan(((((values[i1] if i1 >= 0 and i1 < len(values) else None) * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323))
                            if (not self.roundValues(values,(((2 * Math.atan((Math.tan((((fov * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323))):
                                continue
                            c.fov = _hx_AnonObject({'v': values, 't': times})
                            continue
                        else:
                            pass
                    elif (_hx_local_4 == 4):
                        if (cname == "Roll"):
                            if (not self.roundValues(values,0)):
                                continue
                            c.roll = _hx_AnonObject({'v': values, 't': times})
                            continue
                        else:
                            pass
                    else:
                        pass
                    raise _HxException((((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(model)) + ".") + ("null" if cname is None else cname)) + " has ") + Std.string(len(data))) + " curves"))
                data1 = _hx_AnonObject({'x': hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((data[0] if 0 < len(data) else None),"KeyValueFloat")), 'y': hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((data[1] if 1 < len(data) else None),"KeyValueFloat")), 'z': hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((data[2] if 2 < len(data) else None),"KeyValueFloat")), 't': times})
                M = 1.0
                _hx_def = None
                if (cname == "R"):
                    M = 0.017453292519943295
                    if (c._hx_def.rotate is None):
                        _hx_def = P0
                    else:
                        _hx_def = c._hx_def.rotate
                elif (cname == "S"):
                    if (c._hx_def.scale is None):
                        _hx_def = P1
                    else:
                        _hx_def = c._hx_def.scale
                elif (cname == "T"):
                    if (c._hx_def.trans is None):
                        _hx_def = P0
                    else:
                        _hx_def = c._hx_def.trans
                else:
                    raise _HxException(((("Unknown curve " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(model))) + ".") + ("null" if cname is None else cname)))
                hasValue = False
                if self.roundValues(data1.x,_hx_def.x,M):
                    hasValue = True
                if self.roundValues(data1.y,_hx_def.y,M):
                    hasValue = True
                if self.roundValues(data1.z,_hx_def.z,M):
                    hasValue = True
                if (not hasValue):
                    continue
                if (cname == "R"):
                    c.r = data1
                elif (cname == "S"):
                    c.s = data1
                elif (cname == "T"):
                    c.t = data1
                else:
                    raise _HxException("assert")
        if (self.uvAnims is not None):
            modelByName = haxe_ds_StringMap()
            _g5 = 0
            _g12 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
            while (_g5 < len(_g12)):
                obj = (_g12[_g5] if _g5 >= 0 and _g5 < len(_g12) else None)
                _g5 = (_g5 + 1)
                key = hxd_fmt_fbx_FbxTools.getName(obj)
                modelByName.h[key] = obj
            obj1 = self.uvAnims.keys()
            while obj1.hasNext():
                obj2 = obj1.next()
                frames = self.uvAnims.h.get(obj2,None)
                model1 = modelByName.h.get(obj2,None)
                if (model1 is None):
                    raise _HxException((("Missing model '" + ("null" if obj2 is None else obj2)) + "' required by UV animation"))
                c1 = self.getObjectCurve(curves,model1,"UV",animName)
                if (c1 is None):
                    continue
                c1.uv = frames
                _g6 = 0
                while (_g6 < len(frames)):
                    f = (frames[_g6] if _g6 >= 0 and _g6 < len(frames) else None)
                    _g6 = (_g6 + 1)
                    x = (f.t / 200000)
                    key1 = None
                    try:
                        key1 = int(x)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e1 = _hx_e1
                        key1 = None
                    allTimes.set(key1,f.t)
        _g7 = []
        a1 = allTimes.iterator()
        while a1.hasNext():
            a2 = a1.next()
            _g7.append(a2)
        if (len(_g7) == 0):
            return None
        _g7.sort(key= python_lib_Functools.cmp_to_key(self.sortDistinctFloats))
        maxTime = python_internal_ArrayImpl._get(_g7, (len(_g7) - 1))
        minDT = maxTime
        curT = (_g7[0] if 0 < len(_g7) else None)
        _g25 = 1
        _g13 = len(_g7)
        while (_g25 < _g13):
            i2 = _g25
            _g25 = (_g25 + 1)
            t1 = (_g7[i2] if i2 >= 0 and i2 < len(_g7) else None)
            dt = (t1 - curT)
            if (dt < minDT):
                minDT = dt
            curT = t1
        numFrames = None
        if (maxTime == 0):
            numFrames = 1
        else:
            numFrames1 = None
            try:
                numFrames1 = int((((maxTime - (_g7[0] if 0 < len(_g7) else None))) / minDT))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e2 = _hx_e1
                numFrames1 = None
            numFrames = (1 + numFrames1)
        sampling = (15.0 / ((minDT / 3079077200)))
        if (len(_g7) < numFrames):
            t2 = (_g7[0] if 0 < len(_g7) else None)
            while (t2 < maxTime):
                if (python_internal_ArrayImpl.indexOf(_g7,t2,None) < 0):
                    _g7.append(t2)
                t2 = (t2 + minDT)
            _g7.sort(key= python_lib_Functools.cmp_to_key(Reflect.compare))
            if (len(_g7) != numFrames):
                raise _HxException("assert")
        anim = h3d_anim_LinearAnimation(animName,numFrames,sampling)
        q = h3d_Quat()
        q2 = h3d_Quat()
        _g14 = []
        c2 = curves.iterator()
        while c2.hasNext():
            c3 = c2.next()
            _g14.append(c3)
        def _hx_local_10(c4):
            if (c4.roll is not None):
                return "roll"
            elif (c4.fov is not None):
                return "fov"
            elif (c4.uv is not None):
                return "uv"
            else:
                return "position"
        curveName = _hx_local_10
        def _hx_local_11(c11,c21):
            r = Reflect.compare(c11.object,c21.object)
            if (r != 0):
                return r
            return Reflect.compare(curveName(c11),curveName(c21))
        _g14.sort(key= python_lib_Functools.cmp_to_key(_hx_local_11))
        _g26 = 0
        while (_g26 < len(_g14)):
            c5 = (_g14[_g26] if _g26 >= 0 and _g26 < len(_g14) else None)
            _g26 = (_g26 + 1)
            numFrames2 = numFrames
            sameData = True
            if (((((((c5.t is None) and ((c5.r is None))) and ((c5.s is None))) and ((c5.a is None))) and ((c5.uv is None))) and ((c5.roll is None))) and ((c5.fov is None))):
                numFrames2 = 1
            else:
                sameData = self.checkData(c5.t)
                if sameData:
                    sameData = self.checkData(c5.r)
                if sameData:
                    sameData = self.checkData(c5.s)
            frames1 = [None]*(1 if sameData else numFrames2)
            alpha = (None if ((c5.a is None)) else [None]*numFrames2)
            uvs = (None if ((c5.uv is None)) else [None]*(numFrames2 * 2))
            roll = (None if ((c5.roll is None)) else [None]*numFrames2)
            fov1 = (None if ((c5.fov is None)) else [None]*numFrames2)
            if (((((frames1 is None) and ((alpha is None))) and ((uvs is None))) and ((roll is None))) and ((fov1 is None))):
                continue
            ctx = (None if ((c5.t is None)) else c5.t.x)
            cty = (None if ((c5.t is None)) else c5.t.y)
            ctz = (None if ((c5.t is None)) else c5.t.z)
            ctt = ([-1.] if ((c5.t is None)) else c5.t.t)
            crx = (None if ((c5.r is None)) else c5.r.x)
            cry = (None if ((c5.r is None)) else c5.r.y)
            crz = (None if ((c5.r is None)) else c5.r.z)
            crt = ([-1.] if ((c5.r is None)) else c5.r.t)
            csx = (None if ((c5.s is None)) else c5.s.x)
            csy = (None if ((c5.s is None)) else c5.s.y)
            csz = (None if ((c5.s is None)) else c5.s.z)
            cst = ([-1.] if ((c5.s is None)) else c5.s.t)
            cav = (None if ((c5.a is None)) else c5.a.v)
            cat = (None if ((c5.a is None)) else c5.a.t)
            cuv = c5.uv
            def1 = c5._hx_def
            tp = 0
            rp = 0
            sp = 0
            ap = 0
            uvp = 0
            fovp = 0
            rollp = 0
            curFrame = None
            _g41 = 0
            _g33 = numFrames2
            while (_g41 < _g33):
                f1 = _g41
                _g41 = (_g41 + 1)
                changed = (curFrame is None)
                if ((_g7[f1] if f1 >= 0 and f1 < len(_g7) else None) == (ctt[tp] if tp >= 0 and tp < len(ctt) else None)):
                    changed = True
                    tp = (tp + 1)
                if ((_g7[f1] if f1 >= 0 and f1 < len(_g7) else None) == (crt[rp] if rp >= 0 and rp < len(crt) else None)):
                    changed = True
                    rp = (rp + 1)
                if ((_g7[f1] if f1 >= 0 and f1 < len(_g7) else None) == (cst[sp] if sp >= 0 and sp < len(cst) else None)):
                    changed = True
                    sp = (sp + 1)
                if changed:
                    f2 = h3d_anim_LinearFrame()
                    if ((c5.s is None) or ((sp == 0))):
                        if (def1.scale is not None):
                            f2.sx = def1.scale.x
                            f2.sy = def1.scale.y
                            f2.sz = def1.scale.z
                        else:
                            f2.sx = 1
                            f2.sy = 1
                            f2.sz = 1
                    else:
                        f2.sx = python_internal_ArrayImpl._get(csx, (sp - 1))
                        f2.sy = python_internal_ArrayImpl._get(csy, (sp - 1))
                        f2.sz = python_internal_ArrayImpl._get(csz, (sp - 1))
                    if ((c5.r is None) or ((rp == 0))):
                        if (def1.rotate is not None):
                            q.initRotate(def1.rotate.x,def1.rotate.y,def1.rotate.z)
                        else:
                            def _hx_local_17():
                                def _hx_local_16():
                                    q.z = 0
                                    return q.z
                                q.y = _hx_local_16()
                                return q.y
                            q.x = _hx_local_17()
                            q.w = 1
                    else:
                        q.initRotate(python_internal_ArrayImpl._get(crx, (rp - 1)),python_internal_ArrayImpl._get(cry, (rp - 1)),python_internal_ArrayImpl._get(crz, (rp - 1)))
                    if (def1.preRot is not None):
                        q2.initRotate(def1.preRot.x,def1.preRot.y,def1.preRot.z)
                        q.multiply(q,q2)
                    f2.qx = q.x
                    f2.qy = q.y
                    f2.qz = q.z
                    f2.qw = q.w
                    if ((c5.t is None) or ((tp == 0))):
                        if (def1.trans is not None):
                            f2.tx = def1.trans.x
                            f2.ty = def1.trans.y
                            f2.tz = def1.trans.z
                        else:
                            f2.tx = 0
                            f2.ty = 0
                            f2.tz = 0
                    else:
                        f2.tx = python_internal_ArrayImpl._get(ctx, (tp - 1))
                        f2.ty = python_internal_ArrayImpl._get(cty, (tp - 1))
                        f2.tz = python_internal_ArrayImpl._get(ctz, (tp - 1))
                    if self.leftHand:
                        f2.tx = -f2.tx
                        f2.qy = -f2.qy
                        f2.qz = -f2.qz
                    curFrame = f2
                if ((frames1 is not None) and ((f1 < len(frames1)))):
                    frames1[f1] = curFrame
                if (alpha is not None):
                    if ((_g7[f1] if f1 >= 0 and f1 < len(_g7) else None) == (cat[ap] if ap >= 0 and ap < len(cat) else None)):
                        ap = (ap + 1)
                    val = python_internal_ArrayImpl._get(cav, (ap - 1))
                    alpha[f1] = val
                if (uvs is not None):
                    if ((uvp < len(cuv)) and (((_g7[f1] if f1 >= 0 and f1 < len(_g7) else None) == (cuv[uvp] if uvp >= 0 and uvp < len(cuv) else None).t))):
                        uvp = (uvp + 1)
                    val1 = python_internal_ArrayImpl._get(cuv, (uvp - 1)).u
                    uvs[(f1 << 1)] = val1
                    val2 = python_internal_ArrayImpl._get(cuv, (uvp - 1)).v
                    uvs[((f1 << 1) | 1)] = val2
                if (roll is not None):
                    if ((_g7[f1] if f1 >= 0 and f1 < len(_g7) else None) == python_internal_ArrayImpl._get(c5.roll.t, rollp)):
                        rollp = (rollp + 1)
                    val3 = python_internal_ArrayImpl._get(c5.roll.v, (rollp - 1))
                    roll[f1] = val3
                if (fov1 is not None):
                    if ((_g7[f1] if f1 >= 0 and f1 < len(_g7) else None) == python_internal_ArrayImpl._get(c5.fov.t, fovp)):
                        fovp = (fovp + 1)
                    val4 = python_internal_ArrayImpl._get(c5.fov.v, (fovp - 1))
                    fov1[f1] = val4
            if (frames1 is not None):
                anim.addCurve(c5.object,frames1,((c5.r is not None) or ((def1.rotate is not None))),((c5.s is not None) or ((def1.scale is not None))))
            if (alpha is not None):
                anim.addAlphaCurve(c5.object,alpha)
            if (uvs is not None):
                anim.addUVCurve(c5.object,uvs)
            if (roll is not None):
                anim.addPropCurve(c5.object,"Roll",roll)
            if (fov1 is not None):
                anim.addPropCurve(c5.object,"FOVY",fov1)
        return anim

    def sortDistinctFloats(self,a,b):
        if (a > b):
            return 1
        else:
            return -1

    def isNullJoint(self,model):
        if (len(self.getParents(model,"Deformer")) > 0):
            return False
        parent = self.getParent(model,"Model",True)
        if (parent is None):
            return True
        t = hxd_fmt_fbx_FbxTools.getType(parent)
        if ((t == "LimbNode") or ((t == "Root"))):
            return False
        return True

    def autoMerge(self):
        toMerge = []
        mergeGroups = haxe_ds_IntMap()
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
        while (_g < len(_g1)):
            model = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            this1 = self.skipObjects
            key = hxd_fmt_fbx_FbxTools.getName(model)
            if this1.h.get(key,None):
                continue
            if (not (((hxd_fmt_fbx_FbxTools.getType(model) == "LimbNode") and (((not self.unskinnedJointsAsObjects) or (not self.isNullJoint(model))))))):
                continue
            deformers = self.getParents(model,"Deformer")
            if (len(deformers) <= 1):
                continue
            group = []
            _g2 = 0
            while (_g2 < len(deformers)):
                d = (deformers[_g2] if _g2 >= 0 and _g2 < len(deformers) else None)
                _g2 = (_g2 + 1)
                _hx_def = self.getParent(d,"Deformer")
                if (_hx_def is None):
                    continue
                geom = self.getParent(_hx_def,"Geometry")
                if (geom is None):
                    continue
                model2 = self.getParent(geom,"Model")
                if (model2 is None):
                    continue
                id = hxd_fmt_fbx_FbxTools.getId(model2)
                g = mergeGroups.h.get(id,None)
                if (g is not None):
                    _g3 = 0
                    while (_g3 < len(g)):
                        g1 = (g[_g3] if _g3 >= 0 and _g3 < len(g) else None)
                        _g3 = (_g3 + 1)
                        python_internal_ArrayImpl.remove(group,g1)
                        group.append(g1)
                    python_internal_ArrayImpl.remove(toMerge,g)
                python_internal_ArrayImpl.remove(group,model2)
                group.append(model2)
                mergeGroups.set(id,group)
            toMerge.append(group)
        _g4 = 0
        while (_g4 < len(toMerge)):
            group1 = (toMerge[_g4] if _g4 >= 0 and _g4 < len(toMerge) else None)
            _g4 = (_g4 + 1)
            def _hx_local_4(m1,m2):
                return Reflect.compare(hxd_fmt_fbx_FbxTools.getName(m1),hxd_fmt_fbx_FbxTools.getName(m2))
            group1.sort(key= python_lib_Functools.cmp_to_key(_hx_local_4))
            _g11 = 0
            while (_g11 < len(toMerge)):
                g2 = (toMerge[_g11] if _g11 >= 0 and _g11 < len(toMerge) else None)
                _g11 = (_g11 + 1)
                if (g2 is not group1):
                    found = False
                    _g21 = 0
                    while (_g21 < len(group1)):
                        m = (group1[_g21] if _g21 >= 0 and _g21 < len(group1) else None)
                        _g21 = (_g21 + 1)
                        if python_internal_ArrayImpl.remove(g2,m):
                            found = True
                    if found:
                        g2.append((group1[0] if 0 < len(group1) else None))
            _g12 = []
            _g22 = 0
            while (_g22 < len(group1)):
                g3 = (group1[_g22] if _g22 >= 0 and _g22 < len(group1) else None)
                _g22 = (_g22 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(g3)
                _g12.append(x)
            self.mergeModels(_g12)

    def keepJoint(self,j):
        return self.keepJoints.h.get(j.name,None)

    def createSkin(self,hskins,hgeom,rootJoints,bonesPerVertex):
        allJoints = []
        collectJoints = None
        def _hx_local_1(j):
            _g = 0
            _g1 = j.subs
            while (_g < len(_g1)):
                j1 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                collectJoints(j1)
            allJoints.append(j)
        collectJoints = _hx_local_1
        collectJoints1 = collectJoints
        _g2 = 0
        while (_g2 < len(rootJoints)):
            j2 = (rootJoints[_g2] if _g2 >= 0 and _g2 < len(rootJoints) else None)
            _g2 = (_g2 + 1)
            collectJoints1(j2)
        skin = None
        iterJoints = list(allJoints)
        _g3 = 0
        while (_g3 < len(iterJoints)):
            j3 = (iterJoints[_g3] if _g3 >= 0 and _g3 < len(iterJoints) else None)
            _g3 = (_g3 + 1)
            jModel = self.ids.h.get(j3.index,None)
            subDef = self.getParent(jModel,"Deformer",True)
            this1 = self.defaultModelMatrixes
            key = hxd_fmt_fbx_FbxTools.getName(jModel)
            defMat = this1.h.get(key,None)
            j3.defMat = defMat.toMatrix(self.leftHand)
            if (subDef is None):
                if ((len(j3.subs) > 0) or self.keepJoint(j3)):
                    continue
                if (j3.parent is None):
                    python_internal_ArrayImpl.remove(rootJoints,j3)
                else:
                    python_internal_ArrayImpl.remove(j3.parent.subs,j3)
                python_internal_ArrayImpl.remove(allJoints,j3)
                defMat.wasRemoved = -1
                continue
            if (skin is None):
                _hx_def = self.getParent(subDef,"Deformer")
                key1 = hxd_fmt_fbx_FbxTools.getId(_hx_def)
                skin = hskins.h.get(key1,None)
                if (skin is not None):
                    return skin
                key2 = hxd_fmt_fbx_FbxTools.getId(self.getParent(_hx_def,"Geometry"))
                geom = hgeom.h.get(key2,None)
                skin = h3d_anim_Skin(None,geom.vertexCount(),bonesPerVertex)
                geom.setSkin(skin)
                hskins.set(hxd_fmt_fbx_FbxTools.getId(_hx_def),skin)
            j3.transPos = h3d_Matrix.L(hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(subDef,"Transform")))
            if self.leftHand:
                m = j3.transPos
                m._12 = -m._12
                m._13 = -m._13
                m._21 = -m._21
                m._31 = -m._31
                m._41 = -m._41
            weights = hxd_fmt_fbx_FbxTools.getAll(subDef,"Weights")
            if (len(weights) > 0):
                weights1 = hxd_fmt_fbx_FbxTools.getFloats((weights[0] if 0 < len(weights) else None))
                vertex = hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(subDef,"Indexes"))
                _g21 = 0
                _g11 = len(vertex)
                while (_g21 < _g11):
                    i = _g21
                    _g21 = (_g21 + 1)
                    w = (weights1[i] if i >= 0 and i < len(weights1) else None)
                    if (w < 0.01):
                        continue
                    vid = (vertex[i] if i >= 0 and i < len(vertex) else None)
                    il = (skin.envelop[vid] if vid >= 0 and vid < len(skin.envelop) else None)
                    if (il is None):
                        def _hx_local_4():
                            python_internal_ArrayImpl._set(skin.envelop, vid, [])
                            return (skin.envelop[vid] if vid >= 0 and vid < len(skin.envelop) else None)
                        il = _hx_local_4()
                    x = h3d_anim__Skin_Influence(j3,w)
                    il.append(x)
        if (skin is None):
            _g4 = []
            _g12 = 0
            while (_g12 < len(iterJoints)):
                j4 = (iterJoints[_g12] if _g12 >= 0 and _g12 < len(iterJoints) else None)
                _g12 = (_g12 + 1)
                x1 = j4.name
                _g4.append(x1)
            raise _HxException((("No joint is skinned (" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g4]))) + ")"))
        allJoints.reverse()
        _g13 = 0
        _g5 = len(allJoints)
        while (_g13 < _g5):
            i1 = _g13
            _g13 = (_g13 + 1)
            (allJoints[i1] if i1 >= 0 and i1 < len(allJoints) else None).index = i1
        skin.setJoints(allJoints,rootJoints)
        skin.initWeights()
        return skin

    def round(self,v):
        v1 = (v * 131072)
        return (((v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor((v1 + 0.5))))) / 131072)

    def getDefaultMatrixes(self,model):
        name = hxd_fmt_fbx_FbxTools.getName(model)
        d = self.defaultModelMatrixes.h.get(name,None)
        if (d is not None):
            return d
        d = hxd_fmt_fbx_DefaultMatrixes()
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(model,"Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 15):
                if (_g2 == "Lcl Translation"):
                    d.trans = h3d_col_Point(self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None))))
                    if (((d.trans.x == 0) and ((d.trans.y == 0))) and ((d.trans.z == 0))):
                        d.trans = None
                else:
                    pass
            elif (_hx_local_1 == 11):
                if (_g2 == "Lcl Scaling"):
                    d.scale = h3d_col_Point(self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None))))
                    if (((d.scale.x == 1) and ((d.scale.y == 1))) and ((d.scale.z == 1))):
                        d.scale = None
                elif (_g2 == "PreRotation"):
                    d.preRot = h3d_col_Point(self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * 0.017453292519943295)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * 0.017453292519943295)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * 0.017453292519943295)))
                    if (((d.preRot.x == 0) and ((d.preRot.y == 0))) and ((d.preRot.z == 0))):
                        d.preRot = None
                else:
                    pass
            elif (_hx_local_1 == 12):
                if (_g2 == "Lcl Rotation"):
                    d.rotate = h3d_col_Point(self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * 0.017453292519943295)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * 0.017453292519943295)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * 0.017453292519943295)))
                    if (((d.rotate.x == 0) and ((d.rotate.y == 0))) and ((d.rotate.z == 0))):
                        d.rotate = None
                else:
                    pass
            elif (_hx_local_1 == 20):
                if (_g2 == "GeometricTranslation"):
                    pass
                else:
                    pass
            else:
                pass
        self.defaultModelMatrixes.h[name] = d
        return d

hxd_fmt_fbx_BaseLibrary._hx_class = hxd_fmt_fbx_BaseLibrary

class hxd_fmt_fbx_FbxProp(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.fbx.FbxProp"
    _hx_constructs = ["PInt", "PFloat", "PString", "PIdent", "PInts", "PFloats"]

    @staticmethod
    def PInt(v):
        return hxd_fmt_fbx_FbxProp("PInt", 0, [v])

    @staticmethod
    def PFloat(v):
        return hxd_fmt_fbx_FbxProp("PFloat", 1, [v])

    @staticmethod
    def PString(v):
        return hxd_fmt_fbx_FbxProp("PString", 2, [v])

    @staticmethod
    def PIdent(i):
        return hxd_fmt_fbx_FbxProp("PIdent", 3, [i])

    @staticmethod
    def PInts(v):
        return hxd_fmt_fbx_FbxProp("PInts", 4, [v])

    @staticmethod
    def PFloats(v):
        return hxd_fmt_fbx_FbxProp("PFloats", 5, [v])
hxd_fmt_fbx_FbxProp._hx_class = hxd_fmt_fbx_FbxProp


class hxd_fmt_fbx_FbxTools:
    _hx_class_name = "hxd.fmt.fbx.FbxTools"
    __slots__ = ()
    _hx_statics = ["get", "getAll", "getInts", "getFloats", "toInt", "toFloat", "toString", "getId", "getName", "getType"]

    @staticmethod
    def get(n,path,opt = False):
        if (opt is None):
            opt = False
        parts = path.split(".")
        cur = n
        _g = 0
        while (_g < len(parts)):
            p = (parts[_g] if _g >= 0 and _g < len(parts) else None)
            _g = (_g + 1)
            found = False
            _g1 = 0
            _g2 = cur.childs
            while (_g1 < len(_g2)):
                c = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                if (c.name == p):
                    cur = c
                    found = True
                    break
            if (not found):
                if opt:
                    return None
                raise _HxException((((((HxOverrides.stringOrNull(n.name) + " does not have ") + ("null" if path is None else path)) + " (") + ("null" if p is None else p)) + " not found)"))
        return cur

    @staticmethod
    def getAll(n,path):
        parts = path.split(".")
        cur = [n]
        _g = 0
        while (_g < len(parts)):
            p = (parts[_g] if _g >= 0 and _g < len(parts) else None)
            _g = (_g + 1)
            out = []
            _g1 = 0
            while (_g1 < len(cur)):
                n1 = (cur[_g1] if _g1 >= 0 and _g1 < len(cur) else None)
                _g1 = (_g1 + 1)
                _g2 = 0
                _g3 = n1.childs
                while (_g2 < len(_g3)):
                    c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if (c.name == p):
                        out.append(c)
            cur = out
            if (len(out) == 0):
                return out
        return cur

    @staticmethod
    def getInts(n):
        if (len(n.props) != 1):
            raise _HxException((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        if (_g.index == 4):
            return _g.params[0]
        else:
            raise _HxException((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))

    @staticmethod
    def getFloats(n):
        if (len(n.props) != 1):
            raise _HxException((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        _g1 = _g.index
        if (_g1 == 4):
            i = _g.params[0]
            fl = list()
            _g2 = 0
            while (_g2 < len(i)):
                x = (i[_g2] if _g2 >= 0 and _g2 < len(i) else None)
                _g2 = (_g2 + 1)
                fl.append(x)
            python_internal_ArrayImpl._set(n.props, 0, hxd_fmt_fbx_FbxProp.PFloats(fl))
            return fl
        elif (_g1 == 5):
            return _g.params[0]
        else:
            raise _HxException((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))

    @staticmethod
    def toInt(n):
        if (n is None):
            raise _HxException("null prop")
        n1 = n.index
        if (n1 == 0):
            return n.params[0]
        elif (n1 == 1):
            f = n.params[0]
            tmp = None
            try:
                tmp = int(f)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp = None
            return tmp
        else:
            raise _HxException(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toFloat(n):
        if (n is None):
            raise _HxException("null prop")
        n1 = n.index
        if (n1 == 0):
            return (n.params[0] * 1.0)
        elif (n1 == 1):
            return n.params[0]
        else:
            raise _HxException(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toString(n):
        if (n is None):
            raise _HxException("null prop")
        if (n.index == 2):
            return n.params[0]
        else:
            raise _HxException(("Invalid prop " + Std.string(n)))

    @staticmethod
    def getId(n):
        if (len(n.props) != 3):
            raise _HxException((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        _g1 = _g.index
        if (_g1 == 0):
            return _g.params[0]
        elif (_g1 == 1):
            id = _g.params[0]
            tmp = None
            try:
                tmp = int(id)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp = None
            return tmp
        else:
            raise _HxException(((HxOverrides.stringOrNull(n.name) + " is not an object ") + Std.string(n.props)))

    @staticmethod
    def getName(n):
        if (len(n.props) != 3):
            raise _HxException((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[1] if 1 < len(n.props) else None)
        if (_g.index == 2):
            _this = _g.params[0].split("::")
            return (None if ((len(_this) == 0)) else _this.pop())
        else:
            raise _HxException((HxOverrides.stringOrNull(n.name) + " is not an object"))

    @staticmethod
    def getType(n):
        if (len(n.props) != 3):
            raise _HxException((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[2] if 2 < len(n.props) else None)
        if (_g.index == 2):
            return _g.params[0]
        else:
            raise _HxException((HxOverrides.stringOrNull(n.name) + " is not an object"))
hxd_fmt_fbx_FbxTools._hx_class = hxd_fmt_fbx_FbxTools


class hxd_fmt_fbx_Geometry:
    _hx_class_name = "hxd.fmt.fbx.Geometry"
    __slots__ = ("lib", "root")
    _hx_fields = ["lib", "root"]
    _hx_methods = ["getRoot", "getVertices", "getPolygons", "getMaterials", "getMaterialByTriangle", "merge", "getIndexes", "getNormals", "getColors", "getUVs", "getGeomMatrix"]

    def __init__(self,l,root):
        self.lib = l
        self.root = root

    def getRoot(self):
        return self.root

    def getVertices(self):
        return hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(self.root,"Vertices"))

    def getPolygons(self):
        return hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(self.root,"PolygonVertexIndex"))

    def getMaterials(self):
        mats = hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementMaterial",True)
        if (mats is None):
            return None
        else:
            return hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(mats,"Materials"))

    def getMaterialByTriangle(self):
        mids = self.getMaterials()
        pos = 0
        count = 0
        mats = []
        _g = 0
        _g1 = self.getPolygons()
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            count = (count + 1)
            if (p >= 0):
                continue
            m = pos
            pos = (pos + 1)
            m1 = (mids[m] if m >= 0 and m < len(mids) else None)
            _g3 = 0
            _g2 = (count - 2)
            while (_g3 < _g2):
                _g3 = (_g3 + 1)
                mats.append(m1)
            count = 0
        return mats

    def merge(self,g,materials):
        vl = self.getVertices()
        x = (len(vl) / 3)
        vcount = None
        try:
            vcount = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            vcount = None
        if ((g.getGeomMatrix() is not None) or ((self.getGeomMatrix() is not None))):
            raise _HxException("TODO")
        _g = 0
        _g1 = g.getVertices()
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            vl.append(v)
        poly = self.getPolygons()
        mats = self.getMaterials()
        if ((len(mats) == 1) and ((hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementMaterial.MappingInformationType").props, 0)) == "AllSame"))):
            polyCount = 0
            _g2 = 0
            while (_g2 < len(poly)):
                p = (poly[_g2] if _g2 >= 0 and _g2 < len(poly) else None)
                _g2 = (_g2 + 1)
                if (p < 0):
                    polyCount = (polyCount + 1)
            m0 = (mats[0] if 0 < len(mats) else None)
            _g11 = 1
            _g3 = polyCount
            while (_g11 < _g3):
                _g11 = (_g11 + 1)
                mats.append(m0)
        polyCount1 = 0
        _g4 = 0
        _g12 = g.getPolygons()
        while (_g4 < len(_g12)):
            p1 = (_g12[_g4] if _g4 >= 0 and _g4 < len(_g12) else None)
            _g4 = (_g4 + 1)
            p2 = p1
            if (p1 < 0):
                polyCount1 = (polyCount1 + 1)
                p2 = (p1 - vcount)
            else:
                p2 = (p1 + vcount)
            poly.append(p2)
        normals = self.getNormals()
        _g5 = 0
        _g13 = g.getNormals()
        while (_g5 < len(_g13)):
            n = (_g13[_g5] if _g5 >= 0 and _g5 < len(_g13) else None)
            _g5 = (_g5 + 1)
            normals.append(n)
        uv = self.getUVs()
        uv2 = g.getUVs()
        if (len(uv) != len(uv2)):
            raise _HxException((((("Different UV layer (" + Std.string(len(uv2))) + " should be ") + Std.string(len(uv))) + ")"))
        _g14 = 0
        _g6 = len(uv)
        while (_g14 < _g6):
            i = _g14
            _g14 = (_g14 + 1)
            uv1 = (uv[i] if i >= 0 and i < len(uv) else None)
            uv21 = (uv2[i] if i >= 0 and i < len(uv2) else None)
            count = (len(uv1.values) >> 1)
            _g21 = 0
            _g31 = uv21.values
            while (_g21 < len(_g31)):
                v1 = (_g31[_g21] if _g21 >= 0 and _g21 < len(_g31) else None)
                _g21 = (_g21 + 1)
                uv1.values.append(v1)
            _g22 = 0
            _g32 = uv21.index
            while (_g22 < len(_g32)):
                i1 = (_g32[_g22] if _g22 >= 0 and _g22 < len(_g32) else None)
                _g22 = (_g22 + 1)
                uv1.index.append((i1 + count))
        colors = self.getColors()
        colors2 = g.getColors()
        if (colors is not None):
            if (colors2 is not None):
                count1 = (len(colors.values) >> 2)
                _g7 = 0
                _g15 = colors2.values
                while (_g7 < len(_g15)):
                    v2 = (_g15[_g7] if _g7 >= 0 and _g7 < len(_g15) else None)
                    _g7 = (_g7 + 1)
                    colors.values.append(v2)
                _g8 = 0
                _g16 = colors2.index
                while (_g8 < len(_g16)):
                    i2 = (_g16[_g8] if _g8 >= 0 and _g8 < len(_g16) else None)
                    _g8 = (_g8 + 1)
                    colors.index.append((i2 + count1))
            else:
                count2 = (len(colors.values) >> 2)
                x1 = (len(g.getNormals()) / 3)
                count21 = None
                try:
                    count21 = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e1 = _hx_e1
                    count21 = None
                colors.values.append(1)
                colors.values.append(1)
                colors.values.append(1)
                colors.values.append(1)
                _g17 = 0
                _g9 = count21
                while (_g17 < _g9):
                    _g17 = (_g17 + 1)
                    colors.index.append(count2)
        m2 = g.getMaterials()
        if (m2 is None):
            mid = (materials[0] if 0 < len(materials) else None)
            _g18 = 0
            _g10 = polyCount1
            while (_g18 < _g10):
                _g18 = (_g18 + 1)
                mats.append(mid)
        elif ((polyCount1 > 1) and ((len(m2) == 1))):
            m = (m2[0] if 0 < len(m2) else None)
            _g19 = 0
            _g20 = polyCount1
            while (_g19 < _g20):
                _g19 = (_g19 + 1)
                mats.append((materials[m] if m >= 0 and m < len(materials) else None))
        else:
            _g23 = 0
            while (_g23 < len(m2)):
                m1 = (m2[_g23] if _g23 >= 0 and _g23 < len(m2) else None)
                _g23 = (_g23 + 1)
                mats.append((materials[m1] if m1 >= 0 and m1 < len(materials) else None))

    def getIndexes(self):
        count = 0
        pos = 0
        index = self.getPolygons()
        vout = []
        iout = []
        _g = 0
        while (_g < len(index)):
            i = (index[_g] if _g >= 0 and _g < len(index) else None)
            _g = (_g + 1)
            count = (count + 1)
            if (i < 0):
                python_internal_ArrayImpl._set(index, pos, (-i - 1))
                start = ((pos - count) + 1)
                _g2 = 0
                _g1 = count
                while (_g2 < _g1):
                    n = _g2
                    _g2 = (_g2 + 1)
                    vout.append(python_internal_ArrayImpl._get(index, (n + start)))
                _g21 = 0
                _g11 = (count - 2)
                while (_g21 < _g11):
                    n1 = _g21
                    _g21 = (_g21 + 1)
                    iout.append((start + n1))
                    iout.append(((start + count) - 1))
                    iout.append(((start + n1) + 1))
                python_internal_ArrayImpl._set(index, pos, i)
                count = 0
            pos = (pos + 1)
        return _hx_AnonObject({'vidx': vout, 'idx': iout})

    def getNormals(self):
        nrm = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementNormal.Normals"))
        if (hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementNormal.MappingInformationType").props, 0)) == "ByVertice"):
            nout = []
            _g = 0
            _g1 = self.getPolygons()
            while (_g < len(_g1)):
                i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                vid = i
                if (i < 0):
                    vid = (-i - 1)
                nout.append(python_internal_ArrayImpl._get(nrm, (vid * 3)))
                nout.append(python_internal_ArrayImpl._get(nrm, ((vid * 3) + 1)))
                nout.append(python_internal_ArrayImpl._get(nrm, ((vid * 3) + 2)))
            nrm = nout
        return nrm

    def getColors(self):
        color = hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementColor",True)
        if (color is None):
            return None
        else:
            return _hx_AnonObject({'values': hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(color,"Colors")), 'index': hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(color,"ColorIndex"))})

    def getUVs(self):
        uvs = []
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"LayerElementUV")
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            index = hxd_fmt_fbx_FbxTools.get(v,"UVIndex",True)
            values = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(v,"UV"))
            index1 = None
            if (index is None):
                _g2 = []
                _g3 = 0
                _g4 = self.getPolygons()
                while (_g3 < len(_g4)):
                    i = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    _g2.append(((-i - 1) if ((i < 0)) else i))
                index1 = _g2
            else:
                index1 = hxd_fmt_fbx_FbxTools.getInts(index)
            uvs.append(_hx_AnonObject({'values': values, 'index': index1}))
        return uvs

    def getGeomMatrix(self):
        rot = None
        trans = None
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.lib.getParent(self.root,"Model"),"Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 17):
                if (_g2 == "GeometricRotation"):
                    rot = h3d_col_Point(((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * 3.14159265358979323) / 180),((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * 3.14159265358979323) / 180),((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * 3.14159265358979323) / 180))
                else:
                    pass
            elif (_hx_local_1 == 20):
                if (_g2 == "GeometricTranslation"):
                    trans = h3d_col_Point((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * ((-1 if (self.lib.leftHand) else 1))),hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)),hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)))
                else:
                    pass
            else:
                pass
        if ((rot is None) and ((trans is None))):
            return None
        m = h3d_Matrix()
        if (rot is None):
            m.identity()
        else:
            m.initRotate(rot.x,rot.y,rot.z)
        if (trans is not None):
            m._41 = (m._41 + trans.x)
            m._42 = (m._42 + trans.y)
            m._43 = (m._43 + trans.z)
        return m

hxd_fmt_fbx_Geometry._hx_class = hxd_fmt_fbx_Geometry


class hxd_fmt_fbx_HMDOut(hxd_fmt_fbx_BaseLibrary):
    _hx_class_name = "hxd.fmt.fbx.HMDOut"
    __slots__ = ("d", "dataOut", "filePath", "tmp", "absoluteTexturePath", "optimizeSkin", "floatSkinIndexes")
    _hx_fields = ["d", "dataOut", "filePath", "tmp", "absoluteTexturePath", "optimizeSkin", "floatSkinIndexes"]
    _hx_methods = ["int32tof", "keepJoint", "buildGeom", "addModels", "makeSkin", "makePosition", "makeAnimation", "toHMD"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fmt_fbx_BaseLibrary


    def __init__(self):
        self.absoluteTexturePath = None
        self.filePath = None
        self.dataOut = None
        self.d = None
        self.floatSkinIndexes = False
        self.optimizeSkin = True
        self.tmp = haxe_io_Bytes.alloc(4)
        super().__init__()

    def int32tof(self,v):
        self.tmp.b[0] = ((v & 255) & 255)
        self.tmp.b[1] = (((v >> 8) & 255) & 255)
        self.tmp.b[2] = (((v >> 16) & 255) & 255)
        self.tmp.b[3] = (HxOverrides.rshift(v, 24) & 255)
        return self.tmp.getFloat(0)

    def keepJoint(self,j):
        if (not self.optimizeSkin):
            return True
        tmp = None
        _this = EReg("^Bip00[0-9] ","")
        _this.matchObj = python_lib_Re.search(_this.pattern,j.name)
        if (_this.matchObj is None):
            _this1 = EReg("^Bone[0-9][0-9][0-9]$","")
            _this1.matchObj = python_lib_Re.search(_this1.pattern,j.name)
            tmp = (_this1.matchObj is not None)
        else:
            tmp = True
        if tmp:
            return False
        return True

    def buildGeom(self,geom,skin,dataOut):
        g = hxd_fmt_hmd_Geometry()
        verts = geom.getVertices()
        normals = geom.getNormals()
        uvs = geom.getUVs()
        colors = geom.getColors()
        mats = geom.getMaterials()
        if (colors is not None):
            hasData = False
            _g = 0
            _g1 = colors.values
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v < 0.99):
                    hasData = True
                    break
            if (not hasData):
                colors = None
        g.vertexFormat = [hxd_fmt_hmd_GeometryFormat("position",3)]
        if (normals is not None):
            x = hxd_fmt_hmd_GeometryFormat("normal",3)
            g.vertexFormat.append(x)
        _g11 = 0
        _g2 = len(uvs)
        while (_g11 < _g2):
            i = _g11
            _g11 = (_g11 + 1)
            x1 = hxd_fmt_hmd_GeometryFormat(("uv" + HxOverrides.stringOrNull((("" if ((i == 0)) else ("" + Std.string(((i + 1)))))))),2)
            g.vertexFormat.append(x1)
        if (colors is not None):
            x2 = hxd_fmt_hmd_GeometryFormat("color",3)
            g.vertexFormat.append(x2)
        stride = (((3 + ((0 if ((normals is None)) else 3))) + ((len(uvs) * 2))) + ((0 if ((colors is None)) else 3)))
        if (skin is not None):
            if ((self.bonesPerVertex <= 0) or ((self.bonesPerVertex > 4))):
                raise _HxException("assert")
            x3 = hxd_fmt_hmd_GeometryFormat("weights",python_internal_ArrayImpl._get([1, 2, 3, 4], (self.bonesPerVertex - 1)))
            g.vertexFormat.append(x3)
            x4 = hxd_fmt_hmd_GeometryFormat("indexes",(python_internal_ArrayImpl._get([1, 2, 3, 4], (self.bonesPerVertex - 1)) if (self.floatSkinIndexes) else 9))
            g.vertexFormat.append(x4)
            stride = (stride + ((self.bonesPerVertex + ((self.bonesPerVertex if (self.floatSkinIndexes) else 1)))))
        g.vertexStride = stride
        g.vertexCount = 0
        gm = geom.getGeomMatrix()
        vbuf = list()
        ibufs = []
        if ((skin is not None) and ((skin.splitJoints is not None))):
            _g3 = 0
            _g12 = skin.splitJoints
            while (_g3 < len(_g12)):
                _g3 = (_g3 + 1)
                this1 = list()
                ibufs.append(this1)
        g.bounds = h3d_col_Bounds()
        tmpBuf = [None]*stride
        vertexRemap = list()
        index = geom.getPolygons()
        count = 0
        matPos = 0
        stri = 0
        lookup = haxe_ds_IntMap()
        tmp_z = None
        tmp_y = None
        tmp_x = 0.
        tmp_y = 0.
        tmp_z = 0.
        _g13 = 0
        _g4 = len(index)
        while (_g13 < _g4):
            pos = _g13
            _g13 = (_g13 + 1)
            i1 = (index[pos] if pos >= 0 and pos < len(index) else None)
            count = (count + 1)
            if (i1 >= 0):
                continue
            python_internal_ArrayImpl._set(index, pos, (-i1 - 1))
            start = ((pos - count) + 1)
            _g31 = 0
            _g21 = count
            while (_g31 < _g21):
                n = _g31
                _g31 = (_g31 + 1)
                k = (n + start)
                vidx = (index[k] if k >= 0 and k < len(index) else None)
                p = 0
                x5 = python_internal_ArrayImpl._get(verts, (vidx * 3))
                y = python_internal_ArrayImpl._get(verts, ((vidx * 3) + 1))
                z = python_internal_ArrayImpl._get(verts, ((vidx * 3) + 2))
                if (gm is not None):
                    tmp_x = x5
                    tmp_y = y
                    tmp_z = z
                    py = ((((tmp_x * gm._12) + ((tmp_y * gm._22))) + ((tmp_z * gm._32))) + gm._42)
                    pz = ((((tmp_x * gm._13) + ((tmp_y * gm._23))) + ((tmp_z * gm._33))) + gm._43)
                    tmp_x = ((((tmp_x * gm._11) + ((tmp_y * gm._21))) + ((tmp_z * gm._31))) + gm._41)
                    tmp_y = py
                    tmp_z = pz
                    x5 = tmp_x
                    y = tmp_y
                    z = tmp_z
                p = 1
                tmpBuf[0] = x5
                p = 2
                tmpBuf[1] = y
                p = 3
                tmpBuf[2] = z
                _this = g.bounds
                if (x5 < _this.xMin):
                    _this.xMin = x5
                if (x5 > _this.xMax):
                    _this.xMax = x5
                if (y < _this.yMin):
                    _this.yMin = y
                if (y > _this.yMax):
                    _this.yMax = y
                if (z < _this.zMin):
                    _this.zMin = z
                if (z > _this.zMax):
                    _this.zMax = z
                if (normals is not None):
                    nx = python_internal_ArrayImpl._get(normals, (k * 3))
                    ny = python_internal_ArrayImpl._get(normals, ((k * 3) + 1))
                    nz = python_internal_ArrayImpl._get(normals, ((k * 3) + 2))
                    p = 4
                    tmpBuf[3] = nx
                    p = 5
                    tmpBuf[4] = ny
                    p = 6
                    tmpBuf[5] = nz
                _g41 = 0
                while (_g41 < len(uvs)):
                    tuvs = (uvs[_g41] if _g41 >= 0 and _g41 < len(uvs) else None)
                    _g41 = (_g41 + 1)
                    iuv = (tuvs.index[k] if k >= 0 and k < len(tuvs.index) else None)
                    index1 = p
                    p = (p + 1)
                    val = python_internal_ArrayImpl._get(tuvs.values, (iuv * 2))
                    tmpBuf[index1] = val
                    index2 = p
                    p = (p + 1)
                    val1 = (1 - python_internal_ArrayImpl._get(tuvs.values, ((iuv * 2) + 1)))
                    tmpBuf[index2] = val1
                if (colors is not None):
                    icol = (colors.index[k] if k >= 0 and k < len(colors.index) else None)
                    index3 = p
                    p = (p + 1)
                    val2 = python_internal_ArrayImpl._get(colors.values, (icol * 4))
                    tmpBuf[index3] = val2
                    index4 = p
                    p = (p + 1)
                    val3 = python_internal_ArrayImpl._get(colors.values, ((icol * 4) + 1))
                    tmpBuf[index4] = val3
                    index5 = p
                    p = (p + 1)
                    val4 = python_internal_ArrayImpl._get(colors.values, ((icol * 4) + 2))
                    tmpBuf[index5] = val4
                if (skin is not None):
                    k1 = (vidx * skin.bonesPerVertex)
                    idx = 0
                    _g5 = 0
                    _g42 = skin.bonesPerVertex
                    while (_g5 < _g42):
                        i2 = _g5
                        _g5 = (_g5 + 1)
                        index6 = p
                        p = (p + 1)
                        val5 = skin.vertexWeights[(k1 + i2)]
                        tmpBuf[index6] = val5
                        idx = ((skin.vertexJoints[(k1 + i2)] << ((8 * i2))) | idx)
                    if self.floatSkinIndexes:
                        _g51 = 0
                        _g43 = skin.bonesPerVertex
                        while (_g51 < _g43):
                            i3 = _g51
                            _g51 = (_g51 + 1)
                            index7 = p
                            p = (p + 1)
                            val6 = (skin.vertexJoints[(k1 + i3)] * 3)
                            tmpBuf[index7] = val6
                    else:
                        index8 = p
                        p = (p + 1)
                        val7 = self.int32tof(idx)
                        tmpBuf[index8] = val7
                total = 0.
                _g52 = 0
                _g44 = stride
                while (_g52 < _g44):
                    i4 = _g52
                    _g52 = (_g52 + 1)
                    total = (total + tmpBuf[i4])
                itotal = None
                try:
                    itotal = int(HxOverrides.modf((total * 100), 268435455))
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    itotal = None
                itotal1 = itotal
                found = None
                vids = lookup.h.get(itotal1,None)
                if (vids is None):
                    vids = []
                    lookup.set(itotal1,vids)
                _g45 = 0
                while (_g45 < len(vids)):
                    vid = (vids[_g45] if _g45 >= 0 and _g45 < len(vids) else None)
                    _g45 = (_g45 + 1)
                    same = True
                    p1 = (vid * stride)
                    _g6 = 0
                    _g53 = stride
                    while (_g6 < _g53):
                        i5 = _g6
                        _g6 = (_g6 + 1)
                        key = p1
                        p1 = (p1 + 1)
                        if (python_internal_ArrayImpl._get(vbuf, key) != tmpBuf[i5]):
                            same = False
                            break
                    if same:
                        found = vid
                        break
                if (found is None):
                    found = g.vertexCount
                    g.vertexCount = (g.vertexCount + 1)
                    _g54 = 0
                    _g46 = stride
                    while (_g54 < _g46):
                        i6 = _g54
                        _g54 = (_g54 + 1)
                        v1 = tmpBuf[i6]
                        vbuf.append(v1)
                    vids.append(found)
                vertexRemap.append(found)
            if ((skin is not None) and ((skin.splitJoints is not None))):
                _g32 = 0
                _g22 = (count - 2)
                while (_g32 < _g22):
                    n1 = _g32
                    _g32 = (_g32 + 1)
                    index9 = stri
                    stri = (stri + 1)
                    idx1 = python_internal_ArrayImpl._get(ibufs, skin.triangleGroups[index9])
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, (start + n1)))
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, ((start + count) - 1)))
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, ((start + n1) + 1)))
            else:
                mid = None
                if (mats is None):
                    mid = 0
                else:
                    mid = (mats[matPos] if matPos >= 0 and matPos < len(mats) else None)
                    if (len(mats) > 1):
                        matPos = (matPos + 1)
                idx2 = (ibufs[mid] if mid >= 0 and mid < len(ibufs) else None)
                if (idx2 is None):
                    idx2 = list()
                    python_internal_ArrayImpl._set(ibufs, mid, idx2)
                _g33 = 0
                _g23 = (count - 2)
                while (_g33 < _g23):
                    n2 = _g33
                    _g33 = (_g33 + 1)
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, (start + n2)))
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, ((start + count) - 1)))
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, ((start + n2) + 1)))
            python_internal_ArrayImpl._set(index, pos, i1)
            count = 0
        g.vertexPosition = len(dataOut.b.b)
        _g14 = 0
        _g7 = len(vbuf)
        while (_g14 < _g7):
            i7 = _g14
            _g14 = (_g14 + 1)
            f = python_internal_ArrayImpl._get(vbuf, i7)
            self.dataOut.writeFloat((0 if ((f == 0)) else f))
        g.indexPosition = len(dataOut.b.b)
        g.indexCounts = []
        matMap = []
        matCount = 0
        _g8 = 0
        while (_g8 < len(ibufs)):
            idx3 = (ibufs[_g8] if _g8 >= 0 and _g8 < len(ibufs) else None)
            _g8 = (_g8 + 1)
            if (idx3 is None):
                matCount = (matCount + 1)
                continue
            x6 = matCount
            matCount = (matCount + 1)
            matMap.append(x6)
            x7 = len(idx3)
            g.indexCounts.append(x7)
            _g15 = 0
            while (_g15 < len(idx3)):
                i8 = python_internal_ArrayImpl._get(idx3, _g15)
                _g15 = (_g15 + 1)
                dataOut.writeUInt16(i8)
        if ((skin is not None) and ((skin.splitJoints is not None))):
            matMap = None
        return _hx_AnonObject({'g': g, 'materials': matMap})

    def addModels(self,includeGeometry):
        _gthis = self
        root = self.buildHierarchy().root
        objects = []
        joints = []
        skins = []
        foundSkin = None
        indexRec = None
        def _hx_local_2(t):
            if t.isJoint:
                joints.append(t)
            else:
                isSkin = False
                if (foundSkin is None):
                    _g = 0
                    _g1 = t.childs
                    while (_g < len(_g1)):
                        c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                        _g = (_g + 1)
                        if c.isJoint:
                            isSkin = True
                            break
                else:
                    isSkin = (Lambda.indexOf(foundSkin,t) >= 0)
                if isSkin:
                    skins.append(t)
                else:
                    objects.append(t)
            _g2 = 0
            _g11 = t.childs
            while (_g2 < len(_g11)):
                c1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                indexRec(c1)
        indexRec = _hx_local_2
        indexRec1 = indexRec
        indexRec1(root)
        _g3 = 0
        while (_g3 < len(joints)):
            o = (joints[_g3] if _g3 >= 0 and _g3 < len(joints) else None)
            _g3 = (_g3 + 1)
            if o.isMesh:
                raise _HxException("assert")
            j = h3d_anim_Joint()
            self.getDefaultMatrixes(o.model)
            j.index = hxd_fmt_fbx_FbxTools.getId(o.model)
            j.name = hxd_fmt_fbx_FbxTools.getName(o.model)
            o.joint = j
            if (o.parent is not None):
                j.parent = o.parent.joint
                if o.parent.isJoint:
                    o.parent.joint.subs.append(j)
        foundSkin = []
        _g4 = 0
        while (_g4 < len(skins)):
            o1 = (skins[_g4] if _g4 >= 0 and _g4 < len(skins) else None)
            _g4 = (_g4 + 1)
            loopRec = [None]
            def _hx_local_7(loopRec1):
                def _hx_local_5(o2):
                    _g12 = 0
                    _g21 = o2.childs
                    while (_g12 < len(_g21)):
                        j1 = (_g21[_g12] if _g12 >= 0 and _g12 < len(_g21) else None)
                        _g12 = (_g12 + 1)
                        if (not j1.isJoint):
                            continue
                        s = _gthis.getParent(j1.model,"Deformer",True)
                        if (s is not None):
                            return s
                        s = (loopRec1[0] if 0 < len(loopRec1) else None)(j1)
                        if (s is not None):
                            return s
                    return None
                return _hx_local_5
            tmp = _hx_local_7(loopRec)
            python_internal_ArrayImpl._set(loopRec, 0, tmp)
            subDef = (loopRec[0] if 0 < len(loopRec) else None)(o1)
            if (subDef is None):
                continue
            geoms = self.getParents(self.getParent(subDef,"Deformer"),"Geometry")
            if (len(geoms) == 0):
                continue
            if (len(geoms) > 1):
                raise _HxException("Single skin applied to multiple geometries not supported")
            models = self.getParents((geoms[0] if 0 < len(geoms) else None),"Model")
            if (len(models) == 0):
                continue
            if (len(models) > 1):
                raise _HxException("Single skin applied to multiple models not supported")
            m = (models[0] if 0 < len(models) else None)
            _g13 = 0
            while (_g13 < len(objects)):
                o21 = (objects[_g13] if _g13 >= 0 and _g13 < len(objects) else None)
                _g13 = (_g13 + 1)
                if (o21.model == m):
                    foundSkin.append(o1)
                    o21.skin = o1
                    if (o1.model is None):
                        o1.model = m
                    self.ignoreMissingObject(hxd_fmt_fbx_FbxTools.getName(m))
                    p = o1.parent
                    if (p != o21):
                        python_internal_ArrayImpl.remove(o21.parent.childs,o21)
                        o21.parent = p
                        if (p is not None):
                            p.childs.append(o21)
                        else:
                            root = o21
                    if (p is not None):
                        python_internal_ArrayImpl.remove(p.childs,o1)
                    _g22 = 0
                    _g31 = list(o1.childs)
                    while (_g22 < len(_g31)):
                        c2 = (_g31[_g22] if _g22 >= 0 and _g22 < len(_g31) else None)
                        _g22 = (_g22 + 1)
                        if (not c2.isJoint):
                            python_internal_ArrayImpl.remove(o1.childs,c2)
                            o21.childs.append(c2)
                            c2.parent = o21
                    break
        if (not includeGeometry):
            return
        objects = []
        if ((len(root.childs) <= 1) and ((root.model is None))):
            root = (root.childs[0] if 0 < len(root.childs) else None)
            root.parent = None
        if (root is not None):
            indexRec1(root)
        hskins = haxe_ds_IntMap()
        tmpGeom = haxe_ds_IntMap()
        _g5 = 0
        _g14 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g5 < len(_g14)):
            g = [(_g14[_g5] if _g5 >= 0 and _g5 < len(_g14) else None)]
            _g5 = (_g5 + 1)
            def _hx_local_12():
                def _hx_local_11(_):
                    pass
                return _hx_local_11
            def _hx_local_14(g1):
                def _hx_local_13():
                    x = (len(hxd_fmt_fbx_Geometry(_gthis,(g1[0] if 0 < len(g1) else None)).getVertices()) / 3)
                    try:
                        return int(x)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e = _hx_e1
                        return None
                return _hx_local_13
            tmpGeom.set(hxd_fmt_fbx_FbxTools.getId((g[0] if 0 < len(g) else None)),_hx_AnonObject({'setSkin': _hx_local_12(), 'vertexCount': _hx_local_14(g)}))
        hgeom = haxe_ds_IntMap()
        hmat = haxe_ds_IntMap()
        index = 0
        _g6 = 0
        while (_g6 < len(objects)):
            o3 = (objects[_g6] if _g6 >= 0 and _g6 < len(objects) else None)
            _g6 = (_g6 + 1)
            tmp1 = index
            index = (index + 1)
            o3.index = tmp1
            model = hxd_fmt_hmd_Model()
            ref = (o3 if ((o3.skin is None)) else o3.skin)
            model.name = (None if ((o3.model is None)) else hxd_fmt_fbx_FbxTools.getName(o3.model))
            model.parent = (-1 if (((o3.parent is None) or o3.parent.isJoint)) else o3.parent.index)
            model.follow = (hxd_fmt_fbx_FbxTools.getName(o3.parent.model) if (((o3.parent is not None) and o3.parent.isJoint)) else None)
            m1 = (hxd_fmt_fbx_DefaultMatrixes() if ((ref.model is None)) else self.getDefaultMatrixes(ref.model))
            p1 = hxd_fmt_hmd_Position()
            p1.x = (0 if ((m1.trans is None)) else -m1.trans.x)
            p1.y = (0 if ((m1.trans is None)) else m1.trans.y)
            p1.z = (0 if ((m1.trans is None)) else m1.trans.z)
            p1.sx = (1 if ((m1.scale is None)) else m1.scale.x)
            p1.sy = (1 if ((m1.scale is None)) else m1.scale.y)
            p1.sz = (1 if ((m1.scale is None)) else m1.scale.z)
            if ((o3.model is not None) and ((hxd_fmt_fbx_FbxTools.getType(o3.model) == "Camera"))):
                fov = 45.
                ratio = 1.7777777777777777
                _g15 = 0
                _g23 = hxd_fmt_fbx_FbxTools.getAll(self.getChild(o3.model,"NodeAttribute"),"Properties70.P")
                while (_g15 < len(_g23)):
                    p2 = (_g23[_g15] if _g15 >= 0 and _g15 < len(_g23) else None)
                    _g15 = (_g15 + 1)
                    _g32 = hxd_fmt_fbx_FbxTools.toString((p2.props[0] if 0 < len(p2.props) else None))
                    _hx_local_17 = len(_g32)
                    if (_hx_local_17 == 15):
                        if (_g32 == "FilmAspectRatio"):
                            ratio = hxd_fmt_fbx_FbxTools.toFloat((p2.props[4] if 4 < len(p2.props) else None))
                        else:
                            pass
                    elif (_hx_local_17 == 11):
                        if (_g32 == "FieldOfView"):
                            fov = hxd_fmt_fbx_FbxTools.toFloat((p2.props[4] if 4 < len(p2.props) else None))
                        else:
                            pass
                    else:
                        pass
                fovY = (((2 * Math.atan((Math.tan((((fov * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323)
                if (model.props is None):
                    model.props = []
                model.props.append(hxd_fmt_hmd_Property.CameraFOVY(fovY))
            q = m1.toQuaternion(True)
            q.normalize()
            if (q.w < 0):
                q.x = -q.x
                q.y = -q.y
                q.z = -q.z
                q.w = -q.w
            p1.qx = q.x
            p1.qy = q.y
            p1.qz = q.z
            model.position = p1
            model.geometry = -1
            self.d.models.append(model)
            if (not o3.isMesh):
                continue
            mids = []
            _g16 = 0
            _g24 = self.getChilds(o3.model,"Material")
            while (_g16 < len(_g24)):
                m2 = (_g24[_g16] if _g16 >= 0 and _g16 < len(_g24) else None)
                _g16 = (_g16 + 1)
                key = hxd_fmt_fbx_FbxTools.getId(m2)
                mid = hmat.h.get(key,None)
                if (mid is not None):
                    mids.append(mid)
                    continue
                hasHeapsProps = False
                mat = hxd_fmt_hmd_Material()
                mid = len(self.d.materials)
                mids.append(mid)
                hmat.set(hxd_fmt_fbx_FbxTools.getId(m2),mid)
                self.d.materials.append(mat)
                mat.name = hxd_fmt_fbx_FbxTools.getName(m2)
                mat.culling = h3d_mat_Face.Back
                mat.blendMode = None
                mat.flags = hxd_fmt_hmd_Material.DEFAULT_FLAGS
                _g33 = 0
                _g41 = hxd_fmt_fbx_FbxTools.getAll(m2,"Properties70.P")
                while (_g33 < len(_g41)):
                    p3 = (_g41[_g33] if _g33 >= 0 and _g33 < len(_g41) else None)
                    _g33 = (_g33 + 1)
                    pval = (p3.props[4] if 4 < len(p3.props) else None)
                    _g51 = hxd_fmt_fbx_FbxTools.toString((p3.props[0] if 0 < len(p3.props) else None))
                    if (_g51 == "Opacity"):
                        v = hxd_fmt_fbx_FbxTools.toFloat(pval)
                        if (((v < 1) and ((v > 0.98))) and ((mat.blendMode is None))):
                            mat.blendMode = h2d_BlendMode.Add
                    elif StringTools.startsWith(_g51,"3dsMax|heaps|_"):
                        hasHeapsProps = True
                        _g52 = HxString.substr(_g51,14,None)
                        _hx_local_20 = len(_g52)
                        if (_hx_local_20 == 18):
                            if (_g52 == "killAlphaThreshold"):
                                if (mat.killAlpha is not None):
                                    mat.killAlpha = hxd_fmt_fbx_FbxTools.toFloat(pval)
                            else:
                                raise _HxException(("Unknown heaps property " + ("null" if _g52 is None else _g52)))
                        elif (_hx_local_20 == 9):
                            if (_g52 == "killAlpha"):
                                if (hxd_fmt_fbx_FbxTools.toInt(pval) == 1):
                                    mat.killAlpha = 1
                            else:
                                raise _HxException(("Unknown heaps property " + ("null" if _g52 is None else _g52)))
                        elif (_hx_local_20 == 5):
                            if (_g52 == "blend"):
                                mat.blendMode = python_internal_ArrayImpl._get([None, h2d_BlendMode._hx_None, h2d_BlendMode.Alpha, h2d_BlendMode.Add, h2d_BlendMode.SoftAdd], (hxd_fmt_fbx_FbxTools.toInt(pval) - 1))
                            elif (_g52 == "decal"):
                                if (hxd_fmt_fbx_FbxTools.toInt(pval) == 1):
                                    mat.flags = (mat.flags | ((1 << hxd_fmt_hmd_MaterialFlag.IsVolumeDecal.index)))
                            else:
                                raise _HxException(("Unknown heaps property " + ("null" if _g52 is None else _g52)))
                        elif (_hx_local_20 == 4):
                            if (_g52 == "wrap"):
                                if (hxd_fmt_fbx_FbxTools.toInt(pval) == 1):
                                    mat.flags = (mat.flags | ((1 << hxd_fmt_hmd_MaterialFlag.TextureWrap.index)))
                            else:
                                raise _HxException(("Unknown heaps property " + ("null" if _g52 is None else _g52)))
                        elif (_hx_local_20 == 7):
                            if (_g52 == "shadows"):
                                _g53 = hxd_fmt_fbx_FbxTools.toInt(pval)
                                if (_g53 == 2):
                                    def _hx_local_24():
                                        mat.flags = (mat.flags & ((-1 - ((1 << hxd_fmt_hmd_MaterialFlag.CastShadows.index)))))
                                        return mat.flags
                                    mat.flags = ((_hx_local_24()) & ((-1 - ((1 << hxd_fmt_hmd_MaterialFlag.ReceiveShadows.index)))))
                                elif (_g53 == 3):
                                    mat.flags = (mat.flags & ((-1 - ((1 << hxd_fmt_hmd_MaterialFlag.CastShadows.index)))))
                                elif (_g53 == 4):
                                    mat.flags = (mat.flags & ((-1 - ((1 << hxd_fmt_hmd_MaterialFlag.ReceiveShadows.index)))))
                                else:
                                    pass
                            else:
                                raise _HxException(("Unknown heaps property " + ("null" if _g52 is None else _g52)))
                        elif (_hx_local_20 == 8):
                            if (_g52 == "lighting"):
                                if (hxd_fmt_fbx_FbxTools.toInt(pval) == 0):
                                    mat.flags = (mat.flags & ((-1 - ((1 << hxd_fmt_hmd_MaterialFlag.HasLighting.index)))))
                            elif (_g52 == "twoSided"):
                                if (hxd_fmt_fbx_FbxTools.toInt(pval) == 1):
                                    mat.culling = h3d_mat_Face._hx_None
                            else:
                                raise _HxException(("Unknown heaps property " + ("null" if _g52 is None else _g52)))
                        else:
                            raise _HxException(("Unknown heaps property " + ("null" if _g52 is None else _g52)))
                texture = self.getSpecChild(m2,"DiffuseColor")
                if (texture is not None):
                    path = hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(texture,"FileName").props, 0))
                    if (path != ""):
                        _this = path.split("\\")
                        path = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
                        if (not self.absoluteTexturePath):
                            if ((self.filePath is not None) and StringTools.startsWith(path.lower(),self.filePath)):
                                path = HxString.substr(path,len(self.filePath),None)
                            else:
                                k = path.split("/res/")
                                if (len(k) > 1):
                                    if (len(k) != 0):
                                        k.pop(0)
                                    path = "/res/".join([python_Boot.toString1(x1,'') for x1 in k])
                        mat.diffuseTexture = path
                transp = self.getSpecChild(m2,"TransparentColor")
                if (transp is not None):
                    path1 = hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(transp,"FileName").props, 0))
                    if (path1 != ""):
                        path1 = path1.lower()
                        _this1 = path1.split(".")
                        ext = (None if ((len(_this1) == 0)) else _this1.pop())
                        if ((texture is not None) and ((path1 == hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(texture,"FileName").props, 0)).lower()))):
                            if (((mat.blendMode is None) and ((ext != "jpg"))) and ((ext != "jpeg"))):
                                mat.blendMode = h2d_BlendMode.Alpha
                        else:
                            raise _HxException("TODO : alpha texture")
                if hasHeapsProps:
                    if (mat.props is None):
                        mat.props = []
                    mat.props.append(hxd_fmt_hmd_Property.HasMaterialFlags)
                if (mat.blendMode is None):
                    mat.blendMode = h2d_BlendMode._hx_None
            g2 = self.getChild(o3.model,"Geometry")
            skin = None
            if (o3.skin is not None):
                rootJoints = []
                _g17 = 0
                _g25 = o3.skin.childs
                while (_g17 < len(_g25)):
                    c3 = (_g25[_g17] if _g17 >= 0 and _g17 < len(_g25) else None)
                    _g17 = (_g17 + 1)
                    if c3.isJoint:
                        x1 = c3.joint
                        rootJoints.append(x1)
                skin = self.createSkin(hskins,tmpGeom,rootJoints,self.bonesPerVertex)
                if (len(skin.boundJoints) > self.maxBonesPerSkin):
                    g3 = hxd_fmt_fbx_Geometry(self,g2)
                    idx = g3.getIndexes()
                    tmp2 = self.maxBonesPerSkin
                    _g18 = []
                    _g26 = 0
                    _g34 = idx.idx
                    while (_g26 < len(_g34)):
                        i = (_g34[_g26] if _g26 >= 0 and _g26 < len(_g34) else None)
                        _g26 = (_g26 + 1)
                        x2 = (idx.vidx[i] if i >= 0 and i < len(idx.vidx) else None)
                        _g18.append(x2)
                    skin.split(tmp2,_g18,(g3.getMaterialByTriangle() if ((len(mids) > 1)) else None))
                model.skin = self.makeSkin(skin,o3.skin)
            key1 = hxd_fmt_fbx_FbxTools.getId(g2)
            gdata = hgeom.h.get(key1,None)
            if (gdata is None):
                geom = self.buildGeom(hxd_fmt_fbx_Geometry(self,g2),skin,self.dataOut)
                gdata = _hx_AnonObject({'gid': len(self.d.geometries), 'materials': geom.materials})
                x3 = geom.g
                self.d.geometries.append(x3)
                hgeom.set(hxd_fmt_fbx_FbxTools.getId(g2),gdata)
            model.geometry = gdata.gid
            if (len(mids) == 0):
                mat1 = hxd_fmt_hmd_Material()
                mat1.blendMode = h2d_BlendMode._hx_None
                mat1.culling = h3d_mat_Face.Back
                mat1.name = "default"
                mid1 = len(self.d.materials)
                self.d.materials.append(mat1)
                mids = [mid1]
            if (gdata.materials is None):
                model.materials = mids
            else:
                _g19 = []
                _g27 = 0
                _g35 = gdata.materials
                while (_g27 < len(_g35)):
                    id = (_g35[_g27] if _g27 >= 0 and _g27 < len(_g35) else None)
                    _g27 = (_g27 + 1)
                    _g19.append((mids[id] if id >= 0 and id < len(mids) else None))
                model.materials = _g19

    def makeSkin(self,skin,obj):
        s = hxd_fmt_hmd_Skin()
        s.name = hxd_fmt_fbx_FbxTools.getName(obj.model)
        s.joints = []
        _g = 0
        _g1 = skin.allJoints
        while (_g < len(_g1)):
            jo = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            j = hxd_fmt_hmd_SkinJoint()
            j.name = jo.name
            j.parent = (-1 if ((jo.parent is None)) else jo.parent.index)
            j.bind = jo.bindIndex
            j.position = self.makePosition(jo.defMat)
            if (jo.transPos is not None):
                j.transpos = self.makePosition(jo.transPos)
                if (((j.transpos.sx != 1) or ((j.transpos.sy != 1))) or ((j.transpos.sz != 1))):
                    tmp = jo.transPos.clone()
                    tmp.transpose()
                    v = h3d_Vector()
                    f = (((tmp._11 * tmp._11) + ((tmp._12 * tmp._12))) + ((tmp._13 * tmp._13)))
                    v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
                    f1 = (((tmp._21 * tmp._21) + ((tmp._22 * tmp._22))) + ((tmp._23 * tmp._23)))
                    v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
                    f2 = (((tmp._31 * tmp._31) + ((tmp._32 * tmp._32))) + ((tmp._33 * tmp._33)))
                    v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
                    if ((((tmp._11 * (((tmp._22 * tmp._33) - ((tmp._23 * tmp._32))))) + ((tmp._12 * (((tmp._23 * tmp._31) - ((tmp._21 * tmp._33))))))) + ((tmp._13 * (((tmp._21 * tmp._32) - ((tmp._22 * tmp._31))))))) < 0):
                        v.x = (v.x * -1)
                        v.y = (v.y * -1)
                        v.z = (v.z * -1)
                    tmp.prependScale((1 / v.x),(1 / v.y),(1 / v.z))
                    tmp.transpose()
                    j.transpos = self.makePosition(tmp)
                    j.transpos.sx = self.round(v.x)
                    j.transpos.sy = self.round(v.y)
                    j.transpos.sz = self.round(v.z)
            s.joints.append(j)
        if (skin.splitJoints is not None):
            s.split = []
            _g2 = 0
            _g11 = skin.splitJoints
            while (_g2 < len(_g11)):
                sp = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                ss = hxd_fmt_hmd_SkinSplit()
                ss.materialIndex = sp.material
                _g21 = []
                _g3 = 0
                _g4 = sp.joints
                while (_g3 < len(_g4)):
                    j1 = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    x = j1.index
                    _g21.append(x)
                ss.joints = _g21
                s.split.append(ss)
        return s

    def makePosition(self,m):
        p = hxd_fmt_hmd_Position()
        v = h3d_Vector()
        f = (((m._11 * m._11) + ((m._12 * m._12))) + ((m._13 * m._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f1 = (((m._21 * m._21) + ((m._22 * m._22))) + ((m._23 * m._23)))
        v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f2 = (((m._31 * m._31) + ((m._32 * m._32))) + ((m._33 * m._33)))
        v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
        if ((((m._11 * (((m._22 * m._33) - ((m._23 * m._32))))) + ((m._12 * (((m._23 * m._31) - ((m._21 * m._33))))))) + ((m._13 * (((m._21 * m._32) - ((m._22 * m._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        q = h3d_Quat()
        q.initRotateMatrix(m)
        q.normalize()
        if (q.w < 0):
            q.x = -q.x
            q.y = -q.y
            q.z = -q.z
            q.w = -q.w
        p.sx = self.round(v.x)
        p.sy = self.round(v.y)
        p.sz = self.round(v.z)
        p.qx = self.round(q.x)
        p.qy = self.round(q.y)
        p.qz = self.round(q.z)
        p.x = self.round(m._41)
        p.y = self.round(m._42)
        p.z = self.round(m._43)
        return p

    def makeAnimation(self,anim):
        a = hxd_fmt_hmd_Animation()
        a.name = anim.name
        a.loop = True
        a.speed = 1
        a.sampling = anim.sampling
        a.frames = anim.frameCount
        a.objects = []
        a.dataPosition = len(self.dataOut.b.b)
        if (self.animationEvents is not None):
            _g = []
            _g1 = 0
            _g2 = self.animationEvents
            while (_g1 < len(_g2)):
                a1 = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                e = hxd_fmt_hmd_AnimationEvent()
                e.frame = a1.frame
                e.data = a1.data
                _g.append(e)
            a.events = _g
        objects = anim.objects
        def _hx_local_1(o1,o2):
            return Reflect.compare(o1.objectName,o2.objectName)
        objects.sort(key= python_lib_Functools.cmp_to_key(_hx_local_1))
        _g3 = 0
        while (_g3 < len(objects)):
            obj = (objects[_g3] if _g3 >= 0 and _g3 < len(objects) else None)
            _g3 = (_g3 + 1)
            o = hxd_fmt_hmd_AnimationObject()
            o.name = obj.objectName
            o.flags = 0
            o.props = []
            if (obj.frames is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))
                if obj.hasRotation:
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))
                if obj.hasScale:
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))
                if (len(obj.frames) == 1):
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.SinglePosition.index)))
                _g11 = 0
                _g21 = obj.frames
                while (_g11 < len(_g21)):
                    f = _g21[_g11]
                    _g11 = (_g11 + 1)
                    if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0):
                        f1 = f.tx
                        self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                        f2 = f.ty
                        self.dataOut.writeFloat((0 if ((f2 == 0)) else f2))
                        f3 = f.tz
                        self.dataOut.writeFloat((0 if ((f3 == 0)) else f3))
                    if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0):
                        f4 = ((((f.qx * f.qx) + ((f.qy * f.qy))) + ((f.qz * f.qz))) + ((f.qw * f.qw)))
                        ql = (Math.NaN if ((f4 < 0)) else python_lib_Math.sqrt(f4))
                        if (f.qw < 0):
                            ql = -ql
                        f5 = self.round((f.qx / ql))
                        self.dataOut.writeFloat((0 if ((f5 == 0)) else f5))
                        f6 = self.round((f.qy / ql))
                        self.dataOut.writeFloat((0 if ((f6 == 0)) else f6))
                        f7 = self.round((f.qz / ql))
                        self.dataOut.writeFloat((0 if ((f7 == 0)) else f7))
                    if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0):
                        f8 = f.sx
                        self.dataOut.writeFloat((0 if ((f8 == 0)) else f8))
                        f9 = f.sy
                        self.dataOut.writeFloat((0 if ((f9 == 0)) else f9))
                        f10 = f.sz
                        self.dataOut.writeFloat((0 if ((f10 == 0)) else f10))
            if (obj.uvs is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))
                _g12 = 0
                _g22 = obj.uvs
                while (_g12 < len(_g22)):
                    f11 = _g22[_g12]
                    _g12 = (_g12 + 1)
                    self.dataOut.writeFloat((0 if ((f11 == 0)) else f11))
            if (obj.alphas is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))
                _g13 = 0
                _g23 = obj.alphas
                while (_g13 < len(_g23)):
                    f12 = _g23[_g13]
                    _g13 = (_g13 + 1)
                    self.dataOut.writeFloat((0 if ((f12 == 0)) else f12))
            if (obj.propValues is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))
                x = obj.propName
                o.props.append(x)
                _g14 = 0
                _g24 = obj.propValues
                while (_g14 < len(_g24)):
                    f13 = _g24[_g14]
                    _g14 = (_g14 + 1)
                    self.dataOut.writeFloat((0 if ((f13 == 0)) else f13))
            a.objects.append(o)
        return a

    def toHMD(self,filePath,includeGeometry):
        if (not includeGeometry):
            self.optimizeSkin = False
        self.leftHandConvert()
        self.autoMerge()
        if (filePath is not None):
            _this = filePath.split("\\")
            filePath = "/".join([python_Boot.toString1(x1,'') for x1 in _this]).lower()
            if (not StringTools.endsWith(filePath,"/")):
                filePath = (("null" if filePath is None else filePath) + "/")
        self.filePath = filePath
        self.d = hxd_fmt_hmd_Data()
        self.d.version = 2
        self.d.geometries = []
        self.d.materials = []
        self.d.models = []
        self.d.animations = []
        self.dataOut = haxe_io_BytesOutput()
        self.addModels(includeGeometry)
        anim = self.loadAnimation()
        if (anim is not None):
            _this1 = self.d.animations
            x = self.makeAnimation(anim)
            _this1.append(x)
        self.d.data = self.dataOut.getBytes()
        return self.d

hxd_fmt_fbx_HMDOut._hx_class = hxd_fmt_fbx_HMDOut

class hxd_fmt_fbx__Parser_Token(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.fbx._Parser.Token"
    _hx_constructs = ["TIdent", "TNode", "TInt", "TFloat", "TString", "TLength", "TBraceOpen", "TBraceClose", "TColon", "TEof"]

    @staticmethod
    def TIdent(s):
        return hxd_fmt_fbx__Parser_Token("TIdent", 0, [s])

    @staticmethod
    def TNode(s):
        return hxd_fmt_fbx__Parser_Token("TNode", 1, [s])

    @staticmethod
    def TInt(s):
        return hxd_fmt_fbx__Parser_Token("TInt", 2, [s])

    @staticmethod
    def TFloat(s):
        return hxd_fmt_fbx__Parser_Token("TFloat", 3, [s])

    @staticmethod
    def TString(s):
        return hxd_fmt_fbx__Parser_Token("TString", 4, [s])

    @staticmethod
    def TLength(v):
        return hxd_fmt_fbx__Parser_Token("TLength", 5, [v])
hxd_fmt_fbx__Parser_Token.TBraceOpen = hxd_fmt_fbx__Parser_Token("TBraceOpen", 6, list())
hxd_fmt_fbx__Parser_Token.TBraceClose = hxd_fmt_fbx__Parser_Token("TBraceClose", 7, list())
hxd_fmt_fbx__Parser_Token.TColon = hxd_fmt_fbx__Parser_Token("TColon", 8, list())
hxd_fmt_fbx__Parser_Token.TEof = hxd_fmt_fbx__Parser_Token("TEof", 9, list())
hxd_fmt_fbx__Parser_Token._hx_class = hxd_fmt_fbx__Parser_Token


class hxd_fmt_fbx_Parser:
    _hx_class_name = "hxd.fmt.fbx.Parser"
    __slots__ = ("line", "buf", "pos", "token")
    _hx_fields = ["line", "buf", "pos", "token"]
    _hx_methods = ["parseText", "parseNodes", "parseNode", "except", "peek", "next", "error", "unexpected", "tokenStr", "nextToken"]
    _hx_statics = ["parse"]

    def __init__(self):
        self.token = None
        self.pos = None
        self.buf = None
        self.line = None

    def parseText(self,_hx_str):
        self.buf = _hx_str
        self.pos = 0
        self.line = 1
        self.token = None
        return _hx_AnonObject({'name': "Root", 'props': [hxd_fmt_fbx_FbxProp.PInt(0), hxd_fmt_fbx_FbxProp.PString("Root"), hxd_fmt_fbx_FbxProp.PString("Root")], 'childs': self.parseNodes()})

    def parseNodes(self):
        nodes = []
        while True:
            _g = self.peek().index
            if ((_g == 9) or ((_g == 7))):
                return nodes
            else:
                pass
            x = self.parseNode()
            nodes.append(x)

    def parseNode(self):
        t = self.next()
        name = (t.params[0] if ((t.index == 1)) else self.unexpected(t))
        props = []
        childs = None
        while True:
            t = self.next()
            t1 = t.index
            if (t1 == 0):
                props.append(hxd_fmt_fbx_FbxProp.PIdent(t.params[0]))
            elif (((t1 == 7) or ((t1 == 6))) or ((t1 == 1))):
                self.token = t
            elif (t1 == 2):
                x = hxd_fmt_fbx_FbxProp.PInt(Std.parseInt(t.params[0]))
                props.append(x)
            elif (t1 == 3):
                x1 = hxd_fmt_fbx_FbxProp.PFloat(Std.parseFloat(t.params[0]))
                props.append(x1)
            elif (t1 == 4):
                props.append(hxd_fmt_fbx_FbxProp.PString(t.params[0]))
            elif (t1 == 5):
                v = t.params[0]
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceOpen)
                self._hx_except(hxd_fmt_fbx__Parser_Token.TNode("a"))
                ints = []
                floats = None
                i = 0
                while (i < v):
                    t = self.next()
                    t2 = t.index
                    if (t2 == 2):
                        s = t.params[0]
                        i = (i + 1)
                        if (floats is None):
                            x2 = Std.parseInt(s)
                            ints.append(x2)
                        else:
                            x3 = Std.parseInt(s)
                            floats.append(x3)
                    elif (t2 == 3):
                        s1 = t.params[0]
                        i = (i + 1)
                        if (floats is None):
                            floats = []
                            _g = 0
                            while (_g < len(ints)):
                                i1 = (ints[_g] if _g >= 0 and _g < len(ints) else None)
                                _g = (_g + 1)
                                floats.append(i1)
                            ints = None
                        x4 = Std.parseFloat(s1)
                        floats.append(x4)
                    elif (t2 == 8):
                        continue
                    else:
                        self.unexpected(t)
                props.append((hxd_fmt_fbx_FbxProp.PInts(ints) if ((floats is None)) else hxd_fmt_fbx_FbxProp.PFloats(floats)))
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceClose)
                break
            else:
                self.unexpected(t)
            t = self.next()
            t3 = t.index
            if ((t3 == 7) or ((t3 == 1))):
                self.token = t
                break
            elif (t3 == 6):
                childs = self.parseNodes()
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceClose)
                break
            elif (t3 == 8):
                pass
            else:
                self.unexpected(t)
        if (childs is None):
            childs = []
        return _hx_AnonObject({'name': name, 'props': props, 'childs': childs})

    def _hx_except(self,_hx_except):
        t = self.next()
        if (not Type.enumEq(t,_hx_except)):
            self.error((((("Unexpected '" + HxOverrides.stringOrNull(self.tokenStr(t))) + "' (") + HxOverrides.stringOrNull(self.tokenStr(_hx_except))) + " expected)"))

    def peek(self):
        if (self.token is None):
            self.token = self.nextToken()
        return self.token

    def next(self):
        if (self.token is None):
            return self.nextToken()
        tmp = self.token
        self.token = None
        return tmp

    def error(self,msg):
        raise _HxException((((("null" if msg is None else msg) + " (line ") + Std.string(self.line)) + ")"))

    def unexpected(self,t):
        return self.error(("Unexpected " + HxOverrides.stringOrNull(self.tokenStr(t))))

    def tokenStr(self,t):
        t1 = t.index
        if (t1 == 0):
            return t.params[0]
        elif (t1 == 1):
            return (HxOverrides.stringOrNull(t.params[0]) + ":")
        elif (t1 == 2):
            return t.params[0]
        elif (t1 == 3):
            return t.params[0]
        elif (t1 == 4):
            return (("\"" + HxOverrides.stringOrNull(t.params[0])) + "\"")
        elif (t1 == 5):
            return ("*" + Std.string(t.params[0]))
        elif (t1 == 6):
            return "{"
        elif (t1 == 7):
            return "}"
        elif (t1 == 8):
            return ","
        elif (t1 == 9):
            return "<eof>"
        else:
            pass

    def nextToken(self):
        start = self.pos
        while True:
            s = self.buf
            index = self.pos
            self.pos = (self.pos + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            c1 = c
            if (c1 == 10):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.line
                _hx_local_0.line = (_hx_local_1 + 1)
                _hx_local_1
                start = (start + 1)
            elif (((c1 == 32) or ((c1 == 13))) or ((c1 == 9))):
                start = (start + 1)
            elif (c1 == 34):
                start = self.pos
                while True:
                    s1 = self.buf
                    index1 = self.pos
                    self.pos = (self.pos + 1)
                    if (index1 >= len(s1)):
                        c = -1
                    else:
                        c = ord(s1[index1])
                    if (c == 34):
                        break
                    if ((c == -1) or ((c == 10))):
                        self.error("Unclosed string")
                return hxd_fmt_fbx__Parser_Token.TString(HxString.substr(self.buf,start,((self.pos - start) - 1)))
            elif (c1 == 42):
                start = self.pos
                while True:
                    s2 = self.buf
                    index2 = self.pos
                    self.pos = (self.pos + 1)
                    if (index2 >= len(s2)):
                        c = -1
                    else:
                        c = ord(s2[index2])
                    if (not (((c >= 48) and ((c <= 57))))):
                        break
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.pos
                _hx_local_4.pos = (_hx_local_5 - 1)
                _hx_local_5
                return hxd_fmt_fbx__Parser_Token.TLength(Std.parseInt(HxString.substr(self.buf,start,(self.pos - start))))
            elif (c1 == 44):
                return hxd_fmt_fbx__Parser_Token.TColon
            elif (c1 == 59):
                while True:
                    s3 = self.buf
                    index3 = self.pos
                    self.pos = (self.pos + 1)
                    c2 = (-1 if ((index3 >= len(s3))) else ord(s3[index3]))
                    if ((c2 == -1) or ((c2 == 10))):
                        _hx_local_6 = self
                        _hx_local_7 = _hx_local_6.pos
                        _hx_local_6.pos = (_hx_local_7 - 1)
                        _hx_local_7
                        break
                start = self.pos
            elif (c1 == 123):
                return hxd_fmt_fbx__Parser_Token.TBraceOpen
            elif (c1 == 125):
                return hxd_fmt_fbx__Parser_Token.TBraceClose
            else:
                if ((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or ((c == 95))):
                    while True:
                        s4 = self.buf
                        index4 = self.pos
                        self.pos = (self.pos + 1)
                        if (index4 >= len(s4)):
                            c = -1
                        else:
                            c = ord(s4[index4])
                        if (not (((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 95))) or ((c == 45))))):
                            break
                    if (c == 58):
                        return hxd_fmt_fbx__Parser_Token.TNode(HxString.substr(self.buf,start,((self.pos - start) - 1)))
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.pos
                    _hx_local_8.pos = (_hx_local_9 - 1)
                    _hx_local_9
                    return hxd_fmt_fbx__Parser_Token.TIdent(HxString.substr(self.buf,start,(self.pos - start)))
                if (((c >= 48) and ((c <= 57))) or ((c == 45))):
                    while True:
                        s5 = self.buf
                        index5 = self.pos
                        self.pos = (self.pos + 1)
                        if (index5 >= len(s5)):
                            c = -1
                        else:
                            c = ord(s5[index5])
                        if (not (((c >= 48) and ((c <= 57))))):
                            break
                    if ((((c != 46) and ((c != 69))) and ((c != 101))) and (((self.pos - start) < 10))):
                        _hx_local_10 = self
                        _hx_local_11 = _hx_local_10.pos
                        _hx_local_10.pos = (_hx_local_11 - 1)
                        _hx_local_11
                        return hxd_fmt_fbx__Parser_Token.TInt(HxString.substr(self.buf,start,(self.pos - start)))
                    if (c == 46):
                        while True:
                            s6 = self.buf
                            index6 = self.pos
                            self.pos = (self.pos + 1)
                            if (index6 >= len(s6)):
                                c = -1
                            else:
                                c = ord(s6[index6])
                            if (not (((c >= 48) and ((c <= 57))))):
                                break
                    if ((c == 101) or ((c == 69))):
                        s7 = self.buf
                        index7 = self.pos
                        self.pos = (self.pos + 1)
                        if (index7 >= len(s7)):
                            c = -1
                        else:
                            c = ord(s7[index7])
                        if ((c != 45) and ((c != 43))):
                            _hx_local_12 = self
                            _hx_local_13 = _hx_local_12.pos
                            _hx_local_12.pos = (_hx_local_13 - 1)
                            _hx_local_13
                        while True:
                            s8 = self.buf
                            index8 = self.pos
                            self.pos = (self.pos + 1)
                            if (index8 >= len(s8)):
                                c = -1
                            else:
                                c = ord(s8[index8])
                            if (not (((c >= 48) and ((c <= 57))))):
                                break
                    _hx_local_14 = self
                    _hx_local_15 = _hx_local_14.pos
                    _hx_local_14.pos = (_hx_local_15 - 1)
                    _hx_local_15
                    return hxd_fmt_fbx__Parser_Token.TFloat(HxString.substr(self.buf,start,(self.pos - start)))
                if (c == -1):
                    _hx_local_16 = self
                    _hx_local_17 = _hx_local_16.pos
                    _hx_local_16.pos = (_hx_local_17 - 1)
                    _hx_local_17
                    return hxd_fmt_fbx__Parser_Token.TEof
                self.error((("Unexpected char '" + HxOverrides.stringOrNull("".join(map(chr,[c])))) + "'"))

    @staticmethod
    def parse(text):
        return hxd_fmt_fbx_Parser().parseText(text)

hxd_fmt_fbx_Parser._hx_class = hxd_fmt_fbx_Parser

class hxd_fmt_hmd_Property(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.hmd.Property"
    _hx_constructs = ["CameraFOVY", "HasMaterialFlags"]

    @staticmethod
    def CameraFOVY(v):
        return hxd_fmt_hmd_Property("CameraFOVY", 0, [v])
hxd_fmt_hmd_Property.HasMaterialFlags = hxd_fmt_hmd_Property("HasMaterialFlags", 1, list())
hxd_fmt_hmd_Property._hx_class = hxd_fmt_hmd_Property


class hxd_fmt_hmd_Position:
    _hx_class_name = "hxd.fmt.hmd.Position"
    __slots__ = ("x", "y", "z", "qx", "qy", "qz", "sx", "sy", "sz")
    _hx_fields = ["x", "y", "z", "qx", "qy", "qz", "sx", "sy", "sz"]

    def __init__(self):
        self.sz = None
        self.sy = None
        self.sx = None
        self.qz = None
        self.qy = None
        self.qx = None
        self.z = None
        self.y = None
        self.x = None

hxd_fmt_hmd_Position._hx_class = hxd_fmt_hmd_Position


class hxd_fmt_hmd_GeometryFormat:
    _hx_class_name = "hxd.fmt.hmd.GeometryFormat"
    __slots__ = ("name", "format")
    _hx_fields = ["name", "format"]

    def __init__(self,name,format):
        self.name = name
        self.format = format

hxd_fmt_hmd_GeometryFormat._hx_class = hxd_fmt_hmd_GeometryFormat


class hxd_fmt_hmd_Geometry:
    _hx_class_name = "hxd.fmt.hmd.Geometry"
    __slots__ = ("props", "vertexCount", "vertexStride", "vertexFormat", "vertexPosition", "indexCounts", "indexPosition", "bounds")
    _hx_fields = ["props", "vertexCount", "vertexStride", "vertexFormat", "vertexPosition", "indexCounts", "indexPosition", "bounds"]

    def __init__(self):
        self.bounds = None
        self.indexPosition = None
        self.indexCounts = None
        self.vertexPosition = None
        self.vertexFormat = None
        self.vertexStride = None
        self.vertexCount = None
        self.props = None

hxd_fmt_hmd_Geometry._hx_class = hxd_fmt_hmd_Geometry

class hxd_fmt_hmd_MaterialFlag(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.hmd.MaterialFlag"
    _hx_constructs = ["HasLighting", "CastShadows", "ReceiveShadows", "TextureWrap", "IsVolumeDecal"]
hxd_fmt_hmd_MaterialFlag.HasLighting = hxd_fmt_hmd_MaterialFlag("HasLighting", 0, list())
hxd_fmt_hmd_MaterialFlag.CastShadows = hxd_fmt_hmd_MaterialFlag("CastShadows", 1, list())
hxd_fmt_hmd_MaterialFlag.ReceiveShadows = hxd_fmt_hmd_MaterialFlag("ReceiveShadows", 2, list())
hxd_fmt_hmd_MaterialFlag.TextureWrap = hxd_fmt_hmd_MaterialFlag("TextureWrap", 3, list())
hxd_fmt_hmd_MaterialFlag.IsVolumeDecal = hxd_fmt_hmd_MaterialFlag("IsVolumeDecal", 4, list())
hxd_fmt_hmd_MaterialFlag._hx_class = hxd_fmt_hmd_MaterialFlag


class hxd_fmt_hmd_Material:
    _hx_class_name = "hxd.fmt.hmd.Material"
    __slots__ = ("name", "props", "diffuseTexture", "blendMode", "culling", "killAlpha", "flags")
    _hx_fields = ["name", "props", "diffuseTexture", "blendMode", "culling", "killAlpha", "flags"]
    _hx_statics = ["DEFAULT_FLAGS"]

    def __init__(self):
        self.flags = None
        self.killAlpha = None
        self.culling = None
        self.blendMode = None
        self.diffuseTexture = None
        self.props = None
        self.name = None

hxd_fmt_hmd_Material._hx_class = hxd_fmt_hmd_Material


class hxd_fmt_hmd_SkinJoint:
    _hx_class_name = "hxd.fmt.hmd.SkinJoint"
    __slots__ = ("name", "props", "parent", "position", "bind", "transpos")
    _hx_fields = ["name", "props", "parent", "position", "bind", "transpos"]

    def __init__(self):
        self.transpos = None
        self.bind = None
        self.position = None
        self.parent = None
        self.props = None
        self.name = None

hxd_fmt_hmd_SkinJoint._hx_class = hxd_fmt_hmd_SkinJoint


class hxd_fmt_hmd_SkinSplit:
    _hx_class_name = "hxd.fmt.hmd.SkinSplit"
    __slots__ = ("materialIndex", "joints")
    _hx_fields = ["materialIndex", "joints"]

    def __init__(self):
        self.joints = None
        self.materialIndex = None

hxd_fmt_hmd_SkinSplit._hx_class = hxd_fmt_hmd_SkinSplit


class hxd_fmt_hmd_Skin:
    _hx_class_name = "hxd.fmt.hmd.Skin"
    __slots__ = ("name", "props", "joints", "split")
    _hx_fields = ["name", "props", "joints", "split"]

    def __init__(self):
        self.split = None
        self.joints = None
        self.props = None
        self.name = None

hxd_fmt_hmd_Skin._hx_class = hxd_fmt_hmd_Skin


class hxd_fmt_hmd_Model:
    _hx_class_name = "hxd.fmt.hmd.Model"
    __slots__ = ("name", "props", "parent", "follow", "position", "geometry", "materials", "skin")
    _hx_fields = ["name", "props", "parent", "follow", "position", "geometry", "materials", "skin"]

    def __init__(self):
        self.skin = None
        self.materials = None
        self.geometry = None
        self.position = None
        self.follow = None
        self.parent = None
        self.props = None
        self.name = None

hxd_fmt_hmd_Model._hx_class = hxd_fmt_hmd_Model

class hxd_fmt_hmd_AnimationFlag(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.hmd.AnimationFlag"
    _hx_constructs = ["HasPosition", "HasRotation", "HasScale", "HasUV", "HasAlpha", "SinglePosition", "HasProps", "Reserved"]
hxd_fmt_hmd_AnimationFlag.HasPosition = hxd_fmt_hmd_AnimationFlag("HasPosition", 0, list())
hxd_fmt_hmd_AnimationFlag.HasRotation = hxd_fmt_hmd_AnimationFlag("HasRotation", 1, list())
hxd_fmt_hmd_AnimationFlag.HasScale = hxd_fmt_hmd_AnimationFlag("HasScale", 2, list())
hxd_fmt_hmd_AnimationFlag.HasUV = hxd_fmt_hmd_AnimationFlag("HasUV", 3, list())
hxd_fmt_hmd_AnimationFlag.HasAlpha = hxd_fmt_hmd_AnimationFlag("HasAlpha", 4, list())
hxd_fmt_hmd_AnimationFlag.SinglePosition = hxd_fmt_hmd_AnimationFlag("SinglePosition", 5, list())
hxd_fmt_hmd_AnimationFlag.HasProps = hxd_fmt_hmd_AnimationFlag("HasProps", 6, list())
hxd_fmt_hmd_AnimationFlag.Reserved = hxd_fmt_hmd_AnimationFlag("Reserved", 7, list())
hxd_fmt_hmd_AnimationFlag._hx_class = hxd_fmt_hmd_AnimationFlag


class hxd_fmt_hmd_AnimationObject:
    _hx_class_name = "hxd.fmt.hmd.AnimationObject"
    __slots__ = ("name", "flags", "props")
    _hx_fields = ["name", "flags", "props"]

    def __init__(self):
        self.props = None
        self.flags = None
        self.name = None

hxd_fmt_hmd_AnimationObject._hx_class = hxd_fmt_hmd_AnimationObject


class hxd_fmt_hmd_AnimationEvent:
    _hx_class_name = "hxd.fmt.hmd.AnimationEvent"
    __slots__ = ("frame", "data")
    _hx_fields = ["frame", "data"]

    def __init__(self):
        self.data = None
        self.frame = None

hxd_fmt_hmd_AnimationEvent._hx_class = hxd_fmt_hmd_AnimationEvent


class hxd_fmt_hmd_Animation:
    _hx_class_name = "hxd.fmt.hmd.Animation"
    __slots__ = ("name", "props", "frames", "sampling", "speed", "loop", "objects", "events", "dataPosition")
    _hx_fields = ["name", "props", "frames", "sampling", "speed", "loop", "objects", "events", "dataPosition"]

    def __init__(self):
        self.dataPosition = None
        self.events = None
        self.objects = None
        self.loop = None
        self.speed = None
        self.sampling = None
        self.frames = None
        self.props = None
        self.name = None

hxd_fmt_hmd_Animation._hx_class = hxd_fmt_hmd_Animation


class hxd_fmt_hmd_Data:
    _hx_class_name = "hxd.fmt.hmd.Data"
    __slots__ = ("version", "props", "geometries", "materials", "models", "animations", "dataPosition", "data")
    _hx_fields = ["version", "props", "geometries", "materials", "models", "animations", "dataPosition", "data"]

    def __init__(self):
        self.data = None
        self.dataPosition = None
        self.animations = None
        self.models = None
        self.materials = None
        self.geometries = None
        self.props = None
        self.version = None

hxd_fmt_hmd_Data._hx_class = hxd_fmt_hmd_Data


class hxd_fmt_hmd_Reader:
    _hx_class_name = "hxd.fmt.hmd.Reader"
    __slots__ = ("i", "version")
    _hx_fields = ["i", "version"]
    _hx_methods = ["readProperty", "readProps", "readName", "readPosition", "readBounds", "readSkin", "readHeader", "read"]
    _hx_statics = ["BLEND", "CULLING"]

    def __init__(self,i):
        self.version = None
        self.i = i

    def readProperty(self):
        _g = self.i.readByte()
        if (_g == 0):
            return hxd_fmt_hmd_Property.CameraFOVY(self.i.readFloat())
        elif (_g == 1):
            return hxd_fmt_hmd_Property.HasMaterialFlags
        else:
            raise _HxException(("Unknown property #" + Std.string(_g)))

    def readProps(self):
        if (self.version == 1):
            return None
        n = self.i.readByte()
        if (n == 0):
            return None
        _g = []
        _g2 = 0
        while (_g2 < n):
            _g2 = (_g2 + 1)
            x = self.readProperty()
            _g.append(x)
        return _g

    def readName(self):
        b = self.i.readByte()
        if (b == 255):
            return None
        return self.i.readString(b)

    def readPosition(self,hasScale = True):
        if (hasScale is None):
            hasScale = True
        p = hxd_fmt_hmd_Position()
        p.x = self.i.readFloat()
        p.y = self.i.readFloat()
        p.z = self.i.readFloat()
        p.qx = self.i.readFloat()
        p.qy = self.i.readFloat()
        p.qz = self.i.readFloat()
        if hasScale:
            p.sx = self.i.readFloat()
            p.sy = self.i.readFloat()
            p.sz = self.i.readFloat()
        else:
            p.sx = 1
            p.sy = 1
            p.sz = 1
        return p

    def readBounds(self):
        b = h3d_col_Bounds()
        b.xMin = self.i.readFloat()
        b.yMin = self.i.readFloat()
        b.zMin = self.i.readFloat()
        b.xMax = self.i.readFloat()
        b.yMax = self.i.readFloat()
        b.zMax = self.i.readFloat()
        return b

    def readSkin(self):
        name = self.readName()
        if (name is None):
            return None
        s = hxd_fmt_hmd_Skin()
        s.props = self.readProps()
        s.name = name
        s.joints = []
        _g1 = 0
        _g = self.i.readUInt16()
        while (_g1 < _g):
            _g1 = (_g1 + 1)
            j = hxd_fmt_hmd_SkinJoint()
            j.props = self.readProps()
            j.name = self.readName()
            pid = self.i.readUInt16()
            hasScale = (((pid & 32768)) != 0)
            if hasScale:
                pid = (pid & 32767)
            j.parent = (pid - 1)
            j.position = self.readPosition(hasScale)
            j.bind = (self.i.readUInt16() - 1)
            if (j.bind >= 0):
                j.transpos = self.readPosition(hasScale)
            s.joints.append(j)
        count = self.i.readByte()
        if (count > 0):
            s.split = []
            _g11 = 0
            while (_g11 < count):
                _g11 = (_g11 + 1)
                ss = hxd_fmt_hmd_SkinSplit()
                ss.materialIndex = self.i.readByte()
                _g2 = []
                _g4 = 0
                _g3 = self.i.readByte()
                while (_g4 < _g3):
                    _g4 = (_g4 + 1)
                    x = self.i.readUInt16()
                    _g2.append(x)
                ss.joints = _g2
                s.split.append(ss)
        return s

    def readHeader(self):
        d = hxd_fmt_hmd_Data()
        h = self.i.readString(3)
        if (h != "HMD"):
            if (HxString.charCodeAt(h,0) == 59):
                raise _HxException("FBX was not converted to HMD")
            raise _HxException(("Invalid HMD header " + HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(h,""))))
        self.version = self.i.readByte()
        if (self.version > 2):
            raise _HxException(("Can't read HMD v" + Std.string(self.version)))
        d.version = self.version
        d.geometries = []
        d.dataPosition = self.i.readInt32()
        d.props = self.readProps()
        _g1 = 0
        _g = self.i.readInt32()
        while (_g1 < _g):
            _g1 = (_g1 + 1)
            g = hxd_fmt_hmd_Geometry()
            g.props = self.readProps()
            g.vertexCount = self.i.readInt32()
            g.vertexStride = self.i.readByte()
            _g2 = []
            _g4 = 0
            _g3 = self.i.readByte()
            while (_g4 < _g3):
                _g4 = (_g4 + 1)
                x = hxd_fmt_hmd_GeometryFormat(self.readName(),self.i.readByte())
                _g2.append(x)
            g.vertexFormat = _g2
            g.vertexPosition = self.i.readInt32()
            _g31 = []
            _g5 = 0
            _g41 = self.i.readByte()
            while (_g5 < _g41):
                _g5 = (_g5 + 1)
                x1 = self.i.readInt32()
                _g31.append(x1)
            g.indexCounts = _g31
            g.indexPosition = self.i.readInt32()
            g.bounds = self.readBounds()
            d.geometries.append(g)
        d.materials = []
        _g11 = 0
        _g6 = self.i.readInt32()
        while (_g11 < _g6):
            _g11 = (_g11 + 1)
            m = hxd_fmt_hmd_Material()
            m.props = self.readProps()
            m.name = self.readName()
            m.diffuseTexture = self.readName()
            m.blendMode = python_internal_ArrayImpl._get(hxd_fmt_hmd_Reader.BLEND, self.i.readByte())
            m.culling = python_internal_ArrayImpl._get(hxd_fmt_hmd_Reader.CULLING, self.i.readByte())
            m.killAlpha = self.i.readFloat()
            if (m.killAlpha == 1):
                m.killAlpha = None
            if ((m.props is not None) and ((python_internal_ArrayImpl.indexOf(m.props,hxd_fmt_hmd_Property.HasMaterialFlags,None) >= 0))):
                m.flags = self.i.readInt32()
            d.materials.append(m)
        d.models = []
        _g12 = 0
        _g7 = self.i.readInt32()
        while (_g12 < _g7):
            _g12 = (_g12 + 1)
            m1 = hxd_fmt_hmd_Model()
            m1.props = self.readProps()
            m1.name = self.readName()
            m1.parent = (self.i.readInt32() - 1)
            m1.follow = self.readName()
            m1.position = self.readPosition()
            m1.geometry = (self.i.readInt32() - 1)
            d.models.append(m1)
            if (m1.geometry < 0):
                continue
            m1.materials = []
            _g32 = 0
            _g21 = self.i.readByte()
            while (_g32 < _g21):
                _g32 = (_g32 + 1)
                _this = m1.materials
                x2 = self.i.readInt32()
                _this.append(x2)
            m1.skin = self.readSkin()
        d.animations = []
        _g13 = 0
        _g8 = self.i.readInt32()
        while (_g13 < _g8):
            _g13 = (_g13 + 1)
            a = hxd_fmt_hmd_Animation()
            a.props = self.readProps()
            a.name = self.readName()
            a.frames = self.i.readInt32()
            a.sampling = self.i.readFloat()
            a.speed = self.i.readFloat()
            flags = self.i.readByte()
            a.loop = (((flags & 1)) != 0)
            a.dataPosition = self.i.readInt32()
            a.objects = []
            _g33 = 0
            _g22 = self.i.readInt32()
            while (_g33 < _g22):
                _g33 = (_g33 + 1)
                o = hxd_fmt_hmd_AnimationObject()
                o.name = self.readName()
                o.flags = self.i.readByte()
                a.objects.append(o)
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                    _g42 = []
                    _g61 = 0
                    _g51 = self.i.readByte()
                    while (_g61 < _g51):
                        _g61 = (_g61 + 1)
                        x3 = self.readName()
                        _g42.append(x3)
                    o.props = _g42
            if (((flags & 2)) != 0):
                a.events = []
                _g34 = 0
                _g23 = self.i.readInt32()
                while (_g34 < _g23):
                    _g34 = (_g34 + 1)
                    e = hxd_fmt_hmd_AnimationEvent()
                    e.frame = self.i.readInt32()
                    e.data = self.readName()
                    a.events.append(e)
            d.animations.append(a)
        return d

    def read(self):
        h = self.readHeader()
        h.data = self.i.read(self.i.readInt32())
        return h

hxd_fmt_hmd_Reader._hx_class = hxd_fmt_hmd_Reader


class hxd_fmt_hmd_Writer:
    _hx_class_name = "hxd.fmt.hmd.Writer"
    __slots__ = ("out", "version")
    _hx_fields = ["out", "version"]
    _hx_methods = ["writeProperty", "writeProps", "writeName", "writePosition", "writeBounds", "writeSkin", "write"]

    def __init__(self,out):
        self.version = None
        self.out = out

    def writeProperty(self,p):
        self.out.writeByte(p.index)
        p1 = p.index
        if (p1 == 0):
            self.out.writeFloat(p.params[0])
        elif (p1 == 1):
            pass
        else:
            pass

    def writeProps(self,props):
        if (props is None):
            if (self.version == 1):
                return
            self.out.writeByte(0)
            return
        if (self.version == 1):
            raise _HxException("Properties not supported in HMDv1")
        self.out.writeByte(len(props))
        _g = 0
        while (_g < len(props)):
            p = (props[_g] if _g >= 0 and _g < len(props) else None)
            _g = (_g + 1)
            self.writeProperty(p)

    def writeName(self,name):
        if (name is None):
            self.out.writeByte(255)
            return
        self.out.writeByte(len(name))
        self.out.writeString(name)

    def writePosition(self,p,hasScale = True):
        if (hasScale is None):
            hasScale = True
        f = p.x
        self.out.writeFloat((0 if ((f == 0)) else f))
        f1 = p.y
        self.out.writeFloat((0 if ((f1 == 0)) else f1))
        f2 = p.z
        self.out.writeFloat((0 if ((f2 == 0)) else f2))
        f3 = p.qx
        self.out.writeFloat((0 if ((f3 == 0)) else f3))
        f4 = p.qy
        self.out.writeFloat((0 if ((f4 == 0)) else f4))
        f5 = p.qz
        self.out.writeFloat((0 if ((f5 == 0)) else f5))
        if hasScale:
            f6 = p.sx
            self.out.writeFloat((0 if ((f6 == 0)) else f6))
            f7 = p.sy
            self.out.writeFloat((0 if ((f7 == 0)) else f7))
            f8 = p.sz
            self.out.writeFloat((0 if ((f8 == 0)) else f8))

    def writeBounds(self,b):
        f = b.xMin
        self.out.writeFloat((0 if ((f == 0)) else f))
        f1 = b.yMin
        self.out.writeFloat((0 if ((f1 == 0)) else f1))
        f2 = b.zMin
        self.out.writeFloat((0 if ((f2 == 0)) else f2))
        f3 = b.xMax
        self.out.writeFloat((0 if ((f3 == 0)) else f3))
        f4 = b.yMax
        self.out.writeFloat((0 if ((f4 == 0)) else f4))
        f5 = b.zMax
        self.out.writeFloat((0 if ((f5 == 0)) else f5))

    def writeSkin(self,s):
        self.writeName(("" if ((s.name is None)) else s.name))
        self.writeProps(s.props)
        self.out.writeUInt16(len(s.joints))
        _g = 0
        _g1 = s.joints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(j.props)
            self.writeName(j.name)
            rot = ((((j.position.sx != 1) or ((j.position.sy != 1))) or ((j.position.sz != 1))) or (((j.transpos is not None) and ((((j.transpos.sx != 1) or ((j.transpos.sy != 1))) or ((j.transpos.sz != 1)))))))
            self.out.writeUInt16(((j.parent + 1) | ((32768 if rot else 0))))
            self.writePosition(j.position,rot)
            self.out.writeUInt16((j.bind + 1))
            if (j.bind >= 0):
                self.writePosition(j.transpos,rot)
        self.out.writeByte((0 if ((s.split is None)) else len(s.split)))
        if (s.split is not None):
            _g2 = 0
            _g11 = s.split
            while (_g2 < len(_g11)):
                ss = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                self.out.writeByte(ss.materialIndex)
                self.out.writeByte(len(ss.joints))
                _g21 = 0
                _g3 = ss.joints
                while (_g21 < len(_g3)):
                    i = (_g3[_g21] if _g21 >= 0 and _g21 < len(_g3) else None)
                    _g21 = (_g21 + 1)
                    self.out.writeUInt16(i)

    def write(self,d):
        old = self.out
        header = haxe_io_BytesOutput()
        self.out = header
        self.version = d.version
        if (self.version > 2):
            raise _HxException(("Can't write HMD v" + Std.string(self.version)))
        self.writeProps(d.props)
        self.out.writeInt32(len(d.geometries))
        _g = 0
        _g1 = d.geometries
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(g.props)
            self.out.writeInt32(g.vertexCount)
            self.out.writeByte(g.vertexStride)
            self.out.writeByte(len(g.vertexFormat))
            _g2 = 0
            _g3 = g.vertexFormat
            while (_g2 < len(_g3)):
                f = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.writeName(f.name)
                self.out.writeByte(f.format)
            self.out.writeInt32(g.vertexPosition)
            self.out.writeByte(len(g.indexCounts))
            _g21 = 0
            _g31 = g.indexCounts
            while (_g21 < len(_g31)):
                i = (_g31[_g21] if _g21 >= 0 and _g21 < len(_g31) else None)
                _g21 = (_g21 + 1)
                self.out.writeInt32(i)
            self.out.writeInt32(g.indexPosition)
            self.writeBounds(g.bounds)
        self.out.writeInt32(len(d.materials))
        _g4 = 0
        _g11 = d.materials
        while (_g4 < len(_g11)):
            m = (_g11[_g4] if _g4 >= 0 and _g4 < len(_g11) else None)
            _g4 = (_g4 + 1)
            self.writeProps(m.props)
            self.writeName(m.name)
            self.writeName(m.diffuseTexture)
            self.out.writeByte(m.blendMode.index)
            self.out.writeByte(m.culling.index)
            f1 = (1 if ((m.killAlpha is None)) else m.killAlpha)
            self.out.writeFloat((0 if ((f1 == 0)) else f1))
            if ((m.props is not None) and ((python_internal_ArrayImpl.indexOf(m.props,hxd_fmt_hmd_Property.HasMaterialFlags,None) >= 0))):
                self.out.writeInt32(m.flags)
        self.out.writeInt32(len(d.models))
        _g5 = 0
        _g12 = d.models
        while (_g5 < len(_g12)):
            m1 = (_g12[_g5] if _g5 >= 0 and _g5 < len(_g12) else None)
            _g5 = (_g5 + 1)
            self.writeProps(m1.props)
            self.writeName(m1.name)
            self.out.writeInt32((m1.parent + 1))
            self.writeName(m1.follow)
            self.writePosition(m1.position)
            self.out.writeInt32((m1.geometry + 1))
            if (m1.geometry < 0):
                continue
            self.out.writeByte(len(m1.materials))
            _g22 = 0
            _g32 = m1.materials
            while (_g22 < len(_g32)):
                m2 = (_g32[_g22] if _g22 >= 0 and _g22 < len(_g32) else None)
                _g22 = (_g22 + 1)
                self.out.writeInt32(m2)
            if (m1.skin is None):
                self.writeName(None)
            else:
                self.writeSkin(m1.skin)
        self.out.writeInt32(len(d.animations))
        _g6 = 0
        _g13 = d.animations
        while (_g6 < len(_g13)):
            a = (_g13[_g6] if _g6 >= 0 and _g6 < len(_g13) else None)
            _g6 = (_g6 + 1)
            self.writeProps(a.props)
            self.writeName(a.name)
            self.out.writeInt32(a.frames)
            f2 = a.sampling
            self.out.writeFloat((0 if ((f2 == 0)) else f2))
            f3 = a.speed
            self.out.writeFloat((0 if ((f3 == 0)) else f3))
            self.out.writeByte((((1 if (a.loop) else 0)) | ((2 if ((a.events is not None)) else 0))))
            self.out.writeInt32(a.dataPosition)
            self.out.writeInt32(len(a.objects))
            _g23 = 0
            _g33 = a.objects
            while (_g23 < len(_g33)):
                o = (_g33[_g23] if _g23 >= 0 and _g23 < len(_g33) else None)
                _g23 = (_g23 + 1)
                self.writeName(o.name)
                self.out.writeByte(o.flags)
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                    self.out.writeByte(len(o.props))
                    _g41 = 0
                    _g51 = o.props
                    while (_g41 < len(_g51)):
                        n = (_g51[_g41] if _g41 >= 0 and _g41 < len(_g51) else None)
                        _g41 = (_g41 + 1)
                        self.writeName(n)
            if (a.events is not None):
                self.out.writeInt32(len(a.events))
                _g24 = 0
                _g34 = a.events
                while (_g24 < len(_g34)):
                    e = (_g34[_g24] if _g24 >= 0 and _g24 < len(_g34) else None)
                    _g24 = (_g24 + 1)
                    self.out.writeInt32(e.frame)
                    self.writeName(e.data)
        _hx_bytes = header.getBytes()
        self.out = old
        self.out.writeString("HMD")
        self.out.writeByte(d.version)
        self.out.writeInt32((_hx_bytes.length + 12))
        self.out.write(_hx_bytes)
        self.out.writeInt32(d.data.length)
        self.out.write(d.data)

hxd_fmt_hmd_Writer._hx_class = hxd_fmt_hmd_Writer


class hxd_fs_Convert:
    _hx_class_name = "hxd.fs.Convert"
    __slots__ = ("sourceExt", "destExt", "srcPath", "dstPath", "srcFilename", "srcBytes")
    _hx_fields = ["sourceExt", "destExt", "srcPath", "dstPath", "srcFilename", "srcBytes"]
    _hx_methods = ["save"]

    def __init__(self,sourceExt,destExt):
        self.srcBytes = None
        self.srcFilename = None
        self.dstPath = None
        self.srcPath = None
        self.sourceExt = sourceExt
        self.destExt = destExt

    def save(self,_hx_bytes):
        hxd_File.saveBytes(self.dstPath,_hx_bytes)

hxd_fs_Convert._hx_class = hxd_fs_Convert


class hxd_fs_ConvertFBX2HMD(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertFBX2HMD"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("fbx","hmd")

    def convert(self):
        fbx = None
        try:
            fbx = hxd_fmt_fbx_Parser.parse(self.srcBytes.toString())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            raise _HxException(((Std.string(e) + " in ") + HxOverrides.stringOrNull(self.srcPath)))
        hmdout = hxd_fmt_fbx_HMDOut()
        hmdout.load(fbx)
        hmd = hmdout.toHMD(None,(not ((StringTools.startsWith(self.srcFilename,"Anim_") or ((self.srcFilename.lower().find("_anim_") > 0))))))
        out = haxe_io_BytesOutput()
        hxd_fmt_hmd_Writer(out).write(hmd)
        self.save(out.getBytes())

hxd_fs_ConvertFBX2HMD._hx_class = hxd_fs_ConvertFBX2HMD


class hxd_fs_NotFound:
    _hx_class_name = "hxd.fs.NotFound"
    __slots__ = ("path",)
    _hx_fields = ["path"]
    _hx_methods = ["toString"]

    def toString(self):
        return (("Resource file not found '" + HxOverrides.stringOrNull(self.path)) + "'")

hxd_fs_NotFound._hx_class = hxd_fs_NotFound


class hxd_impl_Tmp:
    _hx_class_name = "hxd.impl.Tmp"
    __slots__ = ()
    _hx_statics = ["bytes", "outOfMemory", "getBytes", "freeMemory", "allocBytes", "saveBytes"]

    @staticmethod
    def outOfMemory():
        pass

    @staticmethod
    def getBytes(size):
        found = -1
        _g1 = 0
        _g = len(hxd_impl_Tmp.bytes)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (python_internal_ArrayImpl._get(hxd_impl_Tmp.bytes, i).length >= size):
                found = i
        if (found >= 0):
            b = python_internal_ArrayImpl._get(hxd_impl_Tmp.bytes, found)
            _this = hxd_impl_Tmp.bytes
            pos = found
            if (pos < 0):
                pos = (len(_this) + pos)
            if (pos < 0):
                pos = 0
            _this[pos:(pos + 1)]
            del _this[pos:(pos + 1)]
            return b
        sz = 1024
        while (sz < size):
            sz = ((sz * 3) >> 1)
        return hxd_impl_Tmp.allocBytes(sz)

    @staticmethod
    def freeMemory():
        hxd_impl_Tmp.bytes = []
        hxd_impl_Tmp.outOfMemory()

    @staticmethod
    def allocBytes(size):
        try:
            return haxe_io_Bytes.alloc(size)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            hxd_impl_Tmp.freeMemory()
            return haxe_io_Bytes.alloc(size)

    @staticmethod
    def saveBytes(b):
        _g1 = 0
        _g = len(hxd_impl_Tmp.bytes)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (python_internal_ArrayImpl._get(hxd_impl_Tmp.bytes, i).length <= b.length):
                hxd_impl_Tmp.bytes.insert(i, b)
                if (len(hxd_impl_Tmp.bytes) > 8):
                    _this = hxd_impl_Tmp.bytes
                    if (len(_this) != 0):
                        _this.pop()
                return
        hxd_impl_Tmp.bytes.append(b)
hxd_impl_Tmp._hx_class = hxd_impl_Tmp


class hxsl_Globals:
    _hx_class_name = "hxsl.Globals"
    __slots__ = ()
hxsl_Globals._hx_class = hxsl_Globals


class hxsl_SharedShader:
    _hx_class_name = "hxsl.SharedShader"
    __slots__ = ()
hxsl_SharedShader._hx_class = hxsl_SharedShader


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        return python_Lib.anonAsDict(d)
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["print", "println", "anonToDict", "anonAsDict", "dictAsAnon"]

    @staticmethod
    def print(v):
        _hx_str = Std.string(v)
        python_lib_Sys.stdout.buffer.write(_hx_str.encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def println(v):
        _hx_str = Std.string(v)
        python_lib_Sys.stdout.buffer.write((("" + ("null" if _hx_str is None else _hx_str)) + "\n").encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None

    @staticmethod
    def dictAsAnon(d):
        return _hx_AnonObject(d)
python_Lib._hx_class = python_Lib


class _HxException(Exception):
    _hx_class_name = "_HxException"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        super().__init__(str(val))
        self.val = val

_HxException._hx_class = _HxException


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "rshift", "modf", "mod", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return python_HaxeIterator(x.__iter__())
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        return float('nan') if (b == 0.0) else a % b if a >= 0 else -(-a % b)

    @staticmethod
    def mod(a,b):
        return a % b if a >= 0 else -(-a % b)

    @staticmethod
    def mapKwArgs(a,v):
        a1 = python_Lib.dictAsAnon(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if hasattr(a1,k1):
                setattr(a1,val,getattr(a1,k1))
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["throwEof", "readinto", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise _HxException("Write-only stream")

    def throwEof(self):
        self.wasEof = True
        raise _HxException(haxe_io_Eof())

    def readinto(self,b):
        raise _HxException("abstract method, should be overriden")

    def readBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        ba = bytearray(_hx_len)
        ret = self.readinto(ba)
        if (ret == 0):
            self.throwEof()
        s.blit(pos,haxe_io_Bytes.ofData(ba),0,_hx_len)
        return ret

python_io_NativeInput._hx_class = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "readFullBytes", "read", "readFloat", "readUInt16", "readInt32", "readString"]
python_io_IInput._hx_class = python_io_IInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
    _hx_interfaces = [python_io_IInput]
python_io_IFileInput._hx_class = python_io_IFileInput


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise _HxException("Read only stream")

python_io_NativeOutput._hx_class = python_io_NativeOutput


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "write", "writeFullBytes", "writeFloat", "writeUInt16", "writeInt32", "writeString"]
python_io_IOutput._hx_class = python_io_IOutput


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
    _hx_interfaces = [python_io_IOutput]
python_io_IFileOutput._hx_class = python_io_IFileOutput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return HxString.charCodeAt(ret,0)

    def readinto(self,b):
        return self.stream.buffer.readinto(b)

python_io_NativeTextInput._hx_class = python_io_NativeTextInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextInput._hx_class = python_io_FileTextInput


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))

python_io_NativeTextOutput._hx_class = python_io_NativeTextOutput


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextOutput._hx_class = python_io_FileTextOutput


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileOutputFromText"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))
python_io_IoTools._hx_class = python_io_IoTools


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["getBytes", "saveBytes"]

    @staticmethod
    def getBytes(path):
        f = python_lib_Builtins.open(path,"rb",-1)
        b = haxe_io_Bytes.ofData(f.read(-1))
        f.close()
        return b

    @staticmethod
    def saveBytes(path,_hx_bytes):
        f = python_lib_Builtins.open(path,"wb",-1)
        f.write(_hx_bytes.b)
        f.close()
sys_io_File._hx_class = sys_io_File


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "readFullBytes", "read", "readFloat", "readUInt16", "readInt32", "readString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def readByte(self):
        return self.impl.readByte()

    def readBytes(self,s,pos,_hx_len):
        return self.impl.readBytes(s,pos,_hx_len)

    def readFullBytes(self,s,pos,_hx_len):
        self.impl.readFullBytes(s,pos,_hx_len)

    def read(self,nbytes):
        return self.impl.read(nbytes)

    def readFloat(self):
        return self.impl.readFloat()

    def readUInt16(self):
        return self.impl.readUInt16()

    def readInt32(self):
        return self.impl.readInt32()

    def readString(self,_hx_len):
        return self.impl.readString(_hx_len)

sys_io_FileInput._hx_class = sys_io_FileInput


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "write", "writeFullBytes", "writeFloat", "writeUInt16", "writeInt32", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def write(self,s):
        self.impl.write(s)

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeFloat(self,x):
        self.impl.writeFloat(x)

    def writeUInt16(self,x):
        self.impl.writeUInt16(x)

    def writeInt32(self,x):
        self.impl.writeInt32(x)

    def writeString(self,s):
        self.impl.writeString(s)

sys_io_FileOutput._hx_class = sys_io_FileOutput

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

Date.EPOCH_UTC = python_lib_datetime_Datetime.fromtimestamp(0,python_lib_datetime_Timezone.utc)
def _hx_init_Sys_environ():
    def _hx_local_0():
        Sys.environ = haxe_ds_StringMap()
        env = python_lib_Os.environ
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
Sys._programPath = sys_FileSystem.fullPath(python_lib_Inspect.getsourcefile(Sys))
Xml.Element = 0
Xml.PCData = 1
Xml.CData = 2
Xml.Comment = 3
Xml.DocType = 4
Xml.ProcessingInstruction = 5
Xml.Document = 6
h3d_Engine.CURRENT = None
h3d_Matrix.tmp = h3d_Matrix()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
h3d_mat_Texture.UID = 0
h3d_mat_Texture.nativeFormat = hxd_PixelFormat.RGBA
h3d_mat_Texture.nativeFlip = False
h3d_mat_Texture.noiseTextures = haxe_ds_IntMap()
h3d_pass__Border_BorderShader.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey8:positiony4:typejy9:hxsl.Type:5:2i4jy12:hxsl.VecType:1:0y6:parentoR6r10R8y6:outputR10jR11:12:1ar9oR6r10R8y5:colorR10jR11:5:2i4r11R13r13y2:idi-272ghR16i-270gR16i-271gy1:poy4:filey70:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fpass%2FBorder.hxy3:maxi295y3:mini280gy1:tr12goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:40:0R17oR18R19R20i302R21i298gR22jR11:13:1ahgaoR3jR4:1:1oR6jR7:1:0R8R9R10jR11:5:2i2r11R13oR6r30R8y5:inputR10jR11:12:1ar29hR16i-268gR16i-269gR17oR18R19R20i317R21i303gR22r31goR3jR4:0:1jy10:hxsl.Const:3:1zR17oR18R19R20i320R21i319gR22jR11:3:0goR3jR4:0:1jR25:3:1i1R17oR18R19R20i323R21i322gR22r41ghR17oR18R19R20i324R21i298gR22jR11:5:2i4r11gR17oR18R19R20i324R21i280gR22r12ghR17oR18R19R20i330R21i274gR22jR11:0:0gR6jy17:hxsl.FunctionKind:0:0y3:refoR6jR7:6:0R8y6:vertexR10jR11:13:1aoR1ahy3:retr53ghR16i-273gR29r53goR1ahR2oR3jR4:4:1aoR3jR4:5:3r7oR3jR4:1:1r15R17oR18R19R20i374R21i362gR22r16goR3jR4:1:1oR6jR7:2:0R8R15R10jR11:5:2i4r11R16i-267gR17oR18R19R20i382R21i377gR22r72gR17oR18R19R20i382R21i362gR22r16ghR17oR18R19R20i388R21i356gR22r53gR6jR26:1:0R27oR6r56R8y8:fragmentR10jR11:13:1aoR1ahR29r53ghR16i-274gR29r53ghR8y29:h3d.pass._Border.BorderShadery4:varsar70r32r13r55r80hg"
h3d_shader_ScreenShader.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey8:positiony4:typejy9:hxsl.Type:5:2i4jy12:hxsl.VecType:1:0y6:parentoR6r10R8y6:outputR10jR11:12:1ar9oR6r10R8y5:colorR10jR11:5:2i4r11R13r13y2:idi-197ghR16i-195gR16i-196gy1:poy4:filey78:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxy3:maxi262y3:mini247gy1:tr12goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:40:0R17oR18R19R20i269R21i265gR22jR11:13:1ahgaoR3jR4:1:1oR6jR7:1:0R8R9R10jR11:5:2i2r11R13oR6r30R8y5:inputR10jR11:12:1ar29oR6r30R8y2:uvR10jR11:5:2i2r11R13r32R16i-194ghR16i-192gR16i-193gR17oR18R19R20i284R21i270gR22r31goR3jR4:0:1jy10:hxsl.Const:3:1zR17oR18R19R20i287R21i286gR22jR11:3:0goR3jR4:0:1jR26:3:1i1R17oR18R19R20i290R21i289gR22r43ghR17oR18R19R20i291R21i265gR22jR11:5:2i4r11gR17oR18R19R20i291R21i247gR22r12ghR17oR18R19R20i297R21i241gR22jR11:0:0gR6jy17:hxsl.FunctionKind:0:0y3:refoR6jR7:6:0R8y6:vertexR10jR11:13:1aoR1ahy3:retr55ghR16i-198gR30r55ghR8y23:h3d.shader.ScreenShadery4:varsar32r13r57hg"
h3d_pass__Copy_CopyShader.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey8:positiony4:typejy9:hxsl.Type:5:2i4jy12:hxsl.VecType:1:0y6:parentoR6r10R8y6:outputR10jR11:12:1ar9oR6r10R8y5:colorR10jR11:5:2i4r11R13r13y2:idi-204ghR16i-202gR16i-203gy1:poy4:filey78:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxy3:maxi262y3:mini247gy1:tr12goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:40:0R17oR18R19R20i269R21i265gR22jR11:13:1ahgaoR3jR4:1:1oR6jR7:1:0R8R9R10jR11:5:2i2r11R13oR6r30R8y5:inputR10jR11:12:1ar29oR6r30R8y2:uvR10jR11:5:2i2r11R13r32R16i-201ghR16i-199gR16i-200gR17oR18R19R20i284R21i270gR22r31goR3jR4:0:1jy10:hxsl.Const:3:1zR17oR18R19R20i287R21i286gR22jR11:3:0goR3jR4:0:1jR26:3:1i1R17oR18R19R20i290R21i289gR22r43ghR17oR18R19R20i291R21i265gR22jR11:5:2i4r11gR17oR18R19R20i291R21i247gR22r12ghR17oR18R19R20i297R21i241gR22jR11:0:0gR6jy17:hxsl.FunctionKind:0:0y3:refoR6jR7:6:0R8y6:vertexR10jR11:13:1aoR1ahy3:retr55ghR16i-208gR30r55goR1ahR2oR3jR4:4:1aoR3jR4:5:3r7oR3jR4:1:1oR6r10R8y12:calculatedUVR10jR11:5:2i2r11R16i-207gR17oR18y68:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fpass%2FCopy.hxR20i237R21i225gR22r70goR3jR4:1:1r34R17oR18R32R20i248R21i240gR22r35gR17oR18R32R20i248R21i225gR22r70ghR17oR18R32R20i254R21i219gR22r55gR6jR27:2:0R28oR6r58R8y8:__init__R10jR11:13:1aoR1ahR30r55ghR16i-209gR30r55goR1ahR2oR3jR4:4:1aoR3jR4:5:3r7oR3jR4:1:1oR6r10R8y10:pixelColorR10jR11:5:2i4r11R16i-206gR17oR18R32R20i304R21i294gR22r93goR3jR4:8:2oR3jR4:2:1jR23:33:0R17oR18R32R20i314R21i307gR22jR11:13:1aoR1aoR8y1:_R10jR11:10:0goR8R25R10jR11:5:2i2r11ghR30jR11:5:2i4r11ghgaoR3jR4:1:1oR6jR7:2:0R8y7:textureR10r105R16i-205gR17oR18R32R20i314R21i307gR22r105goR3jR4:1:1r69R17oR18R32R20i331R21i319gR22r70ghR17oR18R32R20i332R21i307gR22r108gR17oR18R32R20i332R21i294gR22r93ghR17oR18R32R20i338R21i288gR22r55gR6r80R28oR6r58R8y16:__init__fragmentR10jR11:13:1aoR1ahR30r55ghR16i-210gR30r55goR1ahR2oR3jR4:4:1aoR3jR4:5:3r7oR3jR4:1:1r15R17oR18R32R20i382R21i370gR22r16goR3jR4:1:1r92R17oR18R32R20i395R21i385gR22r93gR17oR18R32R20i395R21i370gR22r16ghR17oR18R32R20i401R21i364gR22r55gR6jR27:1:0R28oR6r58R8y8:fragmentR10jR11:13:1aoR1ahR30r55ghR16i-211gR30r55ghR8y25:h3d.pass._Copy.CopyShadery4:varsar32r13r112r92r69r57r81r125r146hg"
h3d_pass__HardwarePick_FixedColor.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey8:positiony4:typejy9:hxsl.Type:5:2i4jy12:hxsl.VecType:1:0y6:parentoR6r10R8y6:outputR10jR11:12:1ar9oR6r10R8y7:colorIDR10jR11:5:2i4r11R13r13y2:idi-5ghR16i-3gR16i-4gy1:poy4:filey76:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fpass%2FHardwarePick.hxy3:maxi258y3:mini243gy1:tr12goR3jR4:5:3jR5:1:0oR3jR4:3:1oR3jR4:5:3jR5:0:0oR3jR4:1:1r9R17oR18R19R20i277R21i262gR22r12goR3jR4:5:3r21oR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:40:0R17oR18R19R20i284R21i280gR22jR11:13:1ahgaoR3jR4:9:2oR3jR4:1:1oR6jR7:2:0R8y8:viewportR10jR11:5:2i4r11R16i-2gR17oR18R19R20i293R21i285gR22r41gajy14:hxsl.Component:0:0jR25:1:0hR17oR18R19R20i296R21i285gR22jR11:5:2i2r11goR3jR4:0:1jy10:hxsl.Const:3:1d0R17oR18R19R20i300R21i298gR22jR11:3:0goR3jR4:0:1jR26:3:1d0R17oR18R19R20i304R21i302gR22r54ghR17oR18R19R20i305R21i280gR22jR11:5:2i4r11goR3jR4:9:2oR3jR4:1:1r9R17oR18R19R20i323R21i308gR22r12gajR25:3:0hR17oR18R19R20i325R21i308gR22r54gR17oR18R19R20i325R21i280gR22r61gR17oR18R19R20i325R21i262gR22jR11:5:2i4r11gR17oR18R19R20i326R21i261gR22r74goR3jR4:8:2oR3jR4:2:1r31R17oR18R19R20i333R21i329gR22r35gaoR3jR4:9:2oR3jR4:1:1r39R17oR18R19R20i342R21i334gR22r41gajR25:2:0r67hR17oR18R19R20i345R21i334gR22jR11:5:2i2r11goR3jR4:0:1jR26:3:1d1R17oR18R19R20i349R21i347gR22r54goR3jR4:0:1jR26:3:1d1R17oR18R19R20i353R21i351gR22r54ghR17oR18R19R20i354R21i329gR22jR11:5:2i4r11gR17oR18R19R20i354R21i261gR22jR11:5:2i4r11gR17oR18R19R20i354R21i243gR22r12ghR17oR18R19R20i360R21i237gR22jR11:0:0gR6jy17:hxsl.FunctionKind:0:0y3:refoR6jR7:6:0R8y6:vertexR10jR11:13:1aoR1ahy3:retr109ghR16i-6gR30r109goR1ahR2oR3jR4:4:1aoR3jR4:5:3r7oR3jR4:1:1r15R17oR18R19R20i404R21i390gR22r16goR3jR4:1:1oR6r40R8R15R10jR11:5:2i4r11R16i-1gR17oR18R19R20i414R21i407gR22r127gR17oR18R19R20i414R21i390gR22r16ghR17oR18R19R20i420R21i384gR22r109gR6jR27:1:0R28oR6r112R8y8:fragmentR10jR11:13:1aoR1ahR30r109ghR16i-7gR30r109ghR8y33:h3d.pass._HardwarePick.FixedColory4:varsar126r39r13r111r135hg"
h3d_shader_AmbientLight.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey10:lightColory4:typejy9:hxsl.Type:5:2i3jy12:hxsl.VecType:1:0y2:idi-259gy1:poy4:filey78:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FAmbientLight.hxy3:maxi349y3:mini339gy1:tr12goR3jR4:10:3oR3jR4:1:1oR6jR7:2:0R8y8:additiveR10jR11:2:0y10:qualifiersajy17:hxsl.VarQualifier:0:1nhR13i-260gR14oR15R16R17i360R18i352gR19r19goR3jR4:1:1oR6jR7:0:0R8y12:ambientLightR10jR11:5:2i3r11y6:parentoR6r26R8y6:globalR10jR11:12:1ar25oR6r26R8y16:perPixelLightingR10r19R24r28R21ajR22:0:1nhR13i-256ghR13i-254gR13i-255gR14oR15R16R17i382R18i363gR19r27goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:39:0R14oR15R16R17i389R18i385gR19jR11:13:1ahgaoR3jR4:0:1jy10:hxsl.Const:3:1d0R14oR15R16R17i392R18i390gR19jR11:3:0ghR14oR15R16R17i393R18i385gR19jR11:5:2i3r11gR14oR15R16R17i393R18i352gR19r27gR14oR15R16R17i393R18i339gR19r12ghR14oR15R16R17i399R18i333gR19jR11:0:0gR6jy17:hxsl.FunctionKind:2:0y3:refoR6jR7:6:0R8y8:__init__R10jR11:13:1aoR1ahy3:retr58ghR13i-261gR32r58goR1ahR2oR3jR4:4:1aoR3jR4:5:3r7oR3jR4:1:1oR6r10R8y15:lightPixelColorR10jR11:5:2i3r11R13i-258gR14oR15R16R17i454R18i439gR19r73goR3jR4:10:3oR3jR4:1:1r17R14oR15R16R17i465R18i457gR19r19goR3jR4:1:1r25R14oR15R16R17i487R18i468gR19r27goR3jR4:8:2oR3jR4:2:1r38R14oR15R16R17i494R18i490gR19r42gaoR3jR4:0:1jR28:3:1d0R14oR15R16R17i497R18i495gR19r48ghR14oR15R16R17i498R18i490gR19jR11:5:2i3r11gR14oR15R16R17i498R18i457gR19r27gR14oR15R16R17i498R18i439gR19r73ghR14oR15R16R17i504R18i433gR19r58gR6r59R30oR6r61R8y16:__init__fragmentR10jR11:13:1aoR1ahR32r58ghR13i-262gR32r58goR1aoR6r10R8R9R10jR11:5:2i3r11R13i-263ghR2oR3jR4:4:1aoR3jR4:12:1oR3jR4:10:3oR3jR4:1:1r17R14oR15R16R17i578R18i570gR19r19goR3jR4:1:1r108R14oR15R16R17i591R18i581gR19r109goR3jR4:3:1oR3jR4:5:3jR5:0:0oR3jR4:1:1r25R14oR15R16R17i614R18i595gR19r27goR3jR4:5:3jR5:1:0oR3jR4:8:2oR3jR4:2:1jR27:22:0R14oR15R16R17i642R18i617gR19jR11:13:1aoR1aoR8y1:_R10r27goR8y1:bR10r48ghR32jR11:5:2i3r11ghgaoR3jR4:3:1oR3jR4:5:3jR5:3:0oR3jR4:0:1jR28:3:1i1R14oR15R16R17i619R18i618gR19r48goR3jR4:1:1r25R14oR15R16R17i641R18i622gR19r27gR14oR15R16R17i641R18i618gR19r27gR14oR15R16R17i642R18i617gR19r27goR3jR4:0:1jR28:3:1d0R14oR15R16R17i649R18i647gR19r48ghR14oR15R16R17i650R18i617gR19r138goR3jR4:1:1r108R14oR15R16R17i663R18i653gR19r109gR14oR15R16R17i663R18i617gR19jR11:5:2i3r11gR14oR15R16R17i663R18i595gR19jR11:5:2i3r11gR14oR15R16R17i664R18i594gR19r169gR14oR15R16R17i664R18i570gR19r109gR14oR15R16R17i664R18i563gR19r58ghR14oR15R16R17i670R18i557gR19r58gR6jR29:3:0R30oR6r61R8y9:calcLightR10jR11:13:1aoR1aoR8R9R10r109ghR32jR11:5:2i3r11ghR13i-264gR32r184goR1ahR2oR3jR4:4:1aoR3jR4:10:3oR3jR4:6:2jy15:haxe.macro.Unop:2:0oR3jR4:1:1r30R14oR15R16R17i728R18i705gR19r19gR14oR15R16R17i728R18i704gR19r19goR3jR4:5:3jR5:20:1r127oR3jR4:9:2oR3jR4:1:1oR6r10R8y10:pixelColorR10jR11:5:2i4r11R13i-257gR14oR15R16R17i741R18i731gR19r203gajy14:hxsl.Component:0:0jR40:1:0jR40:2:0hR14oR15R16R17i745R18i731gR19jR11:5:2i3r11goR3jR4:8:2oR3jR4:1:1r179R14oR15R16R17i758R18i749gR19r185gaoR3jR4:1:1r9R14oR15R16R17i769R18i759gR19r12ghR14oR15R16R17i770R18i749gR19r184gR14oR15R16R17i770R18i731gR19r212gnR14oR15R16R17i770R18i700gR19r58ghR14oR15R16R17i776R18i694gR19r58gR6jR29:0:0R30oR6r61R8y6:vertexR10jR11:13:1aoR1ahR32r58ghR13i-265gR32r58goR1ahR2oR3jR4:4:1aoR3jR4:10:3oR3jR4:1:1r30R14oR15R16R17i835R18i812gR19r19goR3jR4:5:3jR5:20:1r127oR3jR4:9:2oR3jR4:1:1r202R14oR15R16R17i848R18i838gR19r203gar207r208r209hR14oR15R16R17i852R18i838gR19jR11:5:2i3r11goR3jR4:8:2oR3jR4:1:1r179R14oR15R16R17i865R18i856gR19r185gaoR3jR4:1:1r72R14oR15R16R17i881R18i866gR19r73ghR14oR15R16R17i882R18i856gR19r184gR14oR15R16R17i882R18i838gR19r252gnR14oR15R16R17i882R18i808gR19r58ghR14oR15R16R17i888R18i802gR19r58gR6jR29:1:0R30oR6r61R8y8:fragmentR10jR11:13:1aoR1ahR32r58ghR13i-266gR32r58ghR8y23:h3d.shader.AmbientLighty4:varsar28r202r72r9r17r60r101r179r230r270hg"
h3d_shader_Base2d.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey14:spritePositiony4:typejy9:hxsl.Type:5:2i4jy12:hxsl.VecType:1:0y2:idi-222gy1:poy4:filey72:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FBase2d.hxy3:maxi983y3:mini969gy1:tr12goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:40:0R14oR15R16R17i990R18i986gR19jR11:13:1ahgaoR3jR4:1:1oR6jR7:1:0R8y8:positionR10jR11:5:2i2r11y6:parentoR6r25R8y5:inputR10jR11:12:1ar24oR6r25R8y2:uvR10jR11:5:2i2r11R22r27R13i-214goR6r25R8y5:colorR10jR11:5:2i4r11R22r27R13i-215ghR13i-212gR13i-213gR14oR15R16R17i1005R18i991gR19r26goR3jR4:1:1oR6jR7:2:0R8y6:zValueR10jR11:3:0R13i-220gR14oR15R16R17i1013R18i1007gR19r39goR3jR4:0:1jy10:hxsl.Const:3:1i1R14oR15R16R17i1016R18i1015gR19r39ghR14oR15R16R17i1017R18i986gR19jR11:5:2i4r11gR14oR15R16R17i1017R18i969gR19r12goR3jR4:10:3oR3jR4:1:1oR6r38R8y10:isRelativeR10jR11:2:0y10:qualifiersajy17:hxsl.VarQualifier:0:1nhR13i-227gR14oR15R16R17i1037R18i1027gR19r54goR3jR4:4:1aoR3jR4:5:3r7oR3jR4:9:2oR3jR4:1:1oR6r10R8y16:absolutePositionR10jR11:5:2i4r11R13i-223gR14oR15R16R17i1063R18i1047gR19r65gajy14:hxsl.Component:0:0hR14oR15R16R17i1065R18i1047gR19r39goR3jR4:8:2oR3jR4:2:1jR20:29:0R14oR15R16R17i1093R18i1068gR19jR11:13:1aoR1aoR8y1:_R10jR11:5:2i3r11goR8y1:bR10jR11:5:2i3r11ghy3:retr39ghgaoR3jR4:8:2oR3jR4:2:1jR20:39:0R14oR15R16R17i1072R18i1068gR19jR11:13:1ahgaoR3jR4:9:2oR3jR4:1:1r9R14oR15R16R17i1087R18i1073gR19r12gar69jR32:1:0hR14oR15R16R17i1090R18i1073gR19jR11:5:2i2r11goR3jR4:0:1jR27:3:1i1R14oR15R16R17i1092R18i1091gR19r39ghR14oR15R16R17i1093R18i1068gR19r81goR3jR4:1:1oR6r38R8y15:absoluteMatrixAR10jR11:5:2i3r11R13i-229gR14oR15R16R17i1113R18i1098gR19r111ghR14oR15R16R17i1114R18i1068gR19r39gR14oR15R16R17i1114R18i1047gR19r39goR3jR4:5:3r7oR3jR4:9:2oR3jR4:1:1r64R14oR15R16R17i1137R18i1121gR19r65gar99hR14oR15R16R17i1139R18i1121gR19r39goR3jR4:8:2oR3jR4:2:1r74R14oR15R16R17i1167R18i1142gR19jR11:13:1aoR1aoR8R33R10jR11:5:2i3r11gr82hR35r39ghgaoR3jR4:8:2oR3jR4:2:1r88R14oR15R16R17i1146R18i1142gR19r92gaoR3jR4:9:2oR3jR4:1:1r9R14oR15R16R17i1161R18i1147gR19r12gar69r99hR14oR15R16R17i1164R18i1147gR19jR11:5:2i2r11goR3jR4:0:1jR27:3:1i1R14oR15R16R17i1166R18i1165gR19r39ghR14oR15R16R17i1167R18i1142gR19r134goR3jR4:1:1oR6r38R8y15:absoluteMatrixBR10jR11:5:2i3r11R13i-230gR14oR15R16R17i1187R18i1172gR19r158ghR14oR15R16R17i1188R18i1142gR19r39gR14oR15R16R17i1188R18i1121gR19r39goR3jR4:5:3r7oR3jR4:9:2oR3jR4:1:1r64R14oR15R16R17i1211R18i1195gR19r65gajR32:2:0jR32:3:0hR14oR15R16R17i1214R18i1195gR19jR11:5:2i2r11goR3jR4:9:2oR3jR4:1:1r9R14oR15R16R17i1231R18i1217gR19r12gar171r172hR14oR15R16R17i1234R18i1217gR19jR11:5:2i2r11gR14oR15R16R17i1234R18i1195gR19r175ghR14oR15R16R17i1241R18i1040gR19jR11:0:0goR3jR4:5:3r7oR3jR4:1:1r64R14oR15R16R17i1268R18i1252gR19r65goR3jR4:1:1r9R14oR15R16R17i1285R18i1271gR19r12gR14oR15R16R17i1285R18i1252gR19r65gR14oR15R16R17i1285R18i1023gR19r188goR3jR4:5:3r7oR3jR4:1:1oR6jR7:3:0R8y12:calculatedUVR10jR11:5:2i2r11R13i-226gR14oR15R16R17i1303R18i1291gR19r204goR3jR4:10:3oR3jR4:1:1oR6r38R8y8:hasUVPosR10r54R29ajR30:0:1nhR13i-233gR14oR15R16R17i1314R18i1306gR19r54goR3jR4:5:3jR5:0:0oR3jR4:5:3jR5:1:0oR3jR4:1:1r29R14oR15R16R17i1325R18i1317gR19r30goR3jR4:9:2oR3jR4:1:1oR6r38R8y5:uvPosR10jR11:5:2i4r11R13i-234gR14oR15R16R17i1333R18i1328gR19r224gar171r172hR14oR15R16R17i1336R18i1328gR19jR11:5:2i2r11gR14oR15R16R17i1336R18i1317gR19jR11:5:2i2r11goR3jR4:9:2oR3jR4:1:1r223R14oR15R16R17i1344R18i1339gR19r224gar69r99hR14oR15R16R17i1347R18i1339gR19jR11:5:2i2r11gR14oR15R16R17i1347R18i1317gR19jR11:5:2i2r11goR3jR4:1:1r29R14oR15R16R17i1358R18i1350gR19r30gR14oR15R16R17i1358R18i1306gR19r244gR14oR15R16R17i1358R18i1291gR19r204goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y10:pixelColorR10jR11:5:2i4r11R13i-224gR14oR15R16R17i1374R18i1364gR19r255goR3jR4:10:3oR3jR4:1:1r53R14oR15R16R17i1387R18i1377gR19r54goR3jR4:5:3r217oR3jR4:1:1oR6r38R8R25R10jR11:5:2i4r11R13i-228gR14oR15R16R17i1395R18i1390gR19r265goR3jR4:1:1r31R14oR15R16R17i1409R18i1398gR19r32gR14oR15R16R17i1409R18i1390gR19jR11:5:2i4r11goR3jR4:1:1r31R14oR15R16R17i1423R18i1412gR19r32gR14oR15R16R17i1423R18i1377gR19r273gR14oR15R16R17i1423R18i1364gR19r255goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y12:textureColorR10jR11:5:2i4r11R13i-225gR14oR15R16R17i1441R18i1429gR19r284goR3jR4:8:2oR3jR4:2:1jR20:33:0R14oR15R16R17i1451R18i1444gR19jR11:13:1aoR1aoR8R33R10jR11:10:0goR8R24R10jR11:5:2i2r11ghR35jR11:5:2i4r11ghgaoR3jR4:1:1oR6r38R8y7:textureR10r296R13i-221gR14oR15R16R17i1451R18i1444gR19r296goR3jR4:1:1r202R14oR15R16R17i1468R18i1456gR19r204ghR14oR15R16R17i1469R18i1444gR19r299gR14oR15R16R17i1469R18i1429gR19r284goR3jR4:5:3jR5:20:1r217oR3jR4:1:1r254R14oR15R16R17i1485R18i1475gR19r255goR3jR4:1:1r283R14oR15R16R17i1501R18i1489gR19r284gR14oR15R16R17i1501R18i1475gR19r255ghR14oR15R16R17i1507R18i963gR19r188gR6jy17:hxsl.FunctionKind:2:0y3:refoR6jR7:6:0R8y8:__init__R10jR11:13:1aoR1ahR35r188ghR13i-240gR35r188goR1ahR2oR3jR4:4:1aoR3jR4:7:2oR6r10R8y3:tmpR10jR11:5:2i3r11R13i-243goR3jR4:8:2oR3jR4:2:1r88R14oR15R16R17i1610R18i1606gR19r92gaoR3jR4:9:2oR3jR4:1:1r64R14oR15R16R17i1627R18i1611gR19r65gar69r99hR14oR15R16R17i1630R18i1611gR19jR11:5:2i2r11goR3jR4:0:1jR27:3:1i1R14oR15R16R17i1633R18i1632gR19r39ghR14oR15R16R17i1634R18i1606gR19r338gR14oR15R16R17i1635R18i1596gR19r188goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y14:outputPositionR10jR11:5:2i4r11R13i-239gR14oR15R16R17i1654R18i1640gR19r363goR3jR4:8:2oR3jR4:2:1r17R14oR15R16R17i1661R18i1657gR19r21gaoR3jR4:8:2oR3jR4:2:1r74R14oR15R16R17i1671R18i1668gR19jR11:13:1aoR1aoR8R33R10r338gr82hR35r39ghgaoR3jR4:1:1r337R14oR15R16R17i1671R18i1668gR19r338goR3jR4:1:1oR6r38R8y13:filterMatrixAR10jR11:5:2i3r11R13i-231gR14oR15R16R17i1689R18i1676gR19r386ghR14oR15R16R17i1690R18i1668gR19r39goR3jR4:8:2oR3jR4:2:1r74R14oR15R16R17i1700R18i1697gR19jR11:13:1aoR1aoR8R33R10r338gr82hR35r39ghgaoR3jR4:1:1r337R14oR15R16R17i1700R18i1697gR19r338goR3jR4:1:1oR6r38R8y13:filterMatrixBR10jR11:5:2i3r11R13i-232gR14oR15R16R17i1718R18i1705gR19r406ghR14oR15R16R17i1719R18i1697gR19r39goR3jR4:9:2oR3jR4:1:1r64R14oR15R16R17i1742R18i1726gR19r65gar171r172hR14oR15R16R17i1745R18i1726gR19jR11:5:2i2r11ghR14oR15R16R17i1751R18i1657gR19jR11:5:2i4r11gR14oR15R16R17i1751R18i1640gR19r363goR3jR4:5:3r7oR3jR4:9:2oR3jR4:1:1r362R14oR15R16R17i1800R18i1786gR19r363gar69r99hR14oR15R16R17i1803R18i1786gR19jR11:5:2i2r11goR3jR4:5:3r217oR3jR4:3:1oR3jR4:5:3r215oR3jR4:9:2oR3jR4:1:1r362R14oR15R16R17i1821R18i1807gR19r363gar69r99hR14oR15R16R17i1824R18i1807gR19jR11:5:2i2r11goR3jR4:9:2oR3jR4:1:1oR6r38R8y8:viewportR10jR11:5:2i4r11R13i-238gR14oR15R16R17i1835R18i1827gR19r447gar69r99hR14oR15R16R17i1838R18i1827gR19jR11:5:2i2r11gR14oR15R16R17i1838R18i1807gR19jR11:5:2i2r11gR14oR15R16R17i1839R18i1806gR19r456goR3jR4:9:2oR3jR4:1:1r446R14oR15R16R17i1850R18i1842gR19r447gar171r172hR14oR15R16R17i1853R18i1842gR19jR11:5:2i2r11gR14oR15R16R17i1853R18i1806gR19jR11:5:2i2r11gR14oR15R16R17i1853R18i1786gR19r432goR3jR4:10:3oR3jR4:1:1oR6r38R8y10:pixelAlignR10r54R29ajR30:0:1nhR13i-236gR14oR15R16R17i1959R18i1949gR19r54goR3jR4:5:3jR5:20:1jR5:3:0oR3jR4:9:2oR3jR4:1:1r362R14oR15R16R17i1976R18i1962gR19r363gar69r99hR14oR15R16R17i1979R18i1962gR19jR11:5:2i2r11goR3jR4:1:1oR6r38R8y16:halfPixelInverseR10jR11:5:2i2r11R13i-237gR14oR15R16R17i1999R18i1983gR19r492gR14oR15R16R17i1999R18i1962gR19r489gnR14oR15R16R17i1999R18i1945gR19r188goR3jR4:5:3r7oR3jR4:1:1oR6r10R8R21R10jR11:5:2i4r11R22oR6r10R8y6:outputR10jR11:12:1ar501oR6r10R8R25R10jR11:5:2i4r11R22r503R13i-218ghR13i-216gR13i-217gR14oR15R16R17i2020R18i2005gR19r502goR3jR4:1:1r362R14oR15R16R17i2037R18i2023gR19r363gR14oR15R16R17i2037R18i2005gR19r502ghR14oR15R16R17i2043R18i1531gR19r188gR6jR44:0:0R45oR6r327R8y6:vertexR10jR11:13:1aoR1ahR35r188ghR13i-241gR35r188goR1ahR2oR3jR4:4:1aoR3jR4:10:3oR3jR4:5:3jR5:14:0oR3jR4:1:1oR6r38R8y9:killAlphaR10r54R29ajR30:0:1nhR13i-235gR14oR15R16R17i2088R18i2079gR19r54goR3jR4:5:3jR5:9:0oR3jR4:9:2oR3jR4:1:1r254R14oR15R16R17i2102R18i2092gR19r255gar172hR14oR15R16R17i2104R18i2092gR19r39goR3jR4:0:1jR27:3:1d0.001R14oR15R16R17i2112R18i2107gR19r39gR14oR15R16R17i2112R18i2092gR19r54gR14oR15R16R17i2112R18i2079gR19r54goR3jR4:11:0R14oR15R16R17i2122R18i2115gR19r188gnR14oR15R16R17i2122R18i2075gR19r188goR3jR4:5:3r7oR3jR4:1:1r505R14oR15R16R17i2140R18i2128gR19r506goR3jR4:1:1r254R14oR15R16R17i2153R18i2143gR19r255gR14oR15R16R17i2153R18i2128gR19r506ghR14oR15R16R17i2159R18i2069gR19r188gR6jR44:1:0R45oR6r327R8y8:fragmentR10jR11:13:1aoR1ahR35r188ghR13i-242gR35r188ghR8y17:h3d.shader.Base2dy4:varsar27r503oR6jR7:0:0R8y4:timeR10r39R13i-219gr37r303r9r64r254r283r202r53r264r110r157r385r405r209r223r531r474r491r446r362r326r518r570hg"
h3d_shader_BaseMesh.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey16:relativePositiony4:typejy9:hxsl.Type:5:2i3jy12:hxsl.VecType:1:0y2:idi-65gy1:poy4:filey74:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FBaseMesh.hxy3:maxi1269y3:mini1253gy1:tr12goR3jR4:1:1oR6jR7:1:0R8y8:positionR10jR11:5:2i3r11y6:parentoR6r17R8y5:inputR10jR11:12:1ar16oR6r17R8y6:normalR10jR11:5:2i3r11R21r19R13i-59ghR13i-57gR13i-58gR14oR15R16R17i1286R18i1272gR19r18gR14oR15R16R17i1286R18i1253gR19r12goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y19:transformedPositionR10jR11:5:2i3r11R13i-66gR14oR15R16R17i1311R18i1292gR19r31goR3jR4:5:3jR5:1:0oR3jR4:1:1r9R14oR15R16R17i1330R18i1314gR19r12goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:50:0R14oR15R16R17i1349R18i1333gR19jR11:13:1ahgaoR3jR4:1:1oR6jR7:0:0R8y9:modelViewR10jR11:7:0R21oR6r49R8y6:globalR10jR11:12:1aoR6r49R8y4:timeR10jR11:3:0R21r51R13i-53goR6r49R8y9:pixelSizeR10jR11:5:2i2r11R21r51R13i-54gr48oR6r49R8y16:modelViewInverseR10r50R21r51y10:qualifiersajy17:hxsl.VarQualifier:3:0hR13i-56ghR13i-52gR31ar59hR13i-55gR14oR15R16R17i1349R18i1333gR19r50ghR14oR15R16R17i1358R18i1333gR19jR11:8:0gR14oR15R16R17i1358R18i1314gR19jR11:5:2i3r11gR14oR15R16R17i1358R18i1292gR19r31goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y17:projectedPositionR10jR11:5:2i4r11R13i-69gR14oR15R16R17i1381R18i1364gR19r75goR3jR4:5:3r35oR3jR4:8:2oR3jR4:2:1jR25:40:0R14oR15R16R17i1388R18i1384gR19jR11:13:1ahgaoR3jR4:1:1r30R14oR15R16R17i1408R18i1389gR19r31goR3jR4:0:1jy10:hxsl.Const:3:1i1R14oR15R16R17i1411R18i1410gR19r54ghR14oR15R16R17i1412R18i1384gR19jR11:5:2i4r11goR3jR4:1:1oR6r49R8y8:viewProjR10r50R21oR6r49R8y6:cameraR10jR11:12:1aoR6r49R8y4:viewR10r50R21r99R13i-43goR6r49R8y4:projR10r50R21r99R13i-44goR6r49R8R20R10jR11:5:2i3r11R21r99R13i-45goR6r49R8y8:projDiagR10jR11:5:2i3r11R21r99R13i-46gr98oR6r49R8y15:inverseViewProjR10r50R21r99R13i-48goR6r49R8y5:zNearR10r54R21r99R13i-49goR6r49R8y4:zFarR10r54R21r99R13i-50goR6jR7:3:0R8y3:dirR10jR11:5:2i3r11R21r99R13i-51ghR13i-42gR13i-47gR14oR15R16R17i1430R18i1415gR19r50gR14oR15R16R17i1430R18i1384gR19jR11:5:2i4r11gR14oR15R16R17i1430R18i1364gR19r75goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y17:transformedNormalR10jR11:5:2i3r11R13i-68gR14oR15R16R17i1453R18i1436gR19r124goR3jR4:8:2oR3jR4:2:1jR25:31:0R14oR15R16R17i1496R18i1456gR19jR11:13:1aoR1aoR8y1:_R10r69ghy3:retr69ghgaoR3jR4:3:1oR3jR4:5:3r35oR3jR4:1:1r21R14oR15R16R17i1469R18i1457gR19r22goR3jR4:8:2oR3jR4:2:1jR25:48:0R14oR15R16R17i1488R18i1472gR19jR11:13:1ahgaoR3jR4:1:1r48R14oR15R16R17i1488R18i1472gR19r50ghR14oR15R16R17i1495R18i1472gR19jR11:6:0gR14oR15R16R17i1495R18i1457gR19r69gR14oR15R16R17i1496R18i1456gR19r69ghR14oR15R16R17i1508R18i1456gR19r69gR14oR15R16R17i1508R18i1436gR19r124goR3jR4:5:3r7oR3jR4:1:1r110R14oR15R16R17i1524R18i1514gR19r112goR3jR4:8:2oR3jR4:2:1r129R14oR15R16R17i1566R18i1527gR19jR11:13:1aoR1aoR8R45R10jR11:5:2i3r11ghR46r69ghgaoR3jR4:3:1oR3jR4:5:3jR5:3:0oR3jR4:1:1r103R14oR15R16R17i1543R18i1528gR19r104goR3jR4:1:1r30R14oR15R16R17i1565R18i1546gR19r31gR14oR15R16R17i1565R18i1528gR19r177gR14oR15R16R17i1566R18i1527gR19r177ghR14oR15R16R17i1578R18i1527gR19r69gR14oR15R16R17i1578R18i1514gR19r112goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y10:pixelColorR10jR11:5:2i4r11R13i-70gR14oR15R16R17i1594R18i1584gR19r200goR3jR4:1:1oR6jR7:2:0R8y5:colorR10jR11:5:2i4r11R13i-75gR14oR15R16R17i1602R18i1597gR19r206gR14oR15R16R17i1602R18i1584gR19r200goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y9:specPowerR10r54R13i-73gR14oR15R16R17i1617R18i1608gR19r54goR3jR4:1:1oR6r205R8y13:specularPowerR10r54R31ajR32:7:2d0d100hR13i-76gR14oR15R16R17i1633R18i1620gR19r54gR14oR15R16R17i1633R18i1608gR19r54goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y9:specColorR10jR11:5:2i3r11R13i-74gR14oR15R16R17i1648R18i1639gR19r227goR3jR4:5:3r35oR3jR4:1:1oR6r205R8y13:specularColorR10jR11:5:2i3r11R13i-78gR14oR15R16R17i1664R18i1651gR19r233goR3jR4:1:1oR6r205R8y14:specularAmountR10r54R31ajR32:7:2d0d10hR13i-77gR14oR15R16R17i1681R18i1667gR19r54gR14oR15R16R17i1681R18i1651gR19r233gR14oR15R16R17i1681R18i1639gR19r227goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y8:screenUVR10jR11:5:2i2r11R13i-72gR14oR15R16R17i1695R18i1687gR19r249goR3jR4:5:3jR5:0:0oR3jR4:5:3r35oR3jR4:3:1oR3jR4:5:3jR5:2:0oR3jR4:9:2oR3jR4:1:1r74R14oR15R16R17i1716R18i1699gR19r75gajy14:hxsl.Component:0:0jR55:1:0hR14oR15R16R17i1719R18i1699gR19jR11:5:2i2r11goR3jR4:9:2oR3jR4:1:1r74R14oR15R16R17i1739R18i1722gR19r75gajR55:3:0hR14oR15R16R17i1741R18i1722gR19r54gR14oR15R16R17i1741R18i1699gR19r267gR14oR15R16R17i1742R18i1698gR19r267goR3jR4:8:2oR3jR4:2:1jR25:38:0R14oR15R16R17i1749R18i1745gR19jR11:13:1ahgaoR3jR4:0:1jR34:3:1d0.5R14oR15R16R17i1753R18i1750gR19r54goR3jR4:0:1jR34:3:1d-0.5R14oR15R16R17i1759R18i1755gR19r54ghR14oR15R16R17i1760R18i1745gR19jR11:5:2i2r11gR14oR15R16R17i1760R18i1698gR19jR11:5:2i2r11goR3jR4:0:1jR34:3:1d0.5R14oR15R16R17i1766R18i1763gR19r54gR14oR15R16R17i1766R18i1698gR19r301gR14oR15R16R17i1766R18i1687gR19r249goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y5:depthR10r54R13i-71gR14oR15R16R17i1777R18i1772gR19r54goR3jR4:5:3r257oR3jR4:9:2oR3jR4:1:1r74R14oR15R16R17i1797R18i1780gR19r75gajR55:2:0hR14oR15R16R17i1799R18i1780gR19r54goR3jR4:9:2oR3jR4:1:1r74R14oR15R16R17i1819R18i1802gR19r75gar273hR14oR15R16R17i1821R18i1802gR19r54gR14oR15R16R17i1821R18i1780gR19r54gR14oR15R16R17i1821R18i1772gR19r54ghR14oR15R16R17i1827R18i1247gR19jR11:0:0gR6jy17:hxsl.FunctionKind:2:0y3:refoR6jR7:6:0R8y8:__init__R10jR11:13:1aoR1ahR46r337ghR13i-79gR46r337goR1ahR2oR3jR4:4:1aoR3jR4:5:3r7oR3jR4:1:1r123R14oR15R16R17i1884R18i1867gR19r124goR3jR4:8:2oR3jR4:2:1r129R14oR15R16R17i1904R18i1887gR19jR11:13:1aoR1aoR8R45R10r124ghR46r69ghgaoR3jR4:1:1r123R14oR15R16R17i1904R18i1887gR19r124ghR14oR15R16R17i1916R18i1887gR19r69gR14oR15R16R17i1916R18i1867gR19r124goR3jR4:5:3r7oR3jR4:1:1r248R14oR15R16R17i2025R18i2017gR19r249goR3jR4:5:3r253oR3jR4:5:3r35oR3jR4:3:1oR3jR4:5:3r257oR3jR4:9:2oR3jR4:1:1r74R14oR15R16R17i2046R18i2029gR19r75gar263r264hR14oR15R16R17i2049R18i2029gR19jR11:5:2i2r11goR3jR4:9:2oR3jR4:1:1r74R14oR15R16R17i2069R18i2052gR19r75gar273hR14oR15R16R17i2071R18i2052gR19r54gR14oR15R16R17i2071R18i2029gR19r385gR14oR15R16R17i2072R18i2028gR19r385goR3jR4:8:2oR3jR4:2:1r282R14oR15R16R17i2079R18i2075gR19r286gaoR3jR4:0:1jR34:3:1d0.5R14oR15R16R17i2083R18i2080gR19r54goR3jR4:0:1jR34:3:1d-0.5R14oR15R16R17i2089R18i2085gR19r54ghR14oR15R16R17i2090R18i2075gR19jR11:5:2i2r11gR14oR15R16R17i2090R18i2028gR19jR11:5:2i2r11goR3jR4:0:1jR34:3:1d0.5R14oR15R16R17i2096R18i2093gR19r54gR14oR15R16R17i2096R18i2028gR19r415gR14oR15R16R17i2096R18i2017gR19r249goR3jR4:5:3r7oR3jR4:1:1r312R14oR15R16R17i2107R18i2102gR19r54goR3jR4:5:3r257oR3jR4:9:2oR3jR4:1:1r74R14oR15R16R17i2127R18i2110gR19r75gar321hR14oR15R16R17i2129R18i2110gR19r54goR3jR4:9:2oR3jR4:1:1r74R14oR15R16R17i2149R18i2132gR19r75gar273hR14oR15R16R17i2151R18i2132gR19r54gR14oR15R16R17i2151R18i2110gR19r54gR14oR15R16R17i2151R18i2102gR19r54goR3jR4:5:3r7oR3jR4:1:1r213R14oR15R16R17i2244R18i2235gR19r54goR3jR4:1:1r217R14oR15R16R17i2260R18i2247gR19r54gR14oR15R16R17i2260R18i2235gR19r54goR3jR4:5:3r7oR3jR4:1:1r226R14oR15R16R17i2275R18i2266gR19r227goR3jR4:5:3r35oR3jR4:1:1r232R14oR15R16R17i2291R18i2278gR19r233goR3jR4:1:1r237R14oR15R16R17i2308R18i2294gR19r54gR14oR15R16R17i2308R18i2278gR19r233gR14oR15R16R17i2308R18i2266gR19r227ghR14oR15R16R17i2314R18i1861gR19r337gR6r338R58oR6r340R8y16:__init__fragmentR10jR11:13:1aoR1ahR46r337ghR13i-80gR46r337goR1ahR2oR3jR4:4:1aoR3jR4:5:3r7oR3jR4:1:1oR6r10R8R20R10jR11:5:2i4r11R21oR6r10R8y6:outputR10jR11:12:1ar484oR6r10R8R48R10jR11:5:2i4r11R21r486R13i-62goR6r10R8R56R10r54R21r486R13i-63goR6r10R8R23R10jR11:5:2i3r11R21r486R13i-64ghR13i-60gR13i-61gR14oR15R16R17i2359R18i2344gR19r485goR3jR4:1:1r74R14oR15R16R17i2379R18i2362gR19r75gR14oR15R16R17i2379R18i2344gR19r485goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y24:pixelTransformedPositionR10jR11:5:2i3r11R13i-67gR14oR15R16R17i2409R18i2385gR19r504goR3jR4:1:1r30R14oR15R16R17i2431R18i2412gR19r31gR14oR15R16R17i2431R18i2385gR19r504ghR14oR15R16R17i2437R18i2338gR19r337gR6jR57:0:0R58oR6r340R8y6:vertexR10jR11:13:1aoR1ahR46r337ghR13i-81gR46r337goR1ahR2oR3jR4:4:1aoR3jR4:5:3r7oR3jR4:1:1r488R14oR15R16R17i2481R18i2469gR19r489goR3jR4:1:1r199R14oR15R16R17i2494R18i2484gR19r200gR14oR15R16R17i2494R18i2469gR19r489goR3jR4:5:3r7oR3jR4:1:1r490R14oR15R16R17i2512R18i2500gR19r54goR3jR4:1:1r312R14oR15R16R17i2520R18i2515gR19r54gR14oR15R16R17i2520R18i2500gR19r54goR3jR4:5:3r7oR3jR4:1:1r491R14oR15R16R17i2539R18i2526gR19r492goR3jR4:1:1r123R14oR15R16R17i2559R18i2542gR19r124gR14oR15R16R17i2559R18i2526gR19r492ghR14oR15R16R17i2565R18i2463gR19r337gR6jR57:1:0R58oR6r340R8y8:fragmentR10jR11:13:1aoR1ahR46r337ghR13i-82gR46r337ghR8y19:h3d.shader.BaseMeshy4:varsar99r51r19r486r9r30r503r123r74r199r312r248r213r226r204r217r237r232r339r473r515r554hg"
h3d_shader_Blur.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey8:positiony4:typejy9:hxsl.Type:5:2i4jy12:hxsl.VecType:1:0y6:parentoR6r10R8y6:outputR10jR11:12:1ar9oR6r10R8y5:colorR10jR11:5:2i4r11R13r13y2:idi-280ghR16i-278gR16i-279gy1:poy4:filey78:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxy3:maxi262y3:mini247gy1:tr12goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:40:0R17oR18R19R20i269R21i265gR22jR11:13:1ahgaoR3jR4:1:1oR6jR7:1:0R8R9R10jR11:5:2i2r11R13oR6r30R8y5:inputR10jR11:12:1ar29oR6r30R8y2:uvR10jR11:5:2i2r11R13r32R16i-277ghR16i-275gR16i-276gR17oR18R19R20i284R21i270gR22r31goR3jR4:0:1jy10:hxsl.Const:3:1zR17oR18R19R20i287R21i286gR22jR11:3:0goR3jR4:0:1jR26:3:1i1R17oR18R19R20i290R21i289gR22r43ghR17oR18R19R20i291R21i265gR22jR11:5:2i4r11gR17oR18R19R20i291R21i247gR22r12ghR17oR18R19R20i297R21i241gR22jR11:0:0gR6jy17:hxsl.FunctionKind:0:0y3:refoR6jR7:6:0R8y6:vertexR10jR11:13:1aoR1ahy3:retr55ghR16i-294gR30r55goR1ahR2oR3jR4:4:1aoR3jR4:10:3oR3jR4:1:1oR6jR7:2:0R8y16:isDepthDependantR10jR11:2:0y10:qualifiersajy17:hxsl.VarQualifier:0:1nhR16i-291gR17oR18y70:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FBlur.hxR20i638R21i622gR22r71goR3jR4:4:1aoR3jR4:7:2oR6r10R8y4:pcurR10jR11:5:2i3r11R16i-298goR3jR4:8:2oR3jR4:1:1oR6r58R8y11:getPositionR10jR11:13:1aoR1aoR8R25R10jR11:5:2i2r11ghR30r80ghR16i-297gR17oR18R34R20i670R21i659gR22r89gaoR3jR4:1:1r34R17oR18R34R20i679R21i671gR22r35ghR17oR18R34R20i680R21i659gR22r80gR17oR18R34R20i681R21i648gR22r55goR3jR4:7:2oR6r10R8y4:ccurR10jR11:5:2i4r11R16i-299goR3jR4:8:2oR3jR4:2:1jR23:33:0R17oR18R34R20i705R21i698gR22jR11:13:1aoR1aoR8y1:_R10jR11:10:0goR8R25R10jR11:5:2i2r11ghR30r102ghgaoR3jR4:1:1oR6r70R8y7:textureR10r112R16i-282gR17oR18R34R20i705R21i698gR22r112goR3jR4:1:1r34R17oR18R34R20i718R21i710gR22r35ghR17oR18R34R20i719R21i698gR22r102gR17oR18R34R20i720R21i687gR22r55goR3jR4:7:2oR6r10R8R15R10jR11:5:2i4r11R16i-300goR3jR4:8:2oR3jR4:2:1r22R17oR18R34R20i742R21i738gR22r26gaoR3jR4:0:1jR26:3:1zR17oR18R34R20i744R21i743gR22r43goR3jR4:0:1jR26:3:1zR17oR18R34R20i747R21i746gR22r43goR3jR4:0:1jR26:3:1zR17oR18R34R20i750R21i749gR22r43goR3jR4:0:1jR26:3:1zR17oR18R34R20i753R21i752gR22r43ghR17oR18R34R20i754R21i738gR22r130gR17oR18R34R20i755R21i726gR22r55goR3jR4:7:2oR6r10R8y4:ncurR10jR11:5:2i3r11R16i-301goR3jR4:8:2oR3jR4:2:1jR23:55:0R17oR18R34R20i784R21i772gR22jR11:13:1aoR1aoR8y5:valueR10jR11:5:2i4r11ghR30r158ghgaoR3jR4:8:2oR3jR4:2:1r105R17oR18R34R20i798R21i785gR22jR11:13:1aoR1aoR8R38R10r112gr113hR30r102ghgaoR3jR4:1:1oR6r70R8y13:normalTextureR10r112R16i-293gR17oR18R34R20i798R21i785gR22r112goR3jR4:1:1r34R17oR18R34R20i811R21i803gR22r35ghR17oR18R34R20i812R21i785gR22r102ghR17oR18R34R20i813R21i772gR22r158gR17oR18R34R20i814R21i761gR22r55goR3jR4:20:3y6:unrollahoR3jR4:13:3oR6r10R8y1:iR10jR11:1:0R16i-302goR3jR4:5:3jR5:21:0oR3jR4:5:3jR5:0:0oR3jR4:6:2jy15:haxe.macro.Unop:3:0oR3jR4:1:1oR6r70R8y7:QualityR10r198R32ajR33:0:1nhR16i-284gR17oR18R34R20i846R21i839gR22r198gR17oR18R34R20i846R21i838gR22r198goR3jR4:0:1jR26:2:1i1R17oR18R34R20i853R21i849gR22r198gR17oR18R34R20i853R21i838gR22r198goR3jR4:1:1r206R17oR18R34R20i860R21i853gR22r198gR17oR18R34R20i860R21i838gR22jR11:14:2r198jy13:hxsl.SizeDecl:0:1zgoR3jR4:4:1aoR3jR4:7:2oR6r10R8R25R10jR11:5:2i2r11R16i-303goR3jR4:5:3r202oR3jR4:1:1r34R17oR18R34R20i888R21i880gR22r35goR3jR4:5:3jR5:1:0oR3jR4:1:1oR6r70R8y5:pixelR10jR11:5:2i2r11R16i-287gR17oR18R34R20i896R21i891gR22r239goR3jR4:8:2oR3jR4:2:1jR23:36:0R17oR18R34R20i904R21i899gR22jR11:13:1aoR1aoR8R41R10r198ghR30r43ghgaoR3jR4:1:1r197R17oR18R34R20i906R21i905gR22r198ghR17oR18R34R20i907R21i899gR22r43gR17oR18R34R20i907R21i891gR22r239gR17oR18R34R20i907R21i880gR22r230gR17oR18R34R20i908R21i871gR22r55goR3jR4:7:2oR6r10R8y1:cR10r102R16i-304goR3jR4:8:2oR3jR4:2:1r105R17oR18R34R20i930R21i923gR22jR11:13:1aoR1aoR8R38R10r112gr113hR30r102ghgaoR3jR4:1:1r118R17oR18R34R20i930R21i923gR22r112goR3jR4:1:1r229R17oR18R34R20i937R21i935gR22r230ghR17oR18R34R20i938R21i923gR22r102gR17oR18R34R20i939R21i915gR22r55goR3jR4:7:2oR6r10R8R17R10r80R16i-305goR3jR4:8:2oR3jR4:1:1r83R17oR18R34R20i965R21i954gR22r89gaoR3jR4:1:1r229R17oR18R34R20i968R21i966gR22r230ghR17oR18R34R20i969R21i954gR22r80gR17oR18R34R20i970R21i946gR22r55goR3jR4:7:2oR6r10R8y1:dR10r43R16i-306goR3jR4:8:2oR3jR4:2:1jR23:29:0R17oR18R34R20i995R21i985gR22jR11:13:1aoR1aoR8R38R10jR11:5:2i3r11goR8y1:bR10jR11:5:2i3r11ghR30r43ghgaoR3jR4:3:1oR3jR4:5:3jR5:3:0oR3jR4:1:1r287R17oR18R34R20i987R21i986gR22r80goR3jR4:1:1r79R17oR18R34R20i994R21i990gR22r80gR17oR18R34R20i994R21i986gR22r311gR17oR18R34R20i995R21i985gR22r311goR3jR4:5:3r318oR3jR4:1:1r287R17oR18R34R20i1001R21i1000gR22r80goR3jR4:1:1r79R17oR18R34R20i1008R21i1004gR22r80gR17oR18R34R20i1008R21i1000gR22jR11:5:2i3r11ghR17oR18R34R20i1009R21i985gR22r43gR17oR18R34R20i1010R21i977gR22r55goR3jR4:7:2oR6r10R8y1:nR10r158R16i-307goR3jR4:8:2oR3jR4:2:1r161R17oR18R34R20i1037R21i1025gR22r169gaoR3jR4:8:2oR3jR4:2:1r105R17oR18R34R20i1051R21i1038gR22jR11:13:1aoR1aoR8R38R10r112gr113hR30r102ghgaoR3jR4:1:1r182R17oR18R34R20i1051R21i1038gR22r112goR3jR4:1:1r229R17oR18R34R20i1058R21i1056gR22r230ghR17oR18R34R20i1059R21i1038gR22r102ghR17oR18R34R20i1060R21i1025gR22r158gR17oR18R34R20i1061R21i1017gR22r55goR3jR4:5:3r7oR3jR4:1:1r265R17oR18R34R20i1071R21i1070gR22r102goR3jR4:8:2oR3jR4:2:1jR23:24:0R17oR18R34R20i1077R21i1074gR22jR11:13:1aoR1aoR8y1:xR10r102goR8y1:yR10r102goR8y1:aR10r43ghR30r102ghgaoR3jR4:1:1r101R17oR18R34R20i1082R21i1078gR22r102goR3jR4:1:1r265R17oR18R34R20i1085R21i1084gR22r102goR3jR4:8:2oR3jR4:2:1r304R17oR18R34R20i1091R21i1087gR22jR11:13:1aoR1aoR8R38R10r158gr312hR30r43ghgaoR3jR4:1:1r157R17oR18R34R20i1091R21i1087gR22r158goR3jR4:1:1r344R17oR18R34R20i1097R21i1096gR22r158ghR17oR18R34R20i1098R21i1087gR22r43ghR17oR18R34R20i1099R21i1074gR22r102gR17oR18R34R20i1099R21i1070gR22r102goR3jR4:5:3r7oR3jR4:1:1r265R17oR18R34R20i1108R21i1107gR22r102goR3jR4:8:2oR3jR4:2:1r378R17oR18R34R20i1114R21i1111gR22jR11:13:1ar382hgaoR3jR4:1:1r265R17oR18R34R20i1116R21i1115gR22r102goR3jR4:1:1r101R17oR18R34R20i1122R21i1118gR22r102goR3jR4:8:2oR3jR4:2:1jR23:21:0R17oR18R34R20i1154R21i1124gR22jR11:13:1aoR1aoR8R38R10r43goR8R51R10r43ghR30r43ghgaoR3jR4:3:1oR3jR4:5:3r236oR3jR4:8:2oR3jR4:2:1jR23:22:0R17oR18R34R20i1136R21i1125gR22jR11:13:1aoR1aoR8R38R10r43gr443hR30r43ghgaoR3jR4:3:1oR3jR4:5:3r318oR3jR4:1:1r301R17oR18R34R20i1127R21i1126gR22r43goR3jR4:0:1jR26:3:1d0.001R17oR18R34R20i1135R21i1130gR22r43gR17oR18R34R20i1135R21i1126gR22r43gR17oR18R34R20i1136R21i1125gR22r43goR3jR4:0:1jR26:3:1d0R17oR18R34R20i1143R21i1141gR22r43ghR17oR18R34R20i1144R21i1125gR22r43goR3jR4:0:1jR26:3:1i100000R17oR18R34R20i1153R21i1147gR22r43gR17oR18R34R20i1153R21i1125gR22r43gR17oR18R34R20i1154R21i1124gR22r43goR3jR4:0:1jR26:3:1d1R17oR18R34R20i1161R21i1159gR22r43ghR17oR18R34R20i1162R21i1124gR22r43ghR17oR18R34R20i1163R21i1111gR22r102gR17oR18R34R20i1163R21i1107gR22r102goR3jR4:5:3jR5:20:1r202oR3jR4:1:1r129R17oR18R34R20i1176R21i1171gR22r130goR3jR4:5:3r236oR3jR4:1:1r265R17oR18R34R20i1181R21i1180gR22r102goR3jR4:16:2oR3jR4:1:1oR6r70R8y6:valuesR10jR11:14:2r43jR47:1:1r206R16i-286gR17oR18R34R20i1190R21i1184gR22r509goR3jR4:10:3oR3jR4:5:3jR5:9:0oR3jR4:1:1r197R17oR18R34R20i1192R21i1191gR22r198goR3jR4:0:1jR26:2:1zR17oR18R34R20i1196R21i1195gR22r198gR17oR18R34R20i1196R21i1191gR22r71goR3jR4:6:2r204oR3jR4:1:1r197R17oR18R34R20i1201R21i1200gR22r198gR17oR18R34R20i1201R21i1199gR22r198goR3jR4:1:1r197R17oR18R34R20i1205R21i1204gR22r198gR17oR18R34R20i1205R21i1191gR22r198gR17oR18R34R20i1206R21i1184gR22r43gR17oR18R34R20i1206R21i1180gR22r102gR17oR18R34R20i1206R21i1171gR22r130ghR17oR18R34R20i1214R21i863gR22r55gR17oR18R34R20i1214R21i828gR22r55gR17oR18R34R20i1214R21i821gR22r55goR3jR4:5:3r7oR3jR4:1:1r15R17oR18R34R20i1232R21i1220gR22r16goR3jR4:1:1r129R17oR18R34R20i1240R21i1235gR22r130gR17oR18R34R20i1240R21i1220gR22r16ghR17oR18R34R20i1247R21i641gR22r55goR3jR4:10:3oR3jR4:1:1oR6r70R8y7:isDepthR10r71R32ajR33:0:1nhR16i-285gR17oR18R34R20i1268R21i1261gR22r71goR3jR4:4:1aoR3jR4:7:2oR6r10R8y3:valR10r43R16i-308goR3jR4:0:1jR26:3:1d0R17oR18R34R20i1290R21i1288gR22r43gR17oR18R34R20i1291R21i1278gR22r55goR3jR4:20:3R43ahoR3jR4:13:3oR6r10R8R44R10r198R16i-309goR3jR4:5:3r200oR3jR4:5:3r202oR3jR4:6:2r204oR3jR4:1:1r206R17oR18R34R20i1323R21i1316gR22r198gR17oR18R34R20i1323R21i1315gR22r198goR3jR4:0:1jR26:2:1i1R17oR18R34R20i1330R21i1326gR22r198gR17oR18R34R20i1330R21i1315gR22r198goR3jR4:1:1r206R17oR18R34R20i1337R21i1330gR22r198gR17oR18R34R20i1337R21i1315gR22jR11:14:2r198jR47:0:1zgoR3jR4:5:3jR5:20:1r202oR3jR4:1:1r568R17oR18R34R20i1349R21i1346gR22r43goR3jR4:5:3r236oR3jR4:8:2oR3jR4:2:1jR23:53:0R17oR18R34R20i1359R21i1353gR22jR11:13:1aoR1aoR8R41R10jR11:5:2i4r11ghR30r43ghgaoR3jR4:8:2oR3jR4:2:1r105R17oR18R34R20i1367R21i1360gR22jR11:13:1aoR1aoR8R38R10r112gr113hR30r102ghgaoR3jR4:1:1r118R17oR18R34R20i1367R21i1360gR22r112goR3jR4:5:3r202oR3jR4:1:1r34R17oR18R34R20i1380R21i1372gR22r35goR3jR4:5:3r236oR3jR4:1:1r238R17oR18R34R20i1388R21i1383gR22r239goR3jR4:8:2oR3jR4:2:1r244R17oR18R34R20i1396R21i1391gR22jR11:13:1ar248hgaoR3jR4:1:1r578R17oR18R34R20i1398R21i1397gR22r198ghR17oR18R34R20i1399R21i1391gR22r43gR17oR18R34R20i1399R21i1383gR22r239gR17oR18R34R20i1399R21i1372gR22jR11:5:2i2r11ghR17oR18R34R20i1400R21i1360gR22r102ghR17oR18R34R20i1401R21i1353gR22r43goR3jR4:16:2oR3jR4:1:1r507R17oR18R34R20i1410R21i1404gR22r509goR3jR4:10:3oR3jR4:5:3r514oR3jR4:1:1r578R17oR18R34R20i1412R21i1411gR22r198goR3jR4:0:1jR26:2:1zR17oR18R34R20i1416R21i1415gR22r198gR17oR18R34R20i1416R21i1411gR22r71goR3jR4:6:2r204oR3jR4:1:1r578R17oR18R34R20i1421R21i1420gR22r198gR17oR18R34R20i1421R21i1419gR22r198goR3jR4:1:1r578R17oR18R34R20i1425R21i1424gR22r198gR17oR18R34R20i1425R21i1411gR22r198gR17oR18R34R20i1426R21i1404gR22r43gR17oR18R34R20i1426R21i1353gR22r43gR17oR18R34R20i1426R21i1346gR22r43gR17oR18R34R20i1426R21i1305gR22r55gR17oR18R34R20i1426R21i1298gR22r55goR3jR4:5:3r7oR3jR4:1:1r15R17oR18R34R20i1445R21i1433gR22r16goR3jR4:8:2oR3jR4:2:1jR23:52:0R17oR18R34R20i1452R21i1448gR22jR11:13:1aoR1aoR8R41R10r43ghR30jR11:5:2i4r11ghgaoR3jR4:8:2oR3jR4:2:1r436R17oR18R34R20i1456R21i1453gR22jR11:13:1aoR1aoR8R38R10r43gr443hR30r43ghgaoR3jR4:1:1r568R17oR18R34R20i1456R21i1453gR22r43goR3jR4:0:1jR26:3:1d0.9999999R17oR18R34R20i1470R21i1461gR22r43ghR17oR18R34R20i1471R21i1453gR22r43ghR17oR18R34R20i1472R21i1448gR22r709gR17oR18R34R20i1472R21i1433gR22r16ghR17oR18R34R20i1479R21i1271gR22r55goR3jR4:4:1aoR3jR4:7:2oR6r10R8R15R10jR11:5:2i4r11R16i-310goR3jR4:8:2oR3jR4:2:1r22R17oR18R34R20i1508R21i1504gR22r26gaoR3jR4:0:1jR26:3:1zR17oR18R34R20i1510R21i1509gR22r43goR3jR4:0:1jR26:3:1zR17oR18R34R20i1513R21i1512gR22r43goR3jR4:0:1jR26:3:1zR17oR18R34R20i1516R21i1515gR22r43goR3jR4:0:1jR26:3:1zR17oR18R34R20i1519R21i1518gR22r43ghR17oR18R34R20i1520R21i1504gR22r741gR17oR18R34R20i1521R21i1492gR22r55goR3jR4:20:3R43ahoR3jR4:13:3oR6r10R8R44R10r198R16i-311goR3jR4:5:3r200oR3jR4:5:3r202oR3jR4:6:2r204oR3jR4:1:1r206R17oR18R34R20i1553R21i1546gR22r198gR17oR18R34R20i1553R21i1545gR22r198goR3jR4:0:1jR26:2:1i1R17oR18R34R20i1560R21i1556gR22r198gR17oR18R34R20i1560R21i1545gR22r198goR3jR4:1:1r206R17oR18R34R20i1567R21i1560gR22r198gR17oR18R34R20i1567R21i1545gR22jR11:14:2r198jR47:0:1zgoR3jR4:5:3jR5:20:1r202oR3jR4:1:1r740R17oR18R34R20i1581R21i1576gR22r741goR3jR4:5:3r236oR3jR4:8:2oR3jR4:2:1r105R17oR18R34R20i1592R21i1585gR22jR11:13:1aoR1aoR8R38R10r112gr113hR30r102ghgaoR3jR4:1:1r118R17oR18R34R20i1592R21i1585gR22r112goR3jR4:5:3r202oR3jR4:1:1r34R17oR18R34R20i1605R21i1597gR22r35goR3jR4:5:3r236oR3jR4:1:1r238R17oR18R34R20i1613R21i1608gR22r239goR3jR4:8:2oR3jR4:2:1r244R17oR18R34R20i1621R21i1616gR22jR11:13:1ar248hgaoR3jR4:1:1r770R17oR18R34R20i1623R21i1622gR22r198ghR17oR18R34R20i1624R21i1616gR22r43gR17oR18R34R20i1624R21i1608gR22r239gR17oR18R34R20i1624R21i1597gR22jR11:5:2i2r11ghR17oR18R34R20i1625R21i1585gR22r102goR3jR4:16:2oR3jR4:1:1r507R17oR18R34R20i1634R21i1628gR22r509goR3jR4:10:3oR3jR4:5:3r514oR3jR4:1:1r770R17oR18R34R20i1636R21i1635gR22r198goR3jR4:0:1jR26:2:1zR17oR18R34R20i1640R21i1639gR22r198gR17oR18R34R20i1640R21i1635gR22r71goR3jR4:6:2r204oR3jR4:1:1r770R17oR18R34R20i1645R21i1644gR22r198gR17oR18R34R20i1645R21i1643gR22r198goR3jR4:1:1r770R17oR18R34R20i1649R21i1648gR22r198gR17oR18R34R20i1649R21i1635gR22r198gR17oR18R34R20i1650R21i1628gR22r43gR17oR18R34R20i1650R21i1585gR22r102gR17oR18R34R20i1650R21i1576gR22r741gR17oR18R34R20i1650R21i1535gR22r55gR17oR18R34R20i1650R21i1528gR22r55goR3jR4:5:3r7oR3jR4:1:1r15R17oR18R34R20i1669R21i1657gR22r16goR3jR4:1:1r740R17oR18R34R20i1677R21i1672gR22r741gR17oR18R34R20i1677R21i1657gR22r16ghR17oR18R34R20i1684R21i1485gR22r55gR17oR18R34R20i1684R21i1257gR22r55gR17oR18R34R20i1684R21i618gR22r55goR3jR4:10:3oR3jR4:1:1oR6r70R8y13:hasFixedColorR10r71R32ajR33:0:1nhR16i-288gR17oR18R34R20i1706R21i1693gR22r71goR3jR4:4:1aoR3jR4:5:3r7oR3jR4:9:2oR3jR4:1:1r15R17oR18R34R20i1728R21i1716gR22r16gajy14:hxsl.Component:0:0jR60:1:0jR60:2:0hR17oR18R34R20i1732R21i1716gR22jR11:5:2i3r11goR3jR4:9:2oR3jR4:1:1oR6r70R8y10:fixedColorR10jR11:5:2i4r11R16i-290gR17oR18R34R20i1745R21i1735gR22r913gar904r905r906hR17oR18R34R20i1749R21i1735gR22jR11:5:2i3r11gR17oR18R34R20i1749R21i1716gR22r909goR3jR4:10:3oR3jR4:1:1oR6r70R8y16:smoothFixedColorR10r71R32ajR33:0:1nhR16i-289gR17oR18R34R20i1776R21i1760gR22r71goR3jR4:5:3jR5:20:1r236oR3jR4:9:2oR3jR4:1:1r15R17oR18R34R20i1797R21i1785gR22r16gajR60:3:0hR17oR18R34R20i1799R21i1785gR22r43goR3jR4:9:2oR3jR4:1:1r912R17oR18R34R20i1813R21i1803gR22r913gar936hR17oR18R34R20i1815R21i1803gR22r43gR17oR18R34R20i1815R21i1785gR22r43goR3jR4:5:3r7oR3jR4:9:2oR3jR4:1:1r15R17oR18R34R20i1845R21i1833gR22r16gar936hR17oR18R34R20i1847R21i1833gR22r43goR3jR4:5:3r236oR3jR4:9:2oR3jR4:1:1r912R17oR18R34R20i1860R21i1850gR22r913gar936hR17oR18R34R20i1862R21i1850gR22r43goR3jR4:8:2oR3jR4:2:1r244R17oR18R34R20i1870R21i1865gR22jR11:13:1aoR1aoR8R41R10r71ghR30r43ghgaoR3jR4:5:3jR5:7:0oR3jR4:9:2oR3jR4:1:1r15R17oR18R34R20i1883R21i1871gR22r16gar936hR17oR18R34R20i1885R21i1871gR22r43goR3jR4:0:1jR26:3:1zR17oR18R34R20i1889R21i1888gR22r43gR17oR18R34R20i1889R21i1871gR22r71ghR17oR18R34R20i1890R21i1865gR22r43gR17oR18R34R20i1890R21i1850gR22r43gR17oR18R34R20i1890R21i1833gR22r43gR17oR18R34R20i1890R21i1756gR22r55ghR17oR18R34R20i1897R21i1709gR22r55gnR17oR18R34R20i1897R21i1689gR22r55ghR17oR18R34R20i1902R21i612gR22r55gR6jR27:1:0R28oR6r58R8y8:fragmentR10jR11:13:1aoR1ahR30r55ghR16i-295gR30r55goR1aoR6r10R8R25R10r88R16i-296ghR2oR3jR4:4:1aoR3jR4:7:2oR6r10R8y5:depthR10r43R16i-312goR3jR4:8:2oR3jR4:2:1r608R17oR18R34R20i1973R21i1967gR22r616gaoR3jR4:8:2oR3jR4:2:1r105R17oR18R34R20i1986R21i1974gR22jR11:13:1aoR1aoR8R38R10r112gr113hR30r102ghgaoR3jR4:1:1oR6r70R8y12:depthTextureR10r112R16i-283gR17oR18R34R20i1986R21i1974gR22r112goR3jR4:1:1r1011R17oR18R34R20i1993R21i1991gR22r88ghR17oR18R34R20i1994R21i1974gR22r102ghR17oR18R34R20i1995R21i1967gR22r43gR17oR18R34R20i1996R21i1955gR22r55goR3jR4:7:2oR6r10R8y3:uv2R10jR11:5:2i2r11R16i-313goR3jR4:5:3r236oR3jR4:3:1oR3jR4:5:3r318oR3jR4:1:1r1011R17oR18R34R20i2014R21i2012gR22r88goR3jR4:0:1jR26:3:1d0.5R17oR18R34R20i2020R21i2017gR22r43gR17oR18R34R20i2020R21i2012gR22r88gR17oR18R34R20i2021R21i2011gR22r88goR3jR4:8:2oR3jR4:2:1jR23:38:0R17oR18R34R20i2028R21i2024gR22jR11:13:1ahgaoR3jR4:0:1jR26:3:1i2R17oR18R34R20i2030R21i2029gR22r43goR3jR4:0:1jR26:3:1i-2R17oR18R34R20i2034R21i2032gR22r43ghR17oR18R34R20i2035R21i2024gR22jR11:5:2i2r11gR17oR18R34R20i2035R21i2011gR22r1046gR17oR18R34R20i2036R21i2001gR22r55goR3jR4:7:2oR6r10R8y4:tempR10r102R16i-314goR3jR4:5:3r236oR3jR4:8:2oR3jR4:2:1r22R17oR18R34R20i2056R21i2052gR22r26gaoR3jR4:1:1r1045R17oR18R34R20i2060R21i2057gR22r1046goR3jR4:1:1r1015R17oR18R34R20i2067R21i2062gR22r43goR3jR4:0:1jR26:3:1i1R17oR18R34R20i2070R21i2069gR22r43ghR17oR18R34R20i2071R21i2052gR22jR11:5:2i4r11goR3jR4:1:1oR6r70R8y21:cameraInverseViewProjR10jR11:7:0R16i-281gR17oR18R34R20i2095R21i2074gR22r1107gR17oR18R34R20i2095R21i2052gR22r102gR17oR18R34R20i2096R21i2041gR22r55goR3jR4:7:2oR6r10R8y8:originWSR10jR11:5:2i3r11R16i-315goR3jR4:5:3jR5:2:0oR3jR4:9:2oR3jR4:1:1r1085R17oR18R34R20i2120R21i2116gR22r102gar904r905r906hR17oR18R34R20i2124R21i2116gR22r1116goR3jR4:9:2oR3jR4:1:1r1085R17oR18R34R20i2131R21i2127gR22r102gar936hR17oR18R34R20i2133R21i2127gR22r43gR17oR18R34R20i2133R21i2116gR22r1116gR17oR18R34R20i2134R21i2101gR22r55goR3jR4:12:1oR3jR4:1:1r1115R17oR18R34R20i2154R21i2146gR22r1116gR17oR18R34R20i2154R21i2139gR22r55ghR17oR18R34R20i2160R21i1949gR22r55gR6jR27:3:0R28r83R30r80ghR8y15:h3d.shader.Blury4:varsar32r13r1106r118r1032r206r560r507r238r891r924r912r69oR6r70R8y9:hasNormalR10r71R32ajR33:0:1nhR16i-292gr182r57r1004r83hg"
h3d_shader_ColorAdd.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:20:1jR5:0:0oR3jR4:9:2oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey10:pixelColory4:typejy9:hxsl.Type:5:2i4jy12:hxsl.VecType:1:0y2:idi-244gy1:poy4:filey74:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FColorAdd.hxy3:maxi180y3:mini170gy1:tr14gajy14:hxsl.Component:0:0jR20:1:0jR20:2:0hR14oR15R16R17i184R18i170gR19jR11:5:2i3r13goR3jR4:1:1oR6jR7:2:0R8y5:colorR10jR11:5:2i3r13R13i-245gR14oR15R16R17i193R18i188gR19r27gR14oR15R16R17i193R18i170gR19r23ghR14oR15R16R17i199R18i164gR19jR11:0:0gR6jy17:hxsl.FunctionKind:1:0y3:refoR6jR7:6:0R8y8:fragmentR10jR11:13:1aoR1ahy3:retr34ghR13i-246gR25r34ghR8y19:h3d.shader.ColorAddy4:varsar11r25r36hg"
h3d_shader_ColorKey.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:7:2oy4:kindjy12:hxsl.VarKind:4:0y4:namey5:cdiffy4:typejy9:hxsl.Type:5:2i4jy12:hxsl.VecType:1:0y2:idi-250goR3jR4:5:3jy16:haxe.macro.Binop:3:0oR3jR4:1:1oR5r8R7y12:textureColorR9jR10:5:2i4r9R12i-248gy1:poy4:filey74:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FColorKey.hxy3:maxi197y3:mini185gy1:tr15goR3jR4:1:1oR5jR6:2:0R7y8:colorKeyR9jR10:5:2i4r9R12i-247gR15oR16R17R18i208R19i200gR20r21gR15oR16R17R18i208R19i185gR20r10gR15oR16R17R18i209R19i173gR20jR10:0:0goR3jR4:10:3oR3jR4:5:3jR13:9:0oR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:29:0R15oR16R17R18i223R19i218gR20jR10:13:1aoR1aoR7y1:_R9r10goR7y1:bR9jR10:5:2i4r9ghy3:retjR10:3:0ghgaoR3jR4:1:1r7R15oR16R17R18i223R19i218gR20r10goR3jR4:1:1r7R15oR16R17R18i233R19i228gR20r10ghR15oR16R17R18i234R19i218gR20r43goR3jR4:0:1jy10:hxsl.Const:3:1d1e-005R15oR16R17R18i244R19i237gR20r43gR15oR16R17R18i244R19i218gR20jR10:2:0goR3jR4:11:0R15oR16R17R18i254R19i247gR20r28gnR15oR16R17R18i254R19i214gR20r28ghR15oR16R17R18i260R19i167gR20r28gR5jy17:hxsl.FunctionKind:1:0y3:refoR5jR6:6:0R7y8:fragmentR9jR10:13:1aoR1ahR25r28ghR12i-249gR25r28ghR7y19:h3d.shader.ColorKeyy4:varsar19r14r69hg"
h3d_shader_ColorMatrix.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey10:pixelColory4:typejy9:hxsl.Type:5:2i4jy12:hxsl.VecType:1:0y2:idi-251gy1:poy4:filey77:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FColorMatrix.hxy3:maxi184y3:mini174gy1:tr12goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:40:0R14oR15R16R17i191R18i187gR19jR11:13:1ahgaoR3jR4:9:2oR3jR4:3:1oR3jR4:5:3jR5:1:0oR3jR4:8:2oR3jR4:2:1r17R14oR15R16R17i198R18i194gR19r21gaoR3jR4:9:2oR3jR4:1:1r9R14oR15R16R17i209R18i199gR19r12gajy14:hxsl.Component:0:0jR21:1:0jR21:2:0hR14oR15R16R17i213R18i199gR19jR11:5:2i3r11goR3jR4:0:1jy10:hxsl.Const:3:1d1R14oR15R16R17i216R18i214gR19jR11:3:0ghR14oR15R16R17i217R18i194gR19jR11:5:2i4r11goR3jR4:1:1oR6jR7:2:0R8y6:matrixR10jR11:7:0R13i-252gR14oR15R16R17i226R18i220gR19r54gR14oR15R16R17i226R18i194gR19jR11:5:2i4r11gR14oR15R16R17i227R18i193gR19r59gar37r38r39hR14oR15R16R17i231R18i193gR19jR11:5:2i3r11goR3jR4:9:2oR3jR4:3:1oR3jR4:5:3r26oR3jR4:1:1r9R14oR15R16R17i244R18i234gR19r12goR3jR4:1:1r52R14oR15R16R17i253R18i247gR19r54gR14oR15R16R17i253R18i234gR19r59gR14oR15R16R17i254R18i233gR19r59gajR21:3:0hR14oR15R16R17i256R18i233gR19r47ghR14oR15R16R17i257R18i187gR19jR11:5:2i4r11gR14oR15R16R17i257R18i174gR19r12ghR14oR15R16R17i263R18i168gR19jR11:0:0gR6jy17:hxsl.FunctionKind:1:0y3:refoR6jR7:6:0R8y8:fragmentR10jR11:13:1aoR1ahy3:retr90ghR13i-253gR27r90ghR8y22:h3d.shader.ColorMatrixy4:varsar9r52r92hg"
h3d_shader_DirLight.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:7:2oy4:kindjy12:hxsl.VarKind:4:0y4:namey4:diffy4:typejy9:hxsl.Type:3:0y2:idi-22goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:22:0y1:poy4:filey74:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FDirLight.hxy3:maxi501y3:mini468gy1:tjR10:13:1aoR1aoR7y1:_R9r9goR7y1:bR9r9ghy3:retr9ghgaoR3jR4:8:2oR3jR4:2:1jR12:29:0R13oR14R15R16i485R17i468gR18jR10:13:1aoR1aoR7R19R9jR10:5:2i3jy12:hxsl.VecType:1:0goR7R20R9jR10:5:2i3r31ghR21r9ghgaoR3jR4:1:1oR5r8R7y17:transformedNormalR9r32R11i-15gR13oR14R15R16i485R17i468gR18r32goR3jR4:6:2jy15:haxe.macro.Unop:3:0oR3jR4:1:1oR5jR6:2:0R7y9:directionR9jR10:5:2i3r31R11i-9gR13oR14R15R16i500R17i491gR18r46gR13oR14R15R16i500R17i490gR18r46ghR13oR14R15R16i501R17i468gR18r9goR3jR4:0:1jy10:hxsl.Const:3:1d0R13oR14R15R16i508R17i506gR18r9ghR13oR14R15R16i509R17i468gR18r9gR13oR14R15R16i510R17i457gR18jR10:0:0goR3jR4:10:3oR3jR4:6:2jR24:2:0oR3jR4:1:1oR5r45R7y14:enableSpecularR9jR10:2:0y10:qualifiersajy17:hxsl.VarQualifier:0:1nhR11i-10gR13oR14R15R16i534R17i520gR18r67gR13oR14R15R16i534R17i519gR18r67goR3jR4:12:1oR3jR4:5:3jy16:haxe.macro.Binop:1:0oR3jR4:1:1oR5r45R7y5:colorR9jR10:5:2i3r31R11i-8gR13oR14R15R16i554R17i549gR18r79goR3jR4:1:1r7R13oR14R15R16i561R17i557gR18r9gR13oR14R15R16i561R17i549gR18r79gR13oR14R15R16i561R17i542gR18r61gnR13oR14R15R16i561R17i515gR18r61goR3jR4:7:2oR5r8R7y1:rR9r34R11i-23goR3jR4:8:2oR3jR4:2:1jR12:31:0R13oR14R15R16i612R17i575gR18jR10:13:1aoR1aoR7R19R9r34ghR21r34ghgaoR3jR4:8:2oR3jR4:2:1jR12:32:0R13oR14R15R16i582R17i575gR18jR10:13:1aoR1aoR7y1:aR9r34goR7R20R9r34ghR21r34ghgaoR3jR4:1:1r44R13oR14R15R16i592R17i583gR18r46goR3jR4:1:1r38R13oR14R15R16i611R17i594gR18r32ghR13oR14R15R16i612R17i575gR18r34ghR13oR14R15R16i624R17i575gR18r34gR13oR14R15R16i625R17i567gR18r61goR3jR4:7:2oR5r8R7y9:specValueR9r9R11i-24goR3jR4:8:2oR3jR4:2:1r12R13oR14R15R16i704R17i646gR18jR10:13:1aoR1aoR7R19R9r9gr19hR21r9ghgaoR3jR4:8:2oR3jR4:2:1r24R13oR14R15R16i647R17i646gR18jR10:13:1aoR1aoR7R19R9r34gr33hR21r9ghgaoR3jR4:1:1r92R13oR14R15R16i647R17i646gR18r34goR3jR4:8:2oR3jR4:2:1r95R13oR14R15R16i691R17i652gR18jR10:13:1aoR1aoR7R19R9jR10:5:2i3r31ghR21r34ghgaoR3jR4:3:1oR3jR4:5:3jR30:3:0oR3jR4:1:1oR5jR6:0:0R7y8:positionR9jR10:5:2i3r31y6:parentoR5r169R7y6:cameraR9jR10:12:1ar168hR11i-11gR11i-12gR13oR14R15R16i668R17i653gR18r170goR3jR4:1:1oR5r8R7y19:transformedPositionR9jR10:5:2i3r31R11i-16gR13oR14R15R16i690R17i671gR18r178gR13oR14R15R16i690R17i653gR18r161gR13oR14R15R16i691R17i652gR18r161ghR13oR14R15R16i703R17i652gR18r34ghR13oR14R15R16i704R17i646gR18r9goR3jR4:0:1jR26:3:1d0R13oR14R15R16i711R17i709gR18r9ghR13oR14R15R16i712R17i646gR18r9gR13oR14R15R16i713R17i630gR18r61goR3jR4:12:1oR3jR4:5:3r76oR3jR4:1:1r78R13oR14R15R16i730R17i725gR18r79goR3jR4:3:1oR3jR4:5:3jR30:0:0oR3jR4:1:1r7R13oR14R15R16i738R17i734gR18r9goR3jR4:5:3r76oR3jR4:1:1oR5r8R7y9:specColorR9jR10:5:2i3r31R11i-18gR13oR14R15R16i750R17i741gR18r211goR3jR4:8:2oR3jR4:2:1jR12:8:0R13oR14R15R16i756R17i753gR18jR10:13:1aoR1aoR7R33R9r9gr19hR21r9ghgaoR3jR4:1:1r129R13oR14R15R16i766R17i757gR18r9goR3jR4:1:1oR5r8R7y9:specPowerR9r9R11i-17gR13oR14R15R16i777R17i768gR18r9ghR13oR14R15R16i778R17i753gR18r9gR13oR14R15R16i778R17i741gR18r211gR13oR14R15R16i778R17i734gR18r211gR13oR14R15R16i779R17i733gR18r211gR13oR14R15R16i779R17i725gR18jR10:5:2i3r31gR13oR14R15R16i779R17i718gR18r61ghR13oR14R15R16i785R17i451gR18r61gR5jy17:hxsl.FunctionKind:3:0y3:refoR5jR6:6:0R7y12:calcLightingR9jR10:13:1aoR1ahR21jR10:5:2i3r31ghR11i-19gR21r253goR1ahR2oR3jR4:4:1aoR3jR4:5:3jR30:20:1r204oR3jR4:9:2oR3jR4:1:1oR5r8R7y10:lightColorR9jR10:5:2i3r31R11i-13gR13oR14R15R16i825R17i815gR18r264gajy14:hxsl.Component:0:0jR45:1:0jR45:2:0hR13oR14R15R16i829R17i815gR18jR10:5:2i3r31goR3jR4:8:2oR3jR4:1:1r248R13oR14R15R16i845R17i833gR18r254gahR13oR14R15R16i847R17i833gR18r253gR13oR14R15R16i847R17i815gR18r273ghR13oR14R15R16i853R17i809gR18r61gR5jR41:0:0R42oR5r249R7y6:vertexR9jR10:13:1aoR1ahR21r61ghR11i-20gR21r61goR1ahR2oR3jR4:4:1aoR3jR4:5:3jR30:20:1r204oR3jR4:9:2oR3jR4:1:1oR5r8R7y15:lightPixelColorR9jR10:5:2i3r31R11i-14gR13oR14R15R16i900R17i885gR18r300gar268r269r270hR13oR14R15R16i904R17i885gR18jR10:5:2i3r31goR3jR4:8:2oR3jR4:1:1r248R13oR14R15R16i920R17i908gR18r254gahR13oR14R15R16i922R17i908gR18r253gR13oR14R15R16i922R17i885gR18r306ghR13oR14R15R16i928R17i879gR18r61gR5jR41:1:0R42oR5r249R7y8:fragmentR9jR10:13:1aoR1ahR21r61ghR11i-21gR21r61ghR7y19:h3d.shader.DirLighty4:varsar78r44r66r171r263r299r38r177r229r210r248r286r319hg"
h3d_shader_LineShader.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:4:1aoR3jR4:7:2oy4:kindjy12:hxsl.VarKind:4:0y4:namey3:diry4:typejy9:hxsl.Type:5:2i3jy12:hxsl.VecType:1:0y2:idi-104goR3jR4:5:3jy16:haxe.macro.Binop:1:0oR3jR4:1:1oR5jR6:1:0R7y6:normalR9jR10:5:2i3r11y6:parentoR5r17R7y5:inputR9jR10:12:1aoR5r17R7y8:positionR9jR10:5:2i3r11R15r19R12i-91gr16oR5r17R7y2:uvR9jR10:5:2i2r11R15r19R12i-93ghR12i-90gR12i-92gy1:poy4:filey76:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FLineShader.hxy3:maxi683y3:mini671gy1:tr18goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:48:0R19oR20R21R22i702R23i686gR24jR10:13:1ahgaoR3jR4:1:1oR5jR6:0:0R7y9:modelViewR9jR10:7:0R15oR5r38R7y6:globalR9jR10:12:1aoR5r38R7y9:pixelSizeR9jR10:5:2i2r11R15r40R12i-88gr37hR12i-87gy10:qualifiersajy17:hxsl.VarQualifier:3:0hR12i-89gR19oR20R21R22i702R23i686gR24r39ghR19oR20R21R22i709R23i686gR24jR10:6:0gR19oR20R21R22i709R23i671gR24r12gR19oR20R21R22i710R23i661gR24jR10:0:0goR3jR4:5:3jR13:4:0oR3jR4:1:1oR5r10R7y4:pdirR9jR10:5:2i4r11R12i-101gR19oR20R21R22i734R23i730gR24r61goR3jR4:5:3r14oR3jR4:8:2oR3jR4:2:1jR25:40:0R19oR20R21R22i741R23i737gR24jR10:13:1ahgaoR3jR4:5:3r14oR3jR4:1:1r9R19oR20R21R22i745R23i742gR24r12goR3jR4:8:2oR3jR4:2:1r30R19oR20R21R22i752R23i748gR24jR10:13:1ahgaoR3jR4:1:1oR5r38R7y4:viewR9r39R15oR5r38R7y6:cameraR9jR10:12:1ar85oR5r38R7y4:projR9r39R15r86R12i-85goR5r38R7y8:viewProjR9r39R15r86R12i-86ghR12i-83gR12i-84gR19oR20R21R22i764R23i753gR24r39ghR19oR20R21R22i765R23i748gR24r51gR19oR20R21R22i765R23i742gR24r12goR3jR4:0:1jy10:hxsl.Const:3:1i1R19oR20R21R22i768R23i767gR24jR10:3:0ghR19oR20R21R22i769R23i737gR24jR10:5:2i4r11goR3jR4:1:1r88R19oR20R21R22i783R23i772gR24r39gR19oR20R21R22i783R23i737gR24jR10:5:2i4r11gR19oR20R21R22i783R23i730gR24r61goR3jR4:5:3jR13:20:1r14oR3jR4:9:2oR3jR4:1:1r60R19oR20R21R22i794R23i790gR24r61gajy14:hxsl.Component:0:0jR37:1:0hR19oR20R21R22i797R23i790gR24jR10:5:2i2r11goR3jR4:5:3jR13:2:0oR3jR4:0:1jR36:3:1i1R19oR20R21R22i802R23i801gR24r101goR3jR4:8:2oR3jR4:2:1jR25:13:0R19oR20R21R22i809R23i805gR24jR10:13:1aoR1aoR7y5:valueR9r101ghy3:retr101ghgaoR3jR4:5:3jR13:0:0oR3jR4:5:3r14oR3jR4:9:2oR3jR4:1:1r60R19oR20R21R22i814R23i810gR24r61gar120hR19oR20R21R22i816R23i810gR24r101goR3jR4:9:2oR3jR4:1:1r60R19oR20R21R22i823R23i819gR24r61gar120hR19oR20R21R22i825R23i819gR24r101gR19oR20R21R22i825R23i810gR24r101goR3jR4:5:3r14oR3jR4:9:2oR3jR4:1:1r60R19oR20R21R22i832R23i828gR24r61gar121hR19oR20R21R22i834R23i828gR24r101goR3jR4:9:2oR3jR4:1:1r60R19oR20R21R22i841R23i837gR24r61gar121hR19oR20R21R22i843R23i837gR24r101gR19oR20R21R22i843R23i828gR24r101gR19oR20R21R22i843R23i810gR24r101ghR19oR20R21R22i844R23i805gR24r101gR19oR20R21R22i844R23i801gR24r101gR19oR20R21R22i844R23i790gR24r124goR3jR4:5:3jR13:20:1r143oR3jR4:1:1oR5r10R7y19:transformedPositionR9jR10:5:2i3r11R12i-97gR19oR20R21R22i870R23i851gR24r190goR3jR4:5:3r14oR3jR4:5:3r14oR3jR4:1:1r9R19oR20R21R22i877R23i874gR24r12goR3jR4:9:2oR3jR4:1:1r23R19oR20R21R22i888R23i880gR24r24gar120hR19oR20R21R22i890R23i880gR24r101gR19oR20R21R22i890R23i874gR24r12goR3jR4:1:1oR5jR6:2:0R7y11:lengthScaleR9r101R12i-99gR19oR20R21R22i904R23i893gR24r101gR19oR20R21R22i904R23i874gR24r12gR19oR20R21R22i904R23i851gR24r190goR3jR4:5:3r58oR3jR4:1:1oR5r10R7y17:transformedNormalR9jR10:5:2i3r11R12i-96gR19oR20R21R22i928R23i911gR24r219goR3jR4:8:2oR3jR4:2:1jR25:31:0R19oR20R21R22i934R23i931gR24jR10:13:1aoR1aoR7y1:_R9r12ghR39r12ghgaoR3jR4:1:1r9R19oR20R21R22i934R23i931gR24r12ghR19oR20R21R22i946R23i931gR24r12gR19oR20R21R22i946R23i911gR24r219ghR19oR20R21R22i953R23i654gR24r56ghR19oR20R21R22i958R23i648gR24r56gR5jy17:hxsl.FunctionKind:2:0y3:refoR5jR6:6:0R7y8:__init__R9jR10:13:1aoR1ahR39r56ghR12i-102gR39r56goR1ahR2oR3jR4:4:1aoR3jR4:5:3jR13:20:1r143oR3jR4:9:2oR3jR4:1:1oR5r10R7y17:projectedPositionR9jR10:5:2i4r11R12i-98gR19oR20R21R22i1005R23i988gR24r260gar120r121hR19oR20R21R22i1008R23i988gR24jR10:5:2i2r11goR3jR4:5:3r14oR3jR4:5:3r14oR3jR4:5:3r14oR3jR4:5:3r14oR3jR4:3:1oR3jR4:5:3r14oR3jR4:9:2oR3jR4:1:1r60R19oR20R21R22i1017R23i1013gR24r61gar121r120hR19oR20R21R22i1020R23i1013gR24jR10:5:2i2r11goR3jR4:8:2oR3jR4:2:1jR25:38:0R19oR20R21R22i1027R23i1023gR24jR10:13:1ahgaoR3jR4:0:1jR36:3:1i1R19oR20R21R22i1029R23i1028gR24r101goR3jR4:0:1jR36:3:1i-1R19oR20R21R22i1032R23i1030gR24r101ghR19oR20R21R22i1033R23i1023gR24jR10:5:2i2r11gR19oR20R21R22i1033R23i1013gR24jR10:5:2i2r11gR19oR20R21R22i1034R23i1012gR24r302goR3jR4:3:1oR3jR4:5:3jR13:3:0oR3jR4:9:2oR3jR4:1:1r23R19oR20R21R22i1046R23i1038gR24r24gar121hR19oR20R21R22i1048R23i1038gR24r101goR3jR4:0:1jR36:3:1d0.5R19oR20R21R22i1054R23i1051gR24r101gR19oR20R21R22i1054R23i1038gR24r101gR19oR20R21R22i1055R23i1037gR24r101gR19oR20R21R22i1055R23i1012gR24r302goR3jR4:9:2oR3jR4:1:1r259R19oR20R21R22i1075R23i1058gR24r260gajR37:2:0hR19oR20R21R22i1077R23i1058gR24r101gR19oR20R21R22i1077R23i1012gR24r302goR3jR4:1:1r42R19oR20R21R22i1096R23i1080gR24r43gR19oR20R21R22i1096R23i1012gR24jR10:5:2i2r11goR3jR4:1:1oR5r209R7y5:widthR9r101R12i-100gR19oR20R21R22i1104R23i1099gR24r101gR19oR20R21R22i1104R23i1012gR24r340gR19oR20R21R22i1104R23i988gR24r266ghR19oR20R21R22i1110R23i982gR24r56gR5jR44:0:0R45oR5r246R7y6:vertexR9jR10:13:1aoR1ahR39r56ghR12i-103gR39r56ghR7y21:h3d.shader.LineShadery4:varsar86r40r19oR5r10R7y6:outputR9jR10:12:1aoR5r10R7R17R9jR10:5:2i4r11R15r358R12i-95ghR12i-94gr218r189r259r208r342r60r245r352hg"
h3d_shader_Shadow.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:10:3oR3jR4:6:2jy15:haxe.macro.Unop:2:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:2:0y4:namey8:perPixely4:typejy9:hxsl.Type:2:0y10:qualifiersajy17:hxsl.VarQualifier:0:1nhy2:idi-184gy1:poy4:filey72:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FShadow.hxy3:maxi414y3:mini406gy1:tr12gR15oR16R17R18i414R19i405gR20r12goR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oR6jR7:3:0R8y9:shadowPosR10jR11:5:2i3jy12:hxsl.VecType:1:0R12ajR13:1:0hR14i-183gR15oR16R17R18i426R19i417gR20r25goR3jR4:5:3jR21:0:0oR3jR4:5:3jR21:1:0oR3jR4:5:3r33oR3jR4:1:1oR6jR7:4:0R8y19:transformedPositionR10jR11:5:2i3r24R14i-181gR15oR16R17R18i448R19i429gR20r38goR3jR4:1:1oR6jR7:0:0R8y4:projR10jR11:8:0y6:parentoR6r43R8y6:shadowR10jR11:12:1aoR6r43R8y3:mapR10jR11:15:1i1R26r45R14i-175gr42oR6r43R8y5:colorR10jR11:5:2i3r24R26r45R14i-177goR6r43R8y5:powerR10jR11:3:0R26r45R14i-178goR6r43R8y4:biasR10r52R26r45R14i-179ghR14i-174gR14i-176gR15oR16R17R18i462R19i451gR20r44gR15oR16R17R18i462R19i429gR20jR11:5:2i3r24goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:39:0R15oR16R17R18i469R19i465gR20jR11:13:1ahgaoR3jR4:0:1jy10:hxsl.Const:3:1d0.5R15oR16R17R18i473R19i470gR20r52goR3jR4:0:1jR33:3:1d-0.5R15oR16R17R18i479R19i475gR20r52goR3jR4:0:1jR33:3:1i1R15oR16R17R18i482R19i481gR20r52ghR15oR16R17R18i483R19i465gR20jR11:5:2i3r24gR15oR16R17R18i483R19i429gR20jR11:5:2i3r24goR3jR4:8:2oR3jR4:2:1r62R15oR16R17R18i490R19i486gR20r66gaoR3jR4:0:1jR33:3:1d0.5R15oR16R17R18i494R19i491gR20r52goR3jR4:0:1jR33:3:1d0.5R15oR16R17R18i499R19i496gR20r52goR3jR4:0:1jR33:3:1zR15oR16R17R18i502R19i501gR20r52ghR15oR16R17R18i503R19i486gR20jR11:5:2i3r24gR15oR16R17R18i503R19i429gR20jR11:5:2i3r24gR15oR16R17R18i503R19i417gR20r25gnR15oR16R17R18i503R19i401gR20jR11:0:0ghR15oR16R17R18i509R19i395gR20r113gR6jy17:hxsl.FunctionKind:0:0y3:refoR6jR7:6:0R8y6:vertexR10jR11:13:1aoR1ahy3:retr113ghR14i-185gR37r113goR1ahR2oR3jR4:4:1aoR3jR4:7:2oR6r37R8R22R10jR11:5:2i3r24R14i-187goR3jR4:10:3oR3jR4:1:1r10R15oR16R17R18i571R19i563gR20r12goR3jR4:5:3r31oR3jR4:5:3r33oR3jR4:5:3r33oR3jR4:1:1oR6r37R8y24:pixelTransformedPositionR10jR11:5:2i3r24R14i-182gR15oR16R17R18i598R19i574gR20r139goR3jR4:1:1r42R15oR16R17R18i612R19i601gR20r44gR15oR16R17R18i612R19i574gR20r59goR3jR4:8:2oR3jR4:2:1r62R15oR16R17R18i619R19i615gR20r66gaoR3jR4:0:1jR33:3:1d0.5R15oR16R17R18i623R19i620gR20r52goR3jR4:0:1jR33:3:1d-0.5R15oR16R17R18i629R19i625gR20r52goR3jR4:0:1jR33:3:1i1R15oR16R17R18i632R19i631gR20r52ghR15oR16R17R18i633R19i615gR20jR11:5:2i3r24gR15oR16R17R18i633R19i574gR20jR11:5:2i3r24goR3jR4:8:2oR3jR4:2:1r62R15oR16R17R18i640R19i636gR20r66gaoR3jR4:0:1jR33:3:1d0.5R15oR16R17R18i644R19i641gR20r52goR3jR4:0:1jR33:3:1d0.5R15oR16R17R18i649R19i646gR20r52goR3jR4:0:1jR33:3:1zR15oR16R17R18i652R19i651gR20r52ghR15oR16R17R18i653R19i636gR20jR11:5:2i3r24gR15oR16R17R18i653R19i574gR20r129goR3jR4:1:1r22R15oR16R17R18i668R19i659gR20r25gR15oR16R17R18i668R19i559gR20r129gR15oR16R17R18i669R19i543gR20r113goR3jR4:7:2oR6r37R8y5:depthR10r52R14i-188goR3jR4:8:2oR3jR4:2:1jR32:61:0R15oR16R17R18i698R19i688gR20jR11:13:1aoR1aoR8y1:_R10r48goR8y2:uvR10jR11:5:2i2r24ghR37r52ghgaoR3jR4:1:1r47R15oR16R17R18i698R19i688gR20r48goR3jR4:9:2oR3jR4:1:1r128R15oR16R17R18i712R19i703gR20r129gajy14:hxsl.Component:0:0jR42:1:0hR15oR16R17R18i715R19i703gR20jR11:5:2i2r24ghR15oR16R17R18i716R19i688gR20r52gR15oR16R17R18i717R19i676gR20r113goR3jR4:7:2oR6r37R8y4:zMaxR10r52R14i-189goR3jR4:8:2oR3jR4:2:1jR32:51:0R15oR16R17R18i909R19i898gR20jR11:13:1aoR1aoR8R40R10r52ghR37r52ghgaoR3jR4:9:2oR3jR4:1:1r128R15oR16R17R18i907R19i898gR20r129gajR42:2:0hR15oR16R17R18i909R19i898gR20r52ghR15oR16R17R18i920R19i898gR20r52gR15oR16R17R18i921R19i887gR20r113goR3jR4:7:2oR6r37R8y5:deltaR10r52R14i-190goR3jR4:5:3jR21:3:0oR3jR4:8:2oR3jR4:2:1jR32:21:0R15oR16R17R18i959R19i938gR20jR11:13:1aoR1aoR8R40R10r52goR8y1:bR10r52ghR37r52ghgaoR3jR4:3:1oR3jR4:5:3r31oR3jR4:1:1r200R15oR16R17R18i944R19i939gR20r52goR3jR4:1:1r53R15oR16R17R18i958R19i947gR20r52gR15oR16R17R18i958R19i939gR20r52gR15oR16R17R18i959R19i938gR20r52goR3jR4:1:1r232R15oR16R17R18i968R19i964gR20r52ghR15oR16R17R18i969R19i938gR20r52goR3jR4:1:1r232R15oR16R17R18i976R19i972gR20r52gR15oR16R17R18i976R19i938gR20r52gR15oR16R17R18i977R19i926gR20r113goR3jR4:7:2oR6r37R8y5:shadeR10r52R14i-191goR3jR4:8:2oR3jR4:2:1r235R15oR16R17R18i1022R19i994gR20jR11:13:1aoR1aoR8R40R10r52ghR37r52ghgaoR3jR4:8:2oR3jR4:2:1jR32:9:0R15oR16R17R18i997R19i994gR20jR11:13:1aoR1aoR8y5:valueR10r52ghR37r52ghgaoR3jR4:5:3r33oR3jR4:1:1r51R15oR16R17R18i1011R19i999gR20r52goR3jR4:1:1r257R15oR16R17R18i1019R19i1014gR20r52gR15oR16R17R18i1019R19i999gR20r52ghR15oR16R17R18i1022R19i994gR20r52ghR15oR16R17R18i1033R19i994gR20r52gR15oR16R17R18i1034R19i982gR20r113goR3jR4:5:3jR21:20:1r33oR3jR4:9:2oR3jR4:1:1oR6r37R8y10:pixelColorR10jR11:5:2i4r24R14i-180gR15oR16R17R18i1049R19i1039gR20r339gar222r223r249hR15oR16R17R18i1053R19i1039gR20jR11:5:2i3r24goR3jR4:5:3r31oR3jR4:5:3r33oR3jR4:3:1oR3jR4:5:3r259oR3jR4:0:1jR33:3:1i1R15oR16R17R18i1059R19i1058gR20r52goR3jR4:1:1r297R15oR16R17R18i1067R19i1062gR20r52gR15oR16R17R18i1067R19i1058gR20r52gR15oR16R17R18i1068R19i1057gR20r52goR3jR4:9:2oR3jR4:1:1r49R15oR16R17R18i1083R19i1071gR20r50gar222r223r249hR15oR16R17R18i1087R19i1071gR20jR11:5:2i3r24gR15oR16R17R18i1087R19i1057gR20r368goR3jR4:1:1r297R15oR16R17R18i1095R19i1090gR20r52gR15oR16R17R18i1095R19i1057gR20r368gR15oR16R17R18i1095R19i1039gR20r345ghR15oR16R17R18i1101R19i535gR20r113gR6jR34:1:0R35oR6r118R8y8:fragmentR10jR11:13:1aoR1ahR37r113ghR14i-186gR37r113ghR8y17:h3d.shader.Shadowy4:varsar45r338r36r138r22r10r117r381hg"
h3d_shader_Skin.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey19:transformedPositiony4:typejy9:hxsl.Type:5:2i3jy12:hxsl.VecType:1:0y2:idi-111gy1:poy4:filey70:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FSkin.hxy3:maxi546y3:mini527gy1:tr12goR3jR4:5:3jR5:0:0oR3jR4:5:3r16oR3jR4:5:3jR5:1:0oR3jR4:3:1oR3jR4:5:3r19oR3jR4:1:1oR6r10R8y16:relativePositionR10jR11:5:2i3r11R13i-110gR14oR15R16R17i571R18i555gR19r24goR3jR4:16:2oR3jR4:1:1oR6jR7:2:0R8y13:bonesMatrixesR10jR11:14:2jR11:8:0jy13:hxsl.SizeDecl:1:1oR6r30R8y8:MaxBonesR10jR11:1:0y10:qualifiersajy17:hxsl.VarQualifier:0:1nhR13i-113gR24ajR25:8:0hR13i-114gR14oR15R16R17i587R18i574gR19r37goR3jR4:9:2oR3jR4:1:1oR6jR7:1:0R8y7:indexesR10jR11:9:1i4y6:parentoR6r45R8y5:inputR10jR11:12:1aoR6r45R8y8:positionR10jR11:5:2i3r11R27r47R13i-106goR6r45R8y6:normalR10jR11:5:2i3r11R27r47R13i-107goR6r45R8y7:weightsR10jR11:5:2i3r11R27r47R13i-108gr44hR13i-105gR13i-109gR14oR15R16R17i601R18i588gR19r46gajy14:hxsl.Component:0:0hR14oR15R16R17i603R18i588gR19r33gR14oR15R16R17i604R18i574gR19r31gR14oR15R16R17i604R18i555gR19jR11:5:2i3r11gR14oR15R16R17i605R18i554gR19r66goR3jR4:9:2oR3jR4:1:1r53R14oR15R16R17i621R18i608gR19r54gar59hR14oR15R16R17i623R18i608gR19jR11:3:0gR14oR15R16R17i623R18i554gR19r66goR3jR4:5:3r19oR3jR4:3:1oR3jR4:5:3r19oR3jR4:1:1r23R14oR15R16R17i648R18i632gR19r24goR3jR4:16:2oR3jR4:1:1r29R14oR15R16R17i664R18i651gR19r37goR3jR4:9:2oR3jR4:1:1r44R14oR15R16R17i678R18i665gR19r46gajR32:1:0hR14oR15R16R17i680R18i665gR19r33gR14oR15R16R17i681R18i651gR19r31gR14oR15R16R17i681R18i632gR19r66gR14oR15R16R17i682R18i631gR19r66goR3jR4:9:2oR3jR4:1:1r53R14oR15R16R17i698R18i685gR19r54gar94hR14oR15R16R17i700R18i685gR19r76gR14oR15R16R17i700R18i631gR19r66gR14oR15R16R17i700R18i554gR19jR11:5:2i3r11goR3jR4:5:3r19oR3jR4:3:1oR3jR4:5:3r19oR3jR4:1:1r23R14oR15R16R17i725R18i709gR19r24goR3jR4:16:2oR3jR4:1:1r29R14oR15R16R17i741R18i728gR19r37goR3jR4:9:2oR3jR4:1:1r44R14oR15R16R17i755R18i742gR19r46gajR32:2:0hR14oR15R16R17i757R18i742gR19r33gR14oR15R16R17i758R18i728gR19r31gR14oR15R16R17i758R18i709gR19r66gR14oR15R16R17i759R18i708gR19r66goR3jR4:9:2oR3jR4:1:1r53R14oR15R16R17i775R18i762gR19r54gar130hR14oR15R16R17i777R18i762gR19r76gR14oR15R16R17i777R18i708gR19r66gR14oR15R16R17i777R18i554gR19jR11:5:2i3r11gR14oR15R16R17i777R18i527gR19r12goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y17:transformedNormalR10jR11:5:2i3r11R13i-112gR14oR15R16R17i800R18i783gR19r156goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:31:0R14oR15R16R17i812R18i803gR19jR11:13:1aoR1aoR8y5:valueR10r66ghy3:retr66ghgaoR3jR4:5:3r16oR3jR4:5:3r16oR3jR4:5:3r19oR3jR4:3:1oR3jR4:5:3r19oR3jR4:1:1r51R14oR15R16R17i832R18i820gR19r52goR3jR4:8:2oR3jR4:2:1jR34:48:0R14oR15R16R17i839R18i835gR19jR11:13:1ahgaoR3jR4:16:2oR3jR4:1:1r29R14oR15R16R17i853R18i840gR19r37goR3jR4:9:2oR3jR4:1:1r44R14oR15R16R17i867R18i854gR19r46gar59hR14oR15R16R17i869R18i854gR19r33gR14oR15R16R17i870R18i840gR19r31ghR14oR15R16R17i871R18i835gR19jR11:6:0gR14oR15R16R17i871R18i820gR19r66gR14oR15R16R17i872R18i819gR19r66goR3jR4:9:2oR3jR4:1:1r53R14oR15R16R17i888R18i875gR19r54gar59hR14oR15R16R17i890R18i875gR19r76gR14oR15R16R17i890R18i819gR19r66goR3jR4:5:3r19oR3jR4:3:1oR3jR4:5:3r19oR3jR4:1:1r51R14oR15R16R17i911R18i899gR19r52goR3jR4:8:2oR3jR4:2:1r180R14oR15R16R17i918R18i914gR19r184gaoR3jR4:16:2oR3jR4:1:1r29R14oR15R16R17i932R18i919gR19r37goR3jR4:9:2oR3jR4:1:1r44R14oR15R16R17i946R18i933gR19r46gar94hR14oR15R16R17i948R18i933gR19r33gR14oR15R16R17i949R18i919gR19r31ghR14oR15R16R17i950R18i914gR19r201gR14oR15R16R17i950R18i899gR19r66gR14oR15R16R17i951R18i898gR19r66goR3jR4:9:2oR3jR4:1:1r53R14oR15R16R17i967R18i954gR19r54gar94hR14oR15R16R17i969R18i954gR19r76gR14oR15R16R17i969R18i898gR19r66gR14oR15R16R17i969R18i819gR19jR11:5:2i3r11goR3jR4:5:3r19oR3jR4:3:1oR3jR4:5:3r19oR3jR4:1:1r51R14oR15R16R17i990R18i978gR19r52goR3jR4:8:2oR3jR4:2:1r180R14oR15R16R17i997R18i993gR19r184gaoR3jR4:16:2oR3jR4:1:1r29R14oR15R16R17i1011R18i998gR19r37goR3jR4:9:2oR3jR4:1:1r44R14oR15R16R17i1025R18i1012gR19r46gar130hR14oR15R16R17i1027R18i1012gR19r33gR14oR15R16R17i1028R18i998gR19r31ghR14oR15R16R17i1029R18i993gR19r201gR14oR15R16R17i1029R18i978gR19r66gR14oR15R16R17i1030R18i977gR19r66goR3jR4:9:2oR3jR4:1:1r53R14oR15R16R17i1046R18i1033gR19r54gar130hR14oR15R16R17i1048R18i1033gR19r76gR14oR15R16R17i1048R18i977gR19r66gR14oR15R16R17i1048R18i819gR19jR11:5:2i3r11ghR14oR15R16R17i1049R18i803gR19r66gR14oR15R16R17i1049R18i783gR19r156ghR14oR15R16R17i1064R18i428gR19jR11:0:0gR6jy17:hxsl.FunctionKind:0:0y3:refoR6jR7:6:0R8y6:vertexR10jR11:13:1aoR1ahR36r305ghR13i-115gR36r305ghR8y15:h3d.shader.Skiny4:varsar47r23r9r155r32r29r307hg"
h3d_shader_SpecularTexture.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:20:1jR5:1:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey9:specColory4:typejy9:hxsl.Type:5:2i3jy12:hxsl.VecType:1:0y2:idi-27gy1:poy4:filey81:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FSpecularTexture.hxy3:maxi218y3:mini209gy1:tr13goR3jR4:9:2oR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:33:0R14oR15R16R17i229R18i222gR19jR11:13:1aoR1aoR8y1:_R10jR11:10:0goR8y2:uvR10jR11:5:2i2r12ghy3:retjR11:5:2i4r12ghgaoR3jR4:1:1oR6jR7:2:0R8y7:textureR10r26R13i-25gR14oR15R16R17i229R18i222gR19r26goR3jR4:1:1oR6r11R8y12:calculatedUVR10jR11:5:2i2r12R13i-26gR14oR15R16R17i246R18i234gR19r39ghR14oR15R16R17i247R18i222gR19r29gajy14:hxsl.Component:0:0jR26:1:0jR26:2:0hR14oR15R16R17i251R18i222gR19jR11:5:2i3r12gR14oR15R16R17i251R18i209gR19r13ghR14oR15R16R17i257R18i203gR19jR11:0:0gR6jy17:hxsl.FunctionKind:1:0y3:refoR6jR7:6:0R8y8:fragmentR10jR11:13:1aoR1ahR23r55ghR13i-28gR23r55ghR8y26:h3d.shader.SpecularTexturey4:varsar33r38r10r57hg"
h3d_shader_Texture.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey12:calculatedUVy4:typejy9:hxsl.Type:5:2i2jy12:hxsl.VecType:1:0y2:idi-36gy1:poy4:filey73:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FTexture.hxy3:maxi443y3:mini431gy1:tr12goR3jR4:1:1oR6jR7:1:0R8y2:uvR10jR11:5:2i2r11y6:parentoR6r17R8y5:inputR10jR11:12:1ar16hR13i-29gR13i-30gR14oR15R16R17i454R18i446gR19r18gR14oR15R16R17i454R18i431gR19r12ghR14oR15R16R17i460R18i425gR19jR11:0:0gR6jy17:hxsl.FunctionKind:0:0y3:refoR6jR7:6:0R8y6:vertexR10jR11:13:1aoR1ahy3:retr28ghR13i-39gR26r28goR1ahR2oR3jR4:4:1aoR3jR4:7:2oR6r10R8y1:cR10jR11:5:2i4r11R13i-41goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:33:0R14oR15R16R17i507R18i500gR19jR11:13:1aoR1aoR8y1:_R10jR11:10:0goR8R20R10jR11:5:2i2r11ghR26r42ghgaoR3jR4:1:1oR6jR7:2:0R8y7:textureR10r52R13i-35gR14oR15R16R17i507R18i500gR19r52goR3jR4:1:1r9R14oR15R16R17i524R18i512gR19r12ghR14oR15R16R17i525R18i500gR19r42gR14oR15R16R17i526R18i492gR19r28goR3jR4:10:3oR3jR4:5:3jR5:14:0oR3jR4:1:1oR6r59R8y9:killAlphaR10jR11:2:0y10:qualifiersajy17:hxsl.VarQualifier:0:1nhR13i-32gR14oR15R16R17i544R18i535gR19r74goR3jR4:5:3jR5:9:0oR3jR4:5:3jR5:3:0oR3jR4:9:2oR3jR4:1:1r41R14oR15R16R17i549R18i548gR19r42gajy14:hxsl.Component:3:0hR14oR15R16R17i551R18i548gR19jR11:3:0goR3jR4:1:1oR6r59R8y18:killAlphaThresholdR10r91R32ajR33:7:2d0d1hR13i-34gR14oR15R16R17i572R18i554gR19r91gR14oR15R16R17i572R18i548gR19r91goR3jR4:0:1jy10:hxsl.Const:3:1zR14oR15R16R17i576R18i575gR19r91gR14oR15R16R17i576R18i548gR19r74gR14oR15R16R17i576R18i535gR19r74goR3jR4:11:0R14oR15R16R17i586R18i579gR19r28gnR14oR15R16R17i586R18i531gR19r28goR3jR4:10:3oR3jR4:1:1oR6r59R8y8:additiveR10r74R32ajR33:0:1nhR13i-31gR14oR15R16R17i604R18i596gR19r74goR3jR4:5:3jR5:20:1jR5:0:0oR3jR4:1:1oR6r10R8y10:pixelColorR10jR11:5:2i4r11R13i-37gR14oR15R16R17i622R18i612gR19r125goR3jR4:1:1r41R14oR15R16R17i627R18i626gR19r42gR14oR15R16R17i627R18i612gR19r125goR3jR4:5:3jR5:20:1jR5:1:0oR3jR4:1:1r124R14oR15R16R17i653R18i643gR19r125goR3jR4:1:1r41R14oR15R16R17i658R18i657gR19r42gR14oR15R16R17i658R18i643gR19r125gR14oR15R16R17i658R18i592gR19r28goR3jR4:10:3oR3jR4:1:1oR6r59R8y13:specularAlphaR10r74R32ajR33:0:1nhR13i-33gR14oR15R16R17i681R18i668gR19r74goR3jR4:5:3jR5:20:1r134oR3jR4:1:1oR6r10R8y9:specColorR10jR11:5:2i3r11R13i-38gR14oR15R16R17i698R18i689gR19r157goR3jR4:9:2oR3jR4:1:1r41R14oR15R16R17i703R18i702gR19r42gar88r88r88hR14oR15R16R17i707R18i702gR19jR11:5:2i3r11gR14oR15R16R17i707R18i689gR19r157gnR14oR15R16R17i707R18i664gR19r28ghR14oR15R16R17i713R18i486gR19r28gR6jR23:1:0R24oR6r31R8y8:fragmentR10jR11:13:1aoR1ahR26r28ghR13i-40gR26r28ghR8y18:h3d.shader.Texturey4:varsar19r115r73r148r93r58r9r124r156r30r175hg"
h3d_shader_UVDelta.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey12:calculatedUVy4:typejy9:hxsl.Type:5:2i2jy12:hxsl.VecType:1:0y2:idi-118gy1:poy4:filey73:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FUVDelta.hxy3:maxi209y3:mini197gy1:tr12goR3jR4:5:3jR5:0:0oR3jR4:5:3jR5:1:0oR3jR4:1:1r9R14oR15R16R17i224R18i212gR19r12goR3jR4:1:1oR6jR7:2:0R8y7:uvScaleR10jR11:5:2i2r11R13i-117gR14oR15R16R17i234R18i227gR19r25gR14oR15R16R17i234R18i212gR19jR11:5:2i2r11goR3jR4:1:1oR6r24R8y7:uvDeltaR10jR11:5:2i2r11R13i-116gR14oR15R16R17i244R18i237gR19r33gR14oR15R16R17i244R18i212gR19jR11:5:2i2r11gR14oR15R16R17i244R18i197gR19r12ghR14oR15R16R17i250R18i191gR19jR11:0:0gR6jy17:hxsl.FunctionKind:0:0y3:refoR6jR7:6:0R8y6:vertexR10jR11:13:1aoR1ahy3:retr43ghR13i-119gR25r43ghR8y18:h3d.shader.UVDeltay4:varsar32r23r9r45hg"
h3d_shader_VertexColorAlpha.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:10:3oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:2:0y4:namey8:additivey4:typejy9:hxsl.Type:2:0y10:qualifiersajy17:hxsl.VarQualifier:0:1nhy2:idi-123gy1:poy4:filey82:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FVertexColorAlpha.hxy3:maxi245y3:mini237gy1:tr10goR3jR4:5:3jy16:haxe.macro.Binop:20:1jR20:0:0oR3jR4:1:1oR5jR6:4:0R7y10:pixelColorR9jR10:5:2i4jy12:hxsl.VecType:1:0R13i-122gR14oR15R16R17i263R18i253gR19r22goR3jR4:1:1oR5jR6:1:0R7y5:colorR9jR10:5:2i4r21y6:parentoR5r27R7y5:inputR9jR10:12:1ar26hR13i-120gR13i-121gR14oR15R16R17i278R18i267gR19r28gR14oR15R16R17i278R18i253gR19r22goR3jR4:5:3jR20:20:1jR20:1:0oR3jR4:1:1r19R14oR15R16R17i304R18i294gR19r22goR3jR4:1:1r26R14oR15R16R17i319R18i308gR19r28gR14oR15R16R17i319R18i294gR19r22gR14oR15R16R17i319R18i233gR19jR10:0:0ghR14oR15R16R17i325R18i227gR19r49gR5jy17:hxsl.FunctionKind:1:0y3:refoR5jR6:6:0R7y8:fragmentR9jR10:13:1aoR1ahy3:retr49ghR13i-124gR29r49ghR7y27:h3d.shader.VertexColorAlphay4:varsar29r19r8r53hg"
h3d_shader_VolumeDecal.SRC = "oy4:funsaoy4:argsahy4:exproy1:ejy13:hxsl.TExprDef:4:1aoR3jR4:5:3jy16:haxe.macro.Binop:4:0oR3jR4:1:1oy4:kindjy12:hxsl.VarKind:4:0y4:namey17:transformedNormaly4:typejy9:hxsl.Type:5:2i3jy12:hxsl.VecType:1:0y2:idi-151gy1:poy4:filey77:C%3A%5CHaxeToolkit%5Chaxe%5Clib%5Cheaps%2Fgit%2Fh3d%2Fshader%2FVolumeDecal.hxy3:maxi282y3:mini265gy1:tr12goR3jR4:1:1oR6jR7:2:0R8y6:normalR10jR11:5:2i3r11R13i-164gR14oR15R16R17i291R18i285gR19r18gR14oR15R16R17i291R18i265gR19r12ghR14oR15R16R17i297R18i259gR19jR11:0:0gR6jy17:hxsl.FunctionKind:0:0y3:refoR6jR7:6:0R8y6:vertexR10jR11:13:1aoR1ahy3:retr25ghR13i-166gR24r25goR1ahR2oR3jR4:4:1aoR3jR4:7:2oR6r10R8y6:matrixR10jR11:7:0R13i-168goR3jR4:5:3jR5:1:0oR3jR4:1:1oR6jR7:0:0R8y15:inverseViewProjR10r39y6:parentoR6r44R8y6:cameraR10jR11:12:1aoR6r44R8y4:viewR10r39R27r45R13i-126goR6r44R8y4:projR10r39R27r45R13i-127goR6r44R8y8:positionR10jR11:5:2i3r11R27r45R13i-128goR6r44R8y8:projDiagR10jR11:5:2i3r11R27r45R13i-129goR6r44R8y8:viewProjR10r39R27r45R13i-130gr43oR6r44R8y5:zNearR10jR11:3:0R27r45R13i-132goR6r44R8y4:zFarR10r55R27r45R13i-133goR6jR7:3:0R8y3:dirR10jR11:5:2i3r11R27r45R13i-134ghR13i-125gR13i-131gR14oR15R16R17i364R18i342gR19r39goR3jR4:1:1oR6r44R8y16:modelViewInverseR10r39R27oR6r44R8y6:globalR10jR11:12:1aoR6r44R8y4:timeR10r55R27r65R13i-136goR6r44R8y9:pixelSizeR10jR11:5:2i2r11R27r65R13i-137goR6r44R8y9:modelViewR10r39R27r65y10:qualifiersajy17:hxsl.VarQualifier:3:0hR13i-138gr64hR13i-135gR42ar72hR13i-139gR14oR15R16R17i390R18i367gR19r39gR14oR15R16R17i390R18i342gR19r39gR14oR15R16R17i391R18i329gR19r25goR3jR4:7:2oR6r10R8y9:screenPosR10jR11:5:2i2r11R13i-169goR3jR4:5:3jR5:2:0oR3jR4:9:2oR3jR4:1:1oR6r10R8y17:projectedPositionR10jR11:5:2i4r11R13i-152gR14oR15R16R17i429R18i412gR19r89gajy14:hxsl.Component:0:0jR46:1:0hR14oR15R16R17i432R18i412gR19r83goR3jR4:9:2oR3jR4:1:1r88R14oR15R16R17i452R18i435gR19r89gajR46:3:0hR14oR15R16R17i454R18i435gR19r55gR14oR15R16R17i454R18i412gR19r83gR14oR15R16R17i455R18i396gR19r25goR3jR4:7:2oR6r10R8y3:tuvR10jR11:5:2i2r11R13i-170goR3jR4:5:3jR5:0:0oR3jR4:5:3r41oR3jR4:1:1r82R14oR15R16R17i479R18i470gR19r83goR3jR4:8:2oR3jR4:2:1jy12:hxsl.TGlobal:38:0R14oR15R16R17i486R18i482gR19jR11:13:1ahgaoR3jR4:0:1jy10:hxsl.Const:3:1d0.5R14oR15R16R17i490R18i487gR19r55goR3jR4:0:1jR49:3:1d-0.5R14oR15R16R17i496R18i492gR19r55ghR14oR15R16R17i497R18i482gR19jR11:5:2i2r11gR14oR15R16R17i497R18i470gR19jR11:5:2i2r11goR3jR4:8:2oR3jR4:2:1r120R14oR15R16R17i504R18i500gR19r124gaoR3jR4:0:1jR49:3:1d0.5R14oR15R16R17i508R18i505gR19r55goR3jR4:0:1jR49:3:1d0.5R14oR15R16R17i513R18i510gR19r55ghR14oR15R16R17i514R18i500gR19jR11:5:2i2r11gR14oR15R16R17i514R18i470gR19r111gR14oR15R16R17i515R18i460gR19r25goR3jR4:7:2oR6r10R8y3:ruvR10jR11:5:2i4r11R13i-171goR3jR4:8:2oR3jR4:2:1jR48:40:0R14oR15R16R17i534R18i530gR19jR11:13:1ahgaoR3jR4:1:1r82R14oR15R16R17i550R18i541gR19r83goR3jR4:8:2oR3jR4:2:1jR48:53:0R14oR15R16R17i563R18i557gR19jR11:13:1aoR1aoR8y5:valueR10jR11:5:2i4r11ghR24r55ghgaoR3jR4:8:2oR3jR4:2:1jR48:33:0R14oR15R16R17i572R18i564gR19jR11:13:1aoR1aoR8y1:_R10jR11:10:0goR8y2:uvR10jR11:5:2i2r11ghR24jR11:5:2i4r11ghgaoR3jR4:1:1oR6r44R8y8:depthMapR10r195R13i-162gR14oR15R16R17i572R18i564gR19r195goR3jR4:1:1r110R14oR15R16R17i580R18i577gR19r111ghR14oR15R16R17i581R18i564gR19r198ghR14oR15R16R17i582R18i557gR19r55goR3jR4:0:1jR49:3:1i1R14oR15R16R17i590R18i589gR19r55ghR14oR15R16R17i596R18i530gR19r162gR14oR15R16R17i597R18i520gR19r25goR3jR4:7:2oR6r10R8y4:wposR10r198R13i-172goR3jR4:5:3r41oR3jR4:1:1r161R14oR15R16R17i616R18i613gR19r162goR3jR4:1:1r38R14oR15R16R17i625R18i619gR19r39gR14oR15R16R17i625R18i613gR19r198gR14oR15R16R17i626R18i602gR19r25goR3jR4:7:2oR6r10R8y4:pposR10r198R13i-173goR3jR4:5:3r41oR3jR4:1:1r161R14oR15R16R17i645R18i642gR19r162goR3jR4:1:1r43R14oR15R16R17i670R18i648gR19r39gR14oR15R16R17i670R18i642gR19r198gR14oR15R16R17i671R18i631gR19r25goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y24:pixelTransformedPositionR10jR11:5:2i3r11R13i-150gR14oR15R16R17i700R18i676gR19r249goR3jR4:5:3r85oR3jR4:9:2oR3jR4:1:1r234R14oR15R16R17i707R18i703gR19r198gar93r94jR46:2:0hR14oR15R16R17i711R18i703gR19jR11:5:2i3r11goR3jR4:9:2oR3jR4:1:1r234R14oR15R16R17i718R18i714gR19r198gar102hR14oR15R16R17i720R18i714gR19r55gR14oR15R16R17i720R18i703gR19r261gR14oR15R16R17i720R18i676gR19r249goR3jR4:5:3r7oR3jR4:1:1oR6r10R8y12:calculatedUVR10jR11:5:2i2r11R13i-165gR14oR15R16R17i738R18i726gR19r276goR3jR4:5:3r113oR3jR4:5:3r41oR3jR4:1:1oR6r17R8y5:scaleR10jR11:5:2i2r11R13i-163gR14oR15R16R17i746R18i741gR19r283goR3jR4:3:1oR3jR4:5:3r85oR3jR4:9:2oR3jR4:1:1r221R14oR15R16R17i754R18i750gR19r198gar93r94hR14oR15R16R17i757R18i750gR19jR11:5:2i2r11goR3jR4:9:2oR3jR4:1:1r221R14oR15R16R17i764R18i760gR19r198gar102hR14oR15R16R17i766R18i760gR19r55gR14oR15R16R17i766R18i750gR19r295gR14oR15R16R17i767R18i749gR19r295gR14oR15R16R17i767R18i741gR19jR11:5:2i2r11goR3jR4:0:1jR49:3:1d0.5R14oR15R16R17i773R18i770gR19r55gR14oR15R16R17i773R18i741gR19r309gR14oR15R16R17i773R18i726gR19r276goR3jR4:10:3oR3jR4:5:3jR5:9:0oR3jR4:8:2oR3jR4:2:1jR48:21:0R14oR15R16R17i786R18i783gR19jR11:13:1aoR1aoR8y1:aR10r55goR8y1:bR10r55ghR24r55ghgaoR3jR4:8:2oR3jR4:2:1r323R14oR15R16R17i790R18i787gR19jR11:13:1ar327hgaoR3jR4:9:2oR3jR4:1:1r275R14oR15R16R17i803R18i791gR19r276gar93hR14oR15R16R17i805R18i791gR19r55goR3jR4:9:2oR3jR4:1:1r275R14oR15R16R17i819R18i807gR19r276gar94hR14oR15R16R17i821R18i807gR19r55ghR14oR15R16R17i822R18i787gR19r55goR3jR4:8:2oR3jR4:2:1r323R14oR15R16R17i827R18i824gR19jR11:13:1ar327hgaoR3jR4:5:3jR5:3:0oR3jR4:0:1jR49:3:1i1R14oR15R16R17i829R18i828gR19r55goR3jR4:9:2oR3jR4:1:1r275R14oR15R16R17i844R18i832gR19r276gar93hR14oR15R16R17i846R18i832gR19r55gR14oR15R16R17i846R18i828gR19r55goR3jR4:5:3r364oR3jR4:0:1jR49:3:1i1R14oR15R16R17i849R18i848gR19r55goR3jR4:9:2oR3jR4:1:1r275R14oR15R16R17i864R18i852gR19r276gar94hR14oR15R16R17i866R18i852gR19r55gR14oR15R16R17i866R18i848gR19r55ghR14oR15R16R17i867R18i824gR19r55ghR14oR15R16R17i868R18i783gR19r55goR3jR4:0:1jR49:3:1zR14oR15R16R17i872R18i871gR19r55gR14oR15R16R17i872R18i783gR19jR11:2:0goR3jR4:11:0R14oR15R16R17i882R18i875gR19r25gnR14oR15R16R17i882R18i779gR19r25ghR14oR15R16R17i888R18i323gR19r25gR6jR21:1:0R22oR6r28R8y8:fragmentR10jR11:13:1aoR1ahR24r25ghR13i-167gR24r25ghR8y22:h3d.shader.VolumeDecaly4:varsar45r65oR6jR7:1:0R8y5:inputR10jR11:12:1aoR6r418R8R31R10jR11:5:2i3r11R27r417R13i-141goR6r418R8R20R10jR11:5:2i3r11R27r417R13i-142ghR13i-140goR6r10R8y6:outputR10jR11:12:1aoR6r10R8R31R10jR11:5:2i4r11R27r425R13i-144goR6r10R8y5:colorR10jR11:5:2i4r11R27r425R13i-145goR6r10R8y5:depthR10r55R27r425R13i-146goR6r10R8R20R10jR11:5:2i3r11R27r425R13i-147ghR13i-143goR6r10R8y16:relativePositionR10jR11:5:2i3r11R13i-148goR6r10R8y19:transformedPositionR10jR11:5:2i3r11R13i-149gr248r9r88oR6r10R8y10:pixelColorR10jR11:5:2i4r11R13i-153goR6r10R8R68R10r55R13i-154goR6r10R8y8:screenUVR10jR11:5:2i2r11R13i-155goR6r10R8y9:specPowerR10r55R13i-156goR6r10R8y9:specColorR10jR11:5:2i3r11R13i-157gr202r282r16r275r27r411hg"
haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
haxe_MainLoop.pending = None
def _hx_init_haxe_xml_Parser_escapes():
    def _hx_local_0():
        h = haxe_ds_StringMap()
        h.h["lt"] = "<"
        h.h["gt"] = ">"
        h.h["amp"] = "&"
        h.h["quot"] = "\""
        h.h["apos"] = "'"
        return h
    return _hx_local_0()
haxe_xml_Parser.escapes = _hx_init_haxe_xml_Parser_escapes()
def _hx_init_hxd_fmt_hmd_Material_DEFAULT_FLAGS():
    def _hx_local_0():
        f = 0
        f = (f | ((1 << hxd_fmt_hmd_MaterialFlag.HasLighting.index)))
        f = (f | ((1 << hxd_fmt_hmd_MaterialFlag.CastShadows.index)))
        f = (f | ((1 << hxd_fmt_hmd_MaterialFlag.ReceiveShadows.index)))
        return f
    return _hx_local_0()
hxd_fmt_hmd_Material.DEFAULT_FLAGS = _hx_init_hxd_fmt_hmd_Material_DEFAULT_FLAGS()
hxd_fmt_hmd_Reader.BLEND = Type.allEnums(h2d_BlendMode)
hxd_fmt_hmd_Reader.CULLING = Type.allEnums(h3d_mat_Face)
hxd_impl_Tmp.bytes = list()

Dumper.main()
haxe_EntryPoint.run()
